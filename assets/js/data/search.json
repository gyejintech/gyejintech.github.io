[
  
  {
    "title": "CSS 레이아웃",
    "url": "/posts/css_layout/",
    "categories": "Develop, Css",
    "tags": "Css",
    "date": "2024-09-04 12:33:00 +0900",
    





    
    "snippet": "  레이아웃(Layout)이란? : 구성 요소를 공간에 효과적으로 배열하는 일,  또는 그 기술웹 요소를 올바른 장소에 배치하는 기술을 말한다.CSS 레이아웃 기술은 형제 요소들을 가지런히 정렬할 수 있게 해주며 요소가 컨테이너 내부에 어떤 위치에 놓이게 될지 결정할 수 있다.Flexbox  플렉스박스는 행 또는 열을 주축으로 설정하여 웹 요소를 배치...",
    "content": "  레이아웃(Layout)이란? : 구성 요소를 공간에 효과적으로 배열하는 일,  또는 그 기술웹 요소를 올바른 장소에 배치하는 기술을 말한다.CSS 레이아웃 기술은 형제 요소들을 가지런히 정렬할 수 있게 해주며 요소가 컨테이너 내부에 어떤 위치에 놓이게 될지 결정할 수 있다.Flexbox  플렉스박스는 행 또는 열을 주축으로 설정하여 웹 요소를 배치 및 정렬하는 1차원 레이아웃 방식을 말한다.요소의 배치와 정렬은 플렉스 컨테이너와 플렉스 아이템간의 상호작용을 통해 결정된다.      플렉스 컨테이너 : 플렉스박스 방식으로 레이아웃을 결정할 요소    플렉스 아이템: 플렉스 컨테이너 내부에서 플렉스박스 방식으로 배치되는 요소   ##Flexbox 기본 사용법Flexbox를 사용하기 위해서는 먼저 플렉스 컨테이너를 지정해주어야 한다 display: flex;ul{ display:flex;}Flexbox의 옵션들- flex-direction  플렉스 컨테이너의 주축을 결정하는 속성이다. 행은 가로 축을, 열은 세로 축을 주축으로 한다                                      속성값      의미              row      기본값, 주축은 행이고 방향은 콘텐츠의 방향과 동일              row-reverse      주축은 행이고 방향은 콘텐츠의 방향과 반대              column      주축은 열이고 방향은 콘텐츠의 방향과 동일              column-reverse      주축은 열이고 방향은 콘텐츠의 방향과 반대      - flex-wrap  플렉스 아이템들이 강제로 한줄에 배치되게 할 것인지, 또는 가능한 영역 내에서 벗어나지 않고 여러행으로 나누어 표현 할 것인지를 결정하는 속성                                      속성값      의미              nowrap      기본값. 공간이 부족하더라도 요소를 한줄에 배치              wrap      공간 크기에 따라 요소가 여러 행에 걸쳐 배치              wrap-reverse      wrap과 동일하나 요소 나열되는 시작점과 끝점이 반대      - justify-content  플렉스아이템들이 플렉스박스 주축을 따라 배치될 때, 요소 사이의 공간을 분배하는 방식을 결정                                      속성값      의미              flex-start      주축의 시작점으로부터 끝점을 향해 배치              flex-end      주축의 끝점으로부터 시작점을 향해 배치              center      주축의 중심부에 배치              space-between      주축에서 일정한 간격을 둔 채 양끝 정렬 배치              space-around      모든 요소가 동일한 여백을 갖도록 배치              space-evenly      모든 요소 사이의 간격을 동일하게 유지해 배치      - align-items   플렉스 컨테이너의 교차축 위에서 플렉스아이템들이 어떤 식으로 정렬될 것인지를 스스로 결정                                      속성값      의미              stretch      플렉스아이템이 교차축 길이에 맞춰 늘어남, but 너비 or 높이가 우선              flex-start      교차축의 시작점으로부터 끝점을 향해 배치              flex-end      교차축의 끝점으로부터 시작점을 향해 배치              center      교차축의 중심부에 배치      - align-self  각각의 플렉스아이템이 교차축에서 어떤 식으로 정렬될 것인지를 스스로 결정                                      속성값      의미              stretch      플렉스아이템이 교차축 길이에 맞춰 늘어남, but 너비 or 높이가 우선              flex-start      교차축의 시작점으로부터 끝점을 향해 배치              flex-end      교차축의 끝점으로부터 시작점을 향해 배치              center      교차축의 중심부에 배치      - align-content  교차축 위에서 justify-content와 동일하게 사용할 수 있는 속성, 다음 두 조건이 만족되면서 여유 공간이 있을 때만 동작할 수 있다    - 아이템을 배치하기 위해 필요한 공간보다 플렉스 컨테이너가 더 클 때     - flex-wrap의 값이 wrap으로 지정되어 있을 때- flex-grow  플렉스아이템이 기본 크기보다 더 커질 수 있는지를 결정하고, 플렉스 컨테이너 내부에서 할당받을 수 있는 공간을 상대적으로 정의할 수 있는 속성                                      속성값      의미              숫자      음수는 허용되지 않는다. 양의 정수, 양의 실수 가능      - flex-shrink  플렉스아이템이 기본 크기보다 더 작아질 수 있는지를 결정하고, 플렉스 컨테이너 내부에서 할당받을 수 있는 공간을 상대적으로 정의할 수 있는 속성                                      속성값      의미              숫자      음수는 허용되지 않는다. 양의 정수, 양의 실수 가능      - flex-basis   플렉스아이템 초기 크기를 지정한다. box-sizing이 따로 설정되지 않은 경우, 콘텐츠 박스의 크기를 결정하게 된다. 기본값은 auto이다                                      속성값      의미              단위가 있는 값      width 속성을 정의할 때와 동일한 방식      - flex  flex는 flex-grow, flex-shrink, flex-basis 세 가지 속성을 정의할 수 있는 단축 속성이다(순서대로)**.item{  flex: 0 0 200px;}"
  },
  
  {
    "title": "Javascript join 메서드",
    "url": "/posts/javascript_join/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-09-01 12:33:00 +0900",
    





    
    "snippet": "join 메서드 이해하기  join 메서드는 배열 요소를 모두 연결해 하나의 문자열로 반환한다join 메서드 사용해보기let arr = [\"안녕\",\"자바스크립트\",\"반가워\"];console.log(arr.join()); // 출력: 안녕,자바스크립트,반가워console.log(arr.join(\"-\")); // 출력: 안녕-자바스크립트-반가워",
    "content": "join 메서드 이해하기  join 메서드는 배열 요소를 모두 연결해 하나의 문자열로 반환한다join 메서드 사용해보기let arr = [\"안녕\",\"자바스크립트\",\"반가워\"];console.log(arr.join()); // 출력: 안녕,자바스크립트,반가워console.log(arr.join(\"-\")); // 출력: 안녕-자바스크립트-반가워"
  },
  
  {
    "title": "Javascript includes 메서드",
    "url": "/posts/javascript_includes/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-09-01 12:33:00 +0900",
    





    
    "snippet": "includes 메서드 이해하기  includes 메서드는 배열에 특정 요소가 있는지를 판단할 때 사용되는 메서드이다 배열에서 주어진 요소가 포함되어 있으면 true를 그렇지 않으면 false를 반환한다includes 메서드 사용해보기const arr = [1,2,3,4,5];console.log(arr.includes(3)); //출력 : truec...",
    "content": "includes 메서드 이해하기  includes 메서드는 배열에 특정 요소가 있는지를 판단할 때 사용되는 메서드이다 배열에서 주어진 요소가 포함되어 있으면 true를 그렇지 않으면 false를 반환한다includes 메서드 사용해보기const arr = [1,2,3,4,5];console.log(arr.includes(3)); //출력 : trueconsole.log(arr.includes(7)); //출력 : false"
  },
  
  {
    "title": "React Map 예제",
    "url": "/posts/react_example_map/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-08-01 12:33:00 +0900",
    





    
    "snippet": "Map 함수 이해하기Map 함수는 React에서 제공하는 함수는 아니며 Javascript 언어에서 사용할 수 있는 함수이다.Map함수를 사용하면 콜백 함수를 이용해 각각의 배열 요소를 호출해서 그 값을 변환할 수 있게 해준다. React예제로 Map을 확인하는 이유는 React에서 어떠한 데이터를 반복적으로 렌더링하거나 컴포넌트를 렌더링할 때 Map...",
    "content": "Map 함수 이해하기Map 함수는 React에서 제공하는 함수는 아니며 Javascript 언어에서 사용할 수 있는 함수이다.Map함수를 사용하면 콜백 함수를 이용해 각각의 배열 요소를 호출해서 그 값을 변환할 수 있게 해준다. React예제로 Map을 확인하는 이유는 React에서 어떠한 데이터를 반복적으로 렌더링하거나 컴포넌트를 렌더링할 때 Map함수를 많이 사용함으로, 이번 예제를 통해 Map함수에대해 자세히 알아보도록 한다✏️리액트에서 동적인 배열을 렌더링해야 할 때는 자바스크립트 배열 내장함수인 map()을 사용하여 일반 데이터 배열을 리액트 엘리먼트로 이루어진 배열로 변환이 가능하다 실제로 리액트에서 배열은 게시글, 리스트, 피드를 표시하는데에 자주사용된다Map 함수 사용법arr.map(callbackFunction(currentValue, index, array), thisArg);  map 함수는 파라미터로 전달된 함수를 사용해, 배열 각 요소를 원하는 규칙에 따라 변환한 다음 새로운 배열을 생성한다.   callback function을 작성할 때 맨 앞의 인자는 현재 배열(arr) 내의 값들을 의미하며, 두 번째 인자는 현재 배열 내 값의 인덱스를 의미하고, 마지막 인자는 현재 배열을 의미한다.   thisArg는 callbackFunction 안에서 사용할 this 레퍼런스를 의미한다.  *key속성을 지정하지 않은 기존 데이터 목록에 새로운 데이터를 추가하면 리액트는 새로운 아이템을 어디에 추가,삭제,변경할지를 모른다 따라서 성능적으로 비효율적인 결과를 얻게되어 key속성은 꼭 사용하도록 하자React 예제를 통해 Map 사용해보기먼저 임시배열(dummyList)을 만들어서 데이터를 전달하여 그 데이터를 렌더링하는것부터 시작하도록 한다예제로는 쇼핑몰 아이템을 렌더링하는것으로 App.js, ShopList.js 두개의 파일로 테스트를 진행한다App.jsimport './App.css';import ShopList from \"./ShopList\"const dummyList = [  {    id: 1,    author: \"선풍기\",    content: \"첫번째\",    emotion: 1,    created_date: new Date().getTime()  },  {    id: 2,    author: \"가스레인지\",    content: \"두번째\",    emotion: 2,    created_date: new Date().getTime()  },  {    id: 3,    author: \"모니터\",    content: \"3번째\",    emotion: 3,    created_date: new Date().getTime()  }]const App = () =&gt; {  return (    &lt;div className=\"App\"&gt;      &lt;ShopList shopList={dummyList}/&gt;    &lt;/div&gt;  );}export default App;ShopList.jsconst ShopList=({shopList})=&gt;{    return (    &lt;div className=\"ShopList\"&gt;        &lt;h2&gt;쇼핑리스트&lt;/h2&gt;        &lt;h4&gt;{shopList.length}개의 아이템이 있습니다.&lt;/h4&gt;        &lt;div&gt;            {shopList.map((it)=&gt;(                &lt;div key={it.id}&gt;                    &lt;div&gt;작성자: {it.author}&lt;/div&gt;                    &lt;div&gt;내용: {it.content}&lt;/div&gt;                    &lt;div&gt;감정: {it.emotion}&lt;/div&gt;                    &lt;div&gt;작성시간(ms): {it.created_date}&lt;/div&gt;                    &lt;hr /&gt;                    &lt;br /&gt;                &lt;/div&gt;            ))}        &lt;/div&gt;    &lt;/div&gt;    );};export default ShopList;"
  },
  
  {
    "title": "React Route",
    "url": "/posts/react_Route/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-07-16 12:33:00 +0900",
    





    
    "snippet": "라우팅 이해하기  라우팅이란 웹 서비스에있어서 페이지 이동을 수행시켜주는 기능이다 즉,사용자가 요청한 URL에 따라 해당 URL에 맞는 페이지로 이동 시켜서 보여주는 것이다 리액트의 라우팅 구현은 웹 페이지를 어디서 만드느냐에 따라 적절한 페이지를 반환하는 일련의 과정이며 서버 사이드 렌더링과, 클라이언트 사이드 렌더링으로 구분된다 리액트는 클라이언트...",
    "content": "라우팅 이해하기  라우팅이란 웹 서비스에있어서 페이지 이동을 수행시켜주는 기능이다 즉,사용자가 요청한 URL에 따라 해당 URL에 맞는 페이지로 이동 시켜서 보여주는 것이다 리액트의 라우팅 구현은 웹 페이지를 어디서 만드느냐에 따라 적절한 페이지를 반환하는 일련의 과정이며 서버 사이드 렌더링과, 클라이언트 사이드 렌더링으로 구분된다 리액트는 클라이언트 사이드 렌더링 방식을 채택하며 두 방식의 차이는 아래 SSR, CSR 를 이해하자리액트 라우터 이해하기라우팅을 위한 기능과 코드를 개발자 모두가 알 필요는 없다 리액트의 라우터라는 페이지 라우팅 전용 라이브러리를 사용하면 굳이 개발자가 구현하지 않아도 필요한 기능을 손쉽게 구현할 수 있다 리액트 라우터 설치하기npm i react-router-dom위 명령어로 설치 후 package.json 파일에서 설치된 react-router-dom의 버전을 확인하자리액트 라우터 사용법1. 리액트 라우터 컴포넌트로 감싸주기/src/index.js// 리액트 라우터가 제공하는 BrowserRouter 컴포넌트를 가져온다  import { BrowserRouter } from \"react-router-dom\";import React from \"react\";import ReactDOM from \"react-dom/client\";import \"./index.css\";import App from \"./App\";// 위에서 가져온 BrowserRouter 컴포넌트를 최상위 부모 컴포넌트로 설정한다const root = ReactDOM.createRoot(document.getElementById(\"root\"));root.render(    &lt;BrowserRouter&gt;        &lt;App /&gt;    &lt;/BrowserRouter&gt;);2. 페이지 컴포넌트 만들기여러 페이지로 구성된 리액트 앱을 리액트 라우터로 만들도록한다 그 전에 페이지 역할을 담당할 컴포넌트부터 만들어야 한다여기서는 예제로 /src/pages/ 라는 폴더를 만든 후 컴포넌트들을 모아놨다고 과정하여 진행한다./src/pages/Home.jsconst Home = () =&gt; {    return &lt;div&gt;Home 페이지&lt;/div&gt;;};export default Home;/src/pages/New.jsconst New = () =&gt; {    return &lt;div&gt;New 페이지&lt;/div&gt;;};export default New;/src/pages/Diary.jsconst Diary = () =&gt; {    return &lt;div&gt;Diary 페이지&lt;/div&gt;;};export default Diary;/src/pages/Edit.jsconst Edit = () =&gt; {    return &lt;div&gt;Edit 페이지&lt;/div&gt;;};export default Edit;URL 경로에 따라 페이지를 렌더링하도록 페이지 라우팅 구현각 페이지의 컴포넌트 구현이 되었다면 부모 컴포넌트인 App.js 에서 react-router-dom이 제공하는 Routes와 Route 컴포넌트를 이용하여 렌더링 하도록 설정한다src/App.jsimport { Routes, Route } from \"react-router-dom\";import \"./App.css;import Home from \"./pages/Home\";import New from \"./pages/New\";import Diary from \"./pages/Diary\";import Edit from \"./pages/Edit\";function App() {    return (        &lt;div className=\"App\"&gt;            &lt;Routes&gt;                &lt;Route path=\"/\" element ={&lt;Home /&gt;} /&gt;                &lt;Route path=\"/new\" element ={&lt;New /&gt;} /&gt;                &lt;Route path=\"/diary\" element ={&lt;Diary /&gt;} /&gt;                &lt;Route path=\"/edit\" element ={&lt;Edit /&gt;} /&gt;            &lt;/Routes&gt;    );}export default App;SPA, MPA 이해하기  SPA(Single Page Application) : 한개의 페이지를 가진 어플리케이션이다, SPA는 클라이언트 사이드 렌더링이라 부르기도하며 초기 렌더링 후 데이터만 받아오기 때문에 상대적으로 서버 요청이 적다, SPA로 개발된 웹사이트에서는 카테고리에 있는 각 메뉴를 선택하면 보통 헤더는 고정되어 있는 상태로 메인화면 혹은 클릭한 부분만 변경되어 렌더링되어진다. 프론트 엔드와 백엔드 분리로 개발업무 분업화 및 협업이 용이하여 개발이 상대적으로 효율적이다 대부분 CSR로 렌더링하게 된다.MPA(Multi Page Application) : 탭을 이동할 때마다 서버로부터 새로운 HTML을 새로 받아와서 페이지 전체를 렌더링 하는 전통적인 웹 페이지 구성 방식을 갖는다 대부분 SSR로 렌더링을 하게된다SSR, CSR 이해하기  SSR(Server Side Rendering) : 과거나 현재에도 많은 웹사이트들은 페이지를 이동할 때마다 서버에 새로운 페이지를 요청하여 처리하는 방식인 SSR방식을 사용하고 있다 페이지 요청을 받은 서버는 렌더링을 마치고 Data가 결합된 HTML파일을 내려주는 방식으로 처리하며 SPA에 비해 서버 의존도가 높아 요청이 많은 서비스는 부하가 걸릴 수 있다CSR(Client Side Rendering) : 최초 서버 요청시에 HTML을 비롯해 CSS, Javascript등 각종 리소스를 받아온다 이후에는 서버에 데이터만 요청하게 되고 자바스크립트로 뷰를 컨드롤하게 된다 당연히 초기 요청 때 SSR 보다 많은 리소스를 요청하기 때문에, 렌더링은 속도는 SSR이 더 빠르다 하지만 이후 다른 페이지로의 이동시에는 SSR 보다 빠른 페이지 전환 속도와 더 나은 사용자 경험을 제공한다."
  },
  
  {
    "title": "React Context",
    "url": "/posts/react_Context/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-07-16 12:33:00 +0900",
    





    
    "snippet": "Context 이해하기  Context란 리액트 컴포넌트의 트리 전체를 대상으로 데이터를 공급하는 기능이다컴포넌트 간에 데이터를 전달하는 방법중에 Props를 사용하여 전달할 수 있지만Props는 컴포넌트 트리에서 언제나 부모에서 자식으로 단방향으로 전달되어진다. 리액트에서는 자식의 자식, 즉 트리에서 2단계 이상 떨어져 있는 컴포넌트에 직접 데이터를...",
    "content": "Context 이해하기  Context란 리액트 컴포넌트의 트리 전체를 대상으로 데이터를 공급하는 기능이다컴포넌트 간에 데이터를 전달하는 방법중에 Props를 사용하여 전달할 수 있지만Props는 컴포넌트 트리에서 언제나 부모에서 자식으로 단방향으로 전달되어진다. 리액트에서는 자식의 자식, 즉 트리에서 2단계 이상 떨어져 있는 컴포넌트에 직접 데이터를 전달하는것은 불가능하다그러면 A컴포넌트 밑에 B컴포넌트가 있고 B컴포넌트 밑에 C, D컴포넌트가 존재한다고 과정했을 때,A컴포넌트가 C,D컴포넌트에 데이터를 전달하려면 어떻게해야 할까?B컴포넌트에 전달하고 B컴포넌트에서 다시 C,D로 뿌려줘야한다 이것을 마치 드릴로 땅을 파고 내려가는 것과 같다해서 Props Drilling문제라고 불린다.이를 해결하는 방법이 바로 Context이다 context를 이용하면 단계마다 일일이 props를 전달하지 않고도,컴포넌트 트리 전역에 데이터를 공급할 수 있다  ContextAPI란 Context를 만들고 다루는 리액트의 기능이다사용법Context를 생성시 반드시 컴포넌트 밖에서 생성해야 한다 만약 안에서 생성하게되면 해당 컴포넌트가 리렌더될 때마다 Context를 새롭게 생성하여 의도처럼 되지 않는다.// ContextAPI에서 새 Context를 만드는 createContext 기능을 사용하기 위해서는 react 라이브러리의 React 객체를 불러와야 한다 import React, {useContext} from 'react';// createContext 메서드를 호출해 새로운 Context를 만든다, 인수로 전달하는 값은 Context의 기본값으로 생략가능하다const MyContext = React.createContext(defaultValue);// Context.Provider는 Context 객체에 기본으로 포함된 컴포넌트이다// 위에서 생성한 MyContext의 Provider를 App컴포넌트의 자식으로 배치한 후 해당 Provider 밑으로 데이터를 공유하고자하는 자식 컴포넌트들을 배치함으로써 Props를 전달할 수 있다 // Props로 전달할 값들을 하기 예제처럼 Provider를 배치할때 value값으로 전달해두면 된다.// useContext를 이용하면 자신이 속한 그룹의 Contex가 제공하는 값을 불러올 수 있다// 만약 useContext를 호출한 컴포넌트가 인수로 전달한 Context 그룹에 속해 있지 않으면 오류가 발생한다.function App() {    const data = 'data';    return (        &lt;div&gt;            &lt;Header/&gt;            &lt;MyContext.Provider value={data}&gt;                &lt;Body/&gt;            &lt;/MyContext.Provider&gt;        &lt;/div&gt;    );   }function Body () {    // useContext를 호출하고 인수로 값을 공급할 Context를 전달한 후 함수 useContext는 해당 Context가 공급하는 값을 반환한다 반환한 값을 변수 data에 저장한다     const data = useContext(MyContext);}"
  },
  
  {
    "title": "React useMemo",
    "url": "/posts/react_useMemo/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-07-16 12:33:00 +0900",
    





    
    "snippet": "useMemo 이해하기  useMemo는 렌더링 중에 발생하는 연산량이 큰 함수의 결과값을 메모이제이션하며, 이전 결과값을 재사용할 수 있도록 도와준다  동일한 값을 리턴하는 함수를 반복적으로 호출할 경우 맨 처음 값을 메모리에 저장해서 필요할 때마다 또다시 계산하지 않고 메모리에서 꺼내서 재사용을 하는 기법이다.간단히 말해서 자주 필요한 값을 맨 처...",
    "content": "useMemo 이해하기  useMemo는 렌더링 중에 발생하는 연산량이 큰 함수의 결과값을 메모이제이션하며, 이전 결과값을 재사용할 수 있도록 도와준다  동일한 값을 리턴하는 함수를 반복적으로 호출할 경우 맨 처음 값을 메모리에 저장해서 필요할 때마다 또다시 계산하지 않고 메모리에서 꺼내서 재사용을 하는 기법이다.간단히 말해서 자주 필요한 값을 맨 처음 계산할 때 캐싱 해놓아서 그 값이 필요할 때마다 다시 계산을 하는 것이 아니라 캐시에서 꺼내서 사용하는 것이다.useMemo 남용할 경우 성능에 안좋아질 수 있다useMemo는 성능 최적화의 목적으로 사용되긴 하지만,무분별하게 사용할 경우 오히려 성능 저하를 초래할 수 있다.      메모이제이션 자체의 비용: 이 두 Hook을 사용하면 함수와 계산 결과를 캐싱하기 위한 메모리 사용량이 늘어난다. 게다가, 새롭게 계산되는 값이 일정 기간 동안 사용되지 않아도 메모리에 남아 있어야 하므로 메모리 관리의 측면에서 비효율적일 수 있다. (가비지 컬렉터가 무시)        의존성 배열의 관리: useCallback과 useMemo는 의존성 배열이 필요한데, 이 배열에 들어간 값들이 변경될 때마다 메모이제이션 된 값을 무효화하고 새로 계산한다. 이 과정에서 복잡성이 증가하며, 관리가 미흡한 경우 오히려 성능이 저하될 수 있다.        남용에 따른 실수: 무분별한 사용으로 인해 모든 함수나 결과값을 메모이제이션하려 할 때 실수가 발생할 가능성이 높아진다. 이로 인해 성능 최적화를 기대하는 대신 버그나 성능 저하를 초래할 수 있는 상황이 생길 수 있다.  useMemo 사용법useMemo는 첫 번째 인자로는 콜백함수, 두 번째 인자로는 의존성 배열을 받아 총 두 개의 인자를 받는다.const result = useMemo(() =&gt; {  return add();}, [value]);첫 번째 인자인 콜백 함수가 return 하는 값이 바로 useMemo가 return 하는 값, 즉 result의 값이 된다.두 번째 인자인 의존성 배열은 배열 안의 요소가 업데이트될 때마다 useMemo의 콜백 함수를 재실행시킨다. 콜백 함수를 재실행시킴으로써 메모리에 저장된 값은 업데이트되어 메모리에 새로 저장된다.빈 배열일 경우 제일 처음 마운트될 때만 값을 메모리에 저장하고 그 이후엔 메모리에 있는 값만 불러오게 된다"
  },
  
  {
    "title": "React useReducer",
    "url": "/posts/react_useReducer/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-07-04 12:33:00 +0900",
    





    
    "snippet": "useReducer 이해하기  useReducer는 useState와 같은 상태 관리, 상태 업데이트 훅이다변경할 값이 많을 때 즉 상태 관리할 데이터가 많을경우 유용하게 사용할 수 있다useReducer와 useState의 차이를 알기위해선 아래 코드를 확인해보자import { useState } from \"react\";function TestCom...",
    "content": "useReducer 이해하기  useReducer는 useState와 같은 상태 관리, 상태 업데이트 훅이다변경할 값이 많을 때 즉 상태 관리할 데이터가 많을경우 유용하게 사용할 수 있다useReducer와 useState의 차이를 알기위해선 아래 코드를 확인해보자import { useState } from \"react\";function TestComp() {  const [count, setCount] = useState(0);  const onIncrease = () =&gt; {    setCount(count + 1);  };  const onDecrease = () =&gt; {    setCount(count - 1);  };  return (    &lt;div&gt;      &lt;h4&gt; 테스트 컴포넌트 &lt;/h4&gt;      &lt;div&gt;        &lt;bold&gt;{count}&lt;/bold&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={onIncrease}&gt;+1&lt;/button&gt;        &lt;button onClick={onDecrease}&gt;-1&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default TestComp;먼저 위와 같이 +1 과 -1버튼으로 특정 변수의 값을 바꾸는 컴포넌트를 하나 생성하였다여기서 상태변화코드를 이해해야하는데 상태변화코드란 useState같이 상태데이터에 내용을 업데이트 즉 변경하게만드는 코드를 상태변화코드라고 한다 그럼 위에서 onIncrease함수와 onDecrease함수가 상태변화코드가 되겠다.그럼 만약에 onIncrease함수와 onDecrease함수를 다른 컴포넌트에서 관리하고 싶으면 어떻게해야 할까?useState를 이용해서 State를 생성하였다면 상태변화코드는 반드시 같은 컴포넌트 안에 작성해야 한다.하지만 useReducer를 사용한다면 상태변화코드를 컴포넌트 밖으로 분리가 가능해진다.  &lt;왜 상태변화코드를 밖에서 관리하나요?&gt;상태변화코드를 분리하는 이유는 하나의 컴포넌트에 모든 상태 변화 코드가 있으면 유지보수가 어려워지는 큰 단점이 존재하게된다또한 가독성을 해치기 때문에 코드의 최적화를 위해 상태변화코드를 분리해주는것이 좋다useReducer를 사용하는 방법useState코드를 삭제하고 아래 코드와 같이 useReducer로 변경해본다import { useReducer } from \"react\";function reducer(state, action) {  switch (action.type) {    case \"INCREASE\":      return state + action.data;    case \"DECREASE\":      return state - action.data;    case \"INIT\":      return 0;    default:      return state;  }}function TestComp() {  const [count, dispatch] = useReducer(reducer, 0);  return (    &lt;div&gt;      &lt;h4&gt; 테스트 컴포넌트 &lt;/h4&gt;      &lt;div&gt;        &lt;bold&gt;{count}&lt;/bold&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={() =&gt; dispatch({ type: \"INCREASE\", data: 1 })}&gt;          +1        &lt;/button&gt;        &lt;button onClick={() =&gt; dispatch({ type: \"DECREASE\", data: 1 })}&gt;          -1        &lt;/button&gt;        &lt;button onClick={() =&gt; dispatch({ type: \"INIT\", data: 0 })}&gt;          초기화        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default TestComp;  (1) 먼저 useReducer를 react로부터 불러온다  (2) 함수 reducer를 만들고 reducer에는 2개의 매개변수를 갖는다, 첫 번째 매개변수 state에는 현재 State의 값이 저장되며 두 번째 매개변수 action에는 함수 dispatch를 호출하면서 인수로 전달한 action 객체가 저장된다  (3) reducer가 반환하는 값은 새로운 State 값이 되며 action 객체의 type이 INCREASE면 기존 State 값에 action 객체의 data값을 더해 반환한다.  실무에서도 관리대상 상태 데이터가 적은 경우에는 useState를 사용하여 구현하지만 많은 경우에는 useReducer를 사용하여 구현한다"
  },
  
  {
    "title": "React 네이밍 규칙",
    "url": "/posts/react_naming/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-07-01 12:33:00 +0900",
    





    
    "snippet": "React 네이밍 규칙팀 프로젝트의 경우 네이밍 규칙을 따라 개발된 코드로 작업할 경우 직관적인 코드 이해와 빠른 전달력으로 작업 효율을 늘릴 수 있다.  프로그래밍 네이밍 규칙법      카멜(camelCase)표기법 : 소문자로 시작하고 대문자로 시작하는 모든 후속 단어    파스칼(PascalCase)표기법 : 모든 단어는 대문자로 시작    스...",
    "content": "React 네이밍 규칙팀 프로젝트의 경우 네이밍 규칙을 따라 개발된 코드로 작업할 경우 직관적인 코드 이해와 빠른 전달력으로 작업 효율을 늘릴 수 있다.  프로그래밍 네이밍 규칙법      카멜(camelCase)표기법 : 소문자로 시작하고 대문자로 시작하는 모든 후속 단어    파스칼(PascalCase)표기법 : 모든 단어는 대문자로 시작    스네이크(snake_case)표기법 : 밑줄로 구분된 단어    케밥(kebab-case)표기법 : 하이픈으로 구분된 단어  React 폴더 네이밍 규칙  카멜 케이스를 기본으로 한다  직접적으로 바로 컴포넌트들이 들어있는 컴포넌트 폴더명은 대문자로 시작하여 파스칼(PascalCase) 표기법을 따른다.React 파일 네이밍 규칙  파스칼(PascalCase) 기본으로 한다  컴포넌트일 경우만 .jsx 확장자를 사용한다. (그 외에는 .js)  customHook을 사용하는 경우 : use + 함수명React 컴포넌트 네이밍 규칙  파스칼(PascalCase) 표기법을 따라 모든 단어의 첫 시작을 대문자로한다React 함수,변수,hook 네이밍 규칙  카멜(camelCase)표기법을 따라 첫시작 단어의 첫글자만 소문자 이후 후속 단어의 시작을 대문자로한다React 이벤트 핸들러 네이밍 규칙  Props의 경우: on (onClick 등등)  함수인 경우: handle (handleClick 등등)"
  },
  
  {
    "title": "Git(깃) 여러대 PC에서 동기화하는방법",
    "url": "/posts/usegit02/",
    "categories": "Utils, Git",
    "tags": "Git",
    "date": "2024-06-30 12:33:00 +0900",
    





    
    "snippet": "과정여러대의 PC가 존재하고 모든 PC는 하나의 레포지스터리를 바라보고 업데이트를 한다고 과정한다방법** PC에 Git 설치하는 방법과 레포지스터리 생성 방법은 생략 **Step01. 맨 처음 업로드하는 pc작업# git 사용 계정 등록$git config --global user.name \"gyejindev\"$git config --global us...",
    "content": "과정여러대의 PC가 존재하고 모든 PC는 하나의 레포지스터리를 바라보고 업데이트를 한다고 과정한다방법** PC에 Git 설치하는 방법과 레포지스터리 생성 방법은 생략 **Step01. 맨 처음 업로드하는 pc작업# git 사용 계정 등록$git config --global user.name \"gyejindev\"$git config --global user.email \"gyejin.dev@gmail.com\"# git에 반영할 폴더로 이동$cd myapp#git 폴더 생성 및 초기화$git init#git 레포지스터리 연결(링크는 레포지스토리 생성하면 얻을 수 있는 git 링크)$git remote set-url origin https://계정이름@github.com/gyejindev/gyejindev_blog.git#git 브랜치를 메인으로 변경$git branch -M main#git에 올리기 위한 스테이지 업로드$git add .#스테이지 commit 진행$git commit -m \"gitblog업데이트\"#git 레포지토리에 업로드 진행$git push -u origin mainStep02. 이후 다른 pc들에서 동기화 및 업로드하는 방법# git 사용 계정 등록$git config --global user.name \"gyejindev\"$git config --global user.email \"gyejin.dev@gmail.com\"# git에 동기화할 폴더로 이동$cd myapp#git 폴더 생성 및 초기화$git init#git 레포지토리 연결(링크는 레포지토리 생성하면 얻을 수 있는 git 링크)$git remote set-url origin https://계정이름@github.com/gyejindev/gyejindev_blog.git#git 브랜치를 메인으로 변경$git branch -M main#git 레포지토리에 업로드되어있는 파일들을 해당 폴더에 내려받아서 최신화하기#만약 내파일과 레포지의 파일을 비교하고 싶다면 $git diff 실행$git pull#파일 수정후 git에 올리기 위한 스테이지 업로드 $git add .#스테이지 commit 진행$git commit -m \"gitblog업데이트\"#git 레포지토리에 업로드 진행$git push -u origin main"
  },
  
  {
    "title": "컴포넌트 분리한 todo 앱 만들기",
    "url": "/posts/react_example_todo/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-06-28 12:33:00 +0900",
    





    
    "snippet": "결과물파일 구성  components 폴더 생성  components/Controller.js, viewers.js 파일 생성코드 작성App.js  App.jsimport \"./App.css\";// (1) useReducer과 useRef를 가져오도록한다import { useReducer, useRef } from \"react\";import Heade...",
    "content": "결과물파일 구성  components 폴더 생성  components/Controller.js, viewers.js 파일 생성코드 작성App.js  App.jsimport \"./App.css\";// (1) useReducer과 useRef를 가져오도록한다import { useReducer, useRef } from \"react\";import Header from \"./components/Header\";import TodoEditor from \"./components/TodoEditor\";import TodoList from \"./components/TodoList\";// (2) TodoList 컴포넌트에서 사용할 배열 데이터로 useReducer로 관리 예정이다const mockTodo = [  {    id: 0,    isDone: false,    content: \"React 공부하기\",    createdDate: new Date().getTime(),  },  {    id: 1,    isDone: false,    content: \"노래 연습하기\",    createdDate: new Date().getTime(),  },];// (3) useReducer를 사용하여 자식 컴포넌트에서 데이터의 CRUD 요청이왔을때 처리하기 위한 함수function reducer(state, action) {  // 상태 변화 코드  switch (action.type) {    // (4) CREATE 요청이 오면 action 객체에 들어있는 newItem속성의 값을 복사하고    // 기존의 todo 데이터(useRef로 등록한 mockTodo데이터)와 합쳐서 todo 데이터로 리턴한다    case \"CREATE\": {      return [action.newItem, ...state];    }    // (5) 이 앱에서의 UPDATE 요청은 할일완료/미완료 체크박스 선택으로, 이벤트 발생시 해당 아이템을 찾기위해    // state인 todo 데이터를 map을 돌려서 id값이 업데이트 요청온 action.targetId와 비교후 맞다면    // 스프레드 연산자를 통한 복사를 통해 isDone의 값만 반대로 변경해주고 아니라면 기존 데이터 그대로를 리턴한다    case \"UPDATE\": {      return state.map((it) =&gt;        it.id === action.targetId ? { ...it, isDone: !it.isDone } : it      );    }    // (6) Delete 요청이 오면 filter키워드를 사용해서 해당 id가 아닌 데이터들만 따로 필터링하여 리턴해준다    case \"DELETE\": {      return state.filter((it) =&gt; it.id !== action.targetId);    }    default:      return state;  }  return state;}function App() {  // 위에서 생성한 mockTodo 배열 데이터를 초기값으로 갖는 todo라는 데이터 변수를 만들고 useReducer로 관리하도록 선언한다  // dispatch를 호출하면 위에서 미리 생성해둔 reducer함수를 호출하며 인자값을 전달하고, reducer함수에서 리턴한 값은 todo 변수에 반영하고 컴포넌트 재렌더링을 진행한다.  const [todo, dispatch] = useReducer(reducer, mockTodo);  // 삭제, 업데이트 등의 데이터 변경을 해주기 위해서는 해당 데이터들마다 구분할 수 있는 중복되지 않는 특별한 id값을 가지고 있어야하는데  // 이 앱에서는 간단하게 변수의 데이터가 변하더라도 재렌더링이 되지 않는 useRef를 사용하여 idRef변수를 생성후 id값을 관리하도록 한다  // 초기값은 기존의 데이터가 2개가 이미 들어가있기 때문에 3부터 시작하도록 주었다  const idRef = useRef(3);  // 데이터 생성을 하는 컴포넌트는 TodoEditor 컴포넌트로 해당 자식컴포넌트가 데이터를 생성할 때 사용하기 위한 함수를 만들어서 제공해주려한다  // onCreate함수로 선언하고 dispatch는 위에서 만들어둔 reducer를 통한 데이터 처리를 하기위해 호출하며  // reducer함수에서 CREATE처리에 필요한 인자값인 type과 newItem 객체데이터를 생성하여 전달한다  // id값의 idRef.current는 현재 idRef의 값을 불러올때 사용된다 content는 자식 컴포넌트에서 데이터를 생성하기위한 데이터를 전달하면 해당 값을 넣어준다  // isDone은 완료/비완료 항목으로 기본은 false로 주도록한다  // 생성날짜인 createdDate속성은 현재 시간을 넣어준다  const onCreate = (content) =&gt; {    dispatch({      type: \"CREATE\",      newItem: {        id: idRef.current,        content,        isDone: false,        createdDate: new Date().getTime(),      },    });    idRef.current += 1;  };  // 데이터를 보여주는 역할을 담당하는 TodoList컴포넌트에서 사용할 onUpdate함수는 자식 컴포넌트인 TodoList로부터 업데이트할 데이터의 id값(targetId)를 전달받아서  // reducer함수로 전달한다  const onUpdate = (targetId) =&gt; {    dispatch({ type: \"UPDATE\", targetId });  };  // 데이터를 보여주는 역할을 담당하는 TodoList컴포넌트에서 사용할 onDelete함수는 자식 컴포넌트인 TodoList로부터 삭제할 데이터의 id값(targetId)를 전달받아서  // reducer함수로 전달한다  const onDelete = (targetId) =&gt; {    dispatch({ type: \"DELETE\", targetId });  };  return (    &lt;div className=\"App\"&gt;      &lt;Header /&gt;      &lt;TodoEditor onCreate={onCreate} /&gt;      &lt;TodoList todo={todo} onUpdate={onUpdate} onDelete={onDelete} /&gt;    &lt;/div&gt;  );}export default App;TodoEditor.js  /components/TodoEditor.jsimport \"./TodoEditor.css\";import { useState, useRef } from \"react\";const TodoEditor = ({ onCreate }) =&gt; {  const [content, setContent] = useState(\"\");  const inputRef = useRef();  const onChangeContent = (e) =&gt; {    setContent(e.target.value);  };  // 추가 버튼을 클릭시 동작하는 함수로 위에서 생성한 content변수가 비어있다면 useRef를 통해 텍스트 입력창으로 포커스를 넘긴다  // alert 메세지 창 호출 함수를 사용해서 메세지를 띄워주도록한다  // content가 비어있지 않다면 부모 컴포넌트한테 받은 onCreate함수로 content데이터를 전달한다, 이후 setContent 함수를 호출하여 content값을 빈값으로 변경해주도록했다  const onSubmit = () =&gt; {    if (!content) {      inputRef.current.focus();      alert(\"No Value\");      return;    }    onCreate(content);    setContent(\"\");  };  // 편의성 기능  // 엔터 키코드는 13번 코드로 onKeyDown 이벤트가 발생하면 이벤트 키코드를 비교하여 13일 경우 onSubmit함수를 호출하도록하였다  const onKeyDown = (e) =&gt; {    if (e.keyCode === 13) {      onSubmit();    }  };  return (    &lt;div className=\"TodoEditor\"&gt;      &lt;h4&gt;새로운 Todo 작성하기 ✏️&lt;/h4&gt;      &lt;div className=\"editor_wrapper\"&gt;        &lt;input          ref={inputRef}          value={content}          onChange={onChangeContent}          onKeyDown={onKeyDown}          placeholder=\"새로운 Todo ...\"        /&gt;        &lt;button onClick={onSubmit}&gt;추가&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );};export default TodoEditor;TodoList.js  /components/TodoList.jsimport \"./TodoList.css\";import TodoItem from \"./TodoItem\";import { useState, useMemo } from \"react\";const TodoList = ({ todo, onUpdate, onDelete }) =&gt; {  const [search, setSearch] = useState(\"\");  const memoTodo = useMemo(() =&gt; {    const totalCount = todo.length;    const doneCount = todo.filter((it) =&gt; it.isDone).length;    const notDoneCount = totalCount - doneCount;    return { totalCount, doneCount, notDoneCount };  }, [todo]);  const onChangeSearch = (e) =&gt; {    setSearch(e.target.value);  };  const getSearchResult = () =&gt; {    return search === \"\"      ? todo      : todo.filter((it) =&gt; it.content.toLowerCase().includes(search));  };  const { totalCount, doneCount, notDoneCount } = memoTodo;  return (    &lt;div className=\"TodoList\"&gt;      &lt;h4&gt;Todo List💫&lt;/h4&gt;      &lt;div&gt;        &lt;div&gt;          &lt;div&gt;총개수: {totalCount}&lt;/div&gt;          &lt;div&gt;완료된 할일: {doneCount}&lt;/div&gt;          &lt;div&gt;아직 완료하지 못한 할 일: {notDoneCount}&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;input        onChange={onChangeSearch}        className=\"searchbar\"        placeholder=\"검색어를 입력하세요\"      /&gt;      &lt;div className=\"list_wrapper\"&gt;        {getSearchResult().map((p) =&gt; (          &lt;TodoItem key={p.id} {...p} onUpdate={onUpdate} onDelete={onDelete} /&gt;        ))}      &lt;/div&gt;    &lt;/div&gt;  );};export default TodoList;TodoList.js  /components/TodoList.jsimport \"./TodoItem.css\";const TodoItem = ({ id, content, isDone, createDate, onUpdate, onDelete }) =&gt; {  console.log(`${id} TodoItem 업데이트`);  const onChangeCheckbox = () =&gt; {    onUpdate(id);  };  const onClickDelete = () =&gt; {    onDelete(id);  };  return (    &lt;div className=\"TodoItem\"&gt;      &lt;div className=\"checkbox_col\"&gt;        &lt;input checked={isDone} type=\"checkbox\" onChange={onChangeCheckbox} /&gt;      &lt;/div&gt;      &lt;div className=\"title_col\"&gt;{content}&lt;/div&gt;      &lt;div className=\"date_col\"&gt;        {new Date(createDate).toLocaleDateString()}      &lt;/div&gt;      &lt;div onClick={onClickDelete} className=\"btn_col\"&gt;        &lt;button&gt;삭제&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );};export default TodoItem;"
  },
  
  {
    "title": "컴포넌트 분리한 카운터웹 만들기",
    "url": "/posts/react_example_counter/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-06-27 12:33:00 +0900",
    





    
    "snippet": "결과물파일 구성  components 폴더 생성  components/Controller.js, viewers.js 파일 생성코드 작성App.js  App.jsimport \"./styles.css\";import Viewers from \"./components/Viewers\";import Controller from \"./components/Contro...",
    "content": "결과물파일 구성  components 폴더 생성  components/Controller.js, viewers.js 파일 생성코드 작성App.js  App.jsimport \"./styles.css\";import Viewers from \"./components/Viewers\";import Controller from \"./components/Controller\";import { useState } from \"react\";export default function App() {  const [count, setCount] = useState(1);  const handleSetCount = (value) =&gt; {    setCount(count + value);  };  return (    &lt;div className=\"App\"&gt;      &lt;h1&gt;Simple Counter&lt;/h1&gt;      &lt;section&gt;        &lt;Viewers count={count} /&gt;      &lt;/section&gt;      &lt;section&gt;        &lt;Controller handleSetCount={handleSetCount} /&gt;      &lt;/section&gt;    &lt;/div&gt;  );}Controller.js  components/Controller.jsconst Controller = ({ handleSetCount }) =&gt; {  return (    &lt;div&gt;      &lt;button onClick={() =&gt; handleSetCount(-1)}&gt;-1&lt;/button&gt;      &lt;button onClick={() =&gt; handleSetCount(-10)}&gt;-10&lt;/button&gt;      &lt;button onClick={() =&gt; handleSetCount(-100)}&gt;-100&lt;/button&gt;      &lt;button onClick={() =&gt; handleSetCount(100)}&gt;+100&lt;/button&gt;      &lt;button onClick={() =&gt; handleSetCount(10)}&gt;+10&lt;/button&gt;      &lt;button onClick={() =&gt; handleSetCount(1)}&gt;+1&lt;/button&gt;    &lt;/div&gt;  );};export default Controller;Viewers.js  components/Viewers.jsconst Viewers = ({ count }) =&gt; {  return (    &lt;div&gt;      현재 카운트 :&lt;h1&gt;{count}&lt;/h1&gt;    &lt;/div&gt;  );};export default Viewers;"
  },
  
  {
    "title": "React Props와 구조분해, 스프레드 연산자",
    "url": "/posts/react_props/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-06-26 12:33:00 +0900",
    





    
    "snippet": "React Props와 구조분해  리액트에서는 부모가 자식 컴포넌트에 단인 객체 형태로 값을 전달할 수 있다.  이 객체를 리액트에서는 Props(Properties)라고 하며 Props는 Properties의 줄임말이다.Props를 사용해보기Props를 사용하기전에 먼저 CRA를 사용하여 기본 프로젝트를 생성 후 필요없는 부분은 삭제하고 Header...",
    "content": "React Props와 구조분해  리액트에서는 부모가 자식 컴포넌트에 단인 객체 형태로 값을 전달할 수 있다.  이 객체를 리액트에서는 Props(Properties)라고 하며 Props는 Properties의 줄임말이다.Props를 사용해보기Props를 사용하기전에 먼저 CRA를 사용하여 기본 프로젝트를 생성 후 필요없는 부분은 삭제하고 Header 컴포넌트 하나를 생성하여 최상위 root컴포넌트인 App 컴포넌트에서 자식 Header 컴포넌트를 렌더링 하도록 한다(1) 사용하지 않는 파일 삭제  src/App.test.js  src/logo.svg  src/reportWebVitals.js  src/setupTest.js(2) App.js 파일 수정 및 Components 폴더 생성src/App.js위에서 삭제한 4개의 파일에 대한 불필요한 참조들을 지우고 아래에서 생성한 CustomHeader.js 파일을 자식 컴포넌트로 렌더링 하는 내용을 추가하였다import \"./App.css\";import CustomHeader from \"./components/CustomHeader\";function App() {  return (    &lt;div className=\"App\"&gt;      &lt;CustomHeader /&gt;    &lt;/div&gt;  );}export default App;src/components/CustomHeader.jsfunction CustomHeader() {  return (    &lt;header&gt;      &lt;h1&gt;header&lt;/h1&gt;    &lt;/header&gt;  );}export default CustomHeader;(3) Prop로 전달하고 렌더링해보기2번까지 수행했다면 header라는 문구가 잘 렌더링 되어 웹에 표시될것이다 이번에는 CustomHeader컴포넌트에 고정 문구인 header를 띄우는것이 아닌 부모 컴포넌트인 APP.js에서 전달해주는 Props값으로 자식 컴포넌트 CustomHeader의 문구를 변경해보도록 하자src/App.jsimport \"./App.css\";import CustomHeader from \"./components/CustomHeader\";const projectTitle = \"리액트 부시기\";function App() {  return (    &lt;div className=\"App\"&gt;      &lt;CustomHeader title={projectTitle} /&gt;    &lt;/div&gt;  );}export default App;}src/components/CustomHeader.jsfunction CustomHeader(props) {  return (    &lt;header&gt;      &lt;h1&gt;{props.title}&lt;/h1&gt;    &lt;/header&gt;  );}export default CustomHeader;구조분해  구조분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식이다.위의 예제에서는 header 컴포넌트에 전달되는 props에 title이라는 데이터 하나만 들어있지만 여러개의 props가 있다면 위처럼 props.title 이렇게 사용하면 번거롭게되는데 구조분해할당 방식을 사용하면 간단하게 아래와 같이 바꿀 수 있다src/App.jsimport \"./App.css\";import CustomHeader from \"./components/CustomHeader\";const projectTitle = \"리액트 부시기\";const projectVersion = \"3.0.1\";function App() {  return (    &lt;div className=\"App\"&gt;      &lt;CustomHeader title={projectTitle} version={projectVersion} /&gt;    &lt;/div&gt;  );}export default App;src/components/CustomHeader.jsfunction CustomHeader(props) {  const { title, version } = props;  return (    &lt;header&gt;      &lt;h1&gt;        {title}, {version}      &lt;/h1&gt;    &lt;/header&gt;  );}export default CustomHeader;스프레드 연산자  ES6는 점 세 개(…)로 이루어진 스프레드 연산자를 제공한다스프레드 연산자는 map, set, object와 같이 반복 가능한 객체를 펼치게끔 해주며 이 기능은 더 적게 쓰고 더 많은 것을 할 수 있게 해준다위에서는 자식 컴포넌트에 구조분해 할당을 통해 조금 더 간편하게 props를 사용해보았는데 이번에는 부모 컴포넌트에서도 Props로 전달할 값이 많은경우 값을 일일이 명시하면 불편할 뿐만 아니라 가독성도 떨어진게 된다. 따라서 스프레드 연산자를 사용하면 더욱 간편하게 Props로 전달할 수 있다위 코드에서 App.js인 부모 컴포넌트만 스프레드 연산자로 변경해보도록 한다src/App.jsimport \"./App.css\";import CustomHeader from \"./components/CustomHeader\";function App() {  const HeaderProps = {    title: \"리액트 부시기\",    version: \"3.0.1\",  };  return (    &lt;div className=\"App\"&gt;      &lt;CustomHeader {...HeaderProps} /&gt;    &lt;/div&gt;  );}export default App;"
  },
  
  {
    "title": "useState와 useRef Hook",
    "url": "/posts/react_useState_useRef/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-06-25 12:33:00 +0900",
    





    
    "snippet": "React Hook의 개념  Hook은 리액트 v16.8에 새로 도입된 기능으로서 함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState 그리고 렌더링 직후 작업을 설정하는 useEffect 등의 기능들을 제공한다useState  가장 기본적인 Hook으로서 상태를 관리하기 위해 사용되는 Hook이다  함수형 컴포넌트 안에 state를 추가하여...",
    "content": "React Hook의 개념  Hook은 리액트 v16.8에 새로 도입된 기능으로서 함수형 컴포넌트에서도 상태 관리를 할 수 있는 useState 그리고 렌더링 직후 작업을 설정하는 useEffect 등의 기능들을 제공한다useState  가장 기본적인 Hook으로서 상태를 관리하기 위해 사용되는 Hook이다  함수형 컴포넌트 안에 state를 추가하여 사용한다  현재 상태를 나타내는 state값과 이 상태를 변경하는 setState값을 한 쌍으로 제공한다  state는 초기값을 설정할 수 있으며, 초기값은 첫 렌더링 때 한번 사용된다.  state는 객체일 필요 없이 문자열, 숫자, boolean, 배열, null, 객체 등의 여러가지 다양한 값을 넣을 수 있다.  useState는 State 값이 바뀔때마다 재렌더링(컴포넌트 재호출)이 된다는 특성을 가지고 있다import React, { useState } from \"react\";const Counter = () =&gt; {  const [value, setValue] = useState(0);  return (    &lt;div&gt;      &lt;p&gt; 현재 카운터 값은 {value}입니다. &lt;/p&gt;      &lt;button onClick={() =&gt; setValue(value + 1)}&gt; +1 &lt;/button&gt;      &lt;button onClick={() =&gt; setValue(value - 1)}&gt; -1 &lt;/button&gt;    &lt;/div&gt;  );};useRef  리액트에서 제공하는 Ref를 사용하면 돔(DOM) 요소들을 직접 조작할 수 있다  useRef를 사용하여 특정 DOM요소에 접근하여 값을 초기화할 수 있다  useRef를 사용하여 특정 DOM요소에 focus를 잡을 수 있다import { useRef, useState } from \"react\";function InputComponent() {  const [text, setText] = useState(\"\");  const textRef = useRef();  const handleOnChange = (e) =&gt; {    setText(e.target.value);  };  const handleOnClick = () =&gt; {    if (text.length &lt; 5) {      alert(\"5글자보다 커야합니다\");      textRef.current.focus();    } else {      alert(text);      textRef.current.value = \"\";    }  };  return (    &lt;div&gt;      &lt;input ref={textRef} value={text} onChange={handleOnChange} /&gt;      &lt;button onClick={handleOnClick}&gt;완료&lt;/button&gt;      &lt;p&gt;{text}&lt;/p&gt;    &lt;/div&gt;  );}export default InputComponent;"
  },
  
  {
    "title": "Git블로그 만들기 (jekyll)",
    "url": "/posts/gitblog01/",
    "categories": "Utils, Git",
    "tags": "Git",
    "date": "2024-06-08 12:33:00 +0900",
    





    
    "snippet": "Git블로그를 사용하기 위해서 필요한것들  ruby  ruby의 jekyll  ruby의 bundle  nodejs  jekyll 스킨  github설치[Step01] ruby 설치Jekyll은 루비로 만들어졌다 블로깅 때문에 루비를 설치해야하는 것이 조금 부담일 수도 있지만, 설치해서 사용하면 더 다양한 기능을 사용할 수 있다  ruby 언어 : 루...",
    "content": "Git블로그를 사용하기 위해서 필요한것들  ruby  ruby의 jekyll  ruby의 bundle  nodejs  jekyll 스킨  github설치[Step01] ruby 설치Jekyll은 루비로 만들어졌다 블로깅 때문에 루비를 설치해야하는 것이 조금 부담일 수도 있지만, 설치해서 사용하면 더 다양한 기능을 사용할 수 있다  ruby 언어 : 루비는 인터프리터 형식으로 실행되는 고기능 스크립트 언어이자 뛰어난 객체 지향적 언어이다. 이러한 특성을 가지면서 루비와 같이 가독성이 뛰어난 대표적인 스크립트 언어는 파이썬이다. 이런 유사함은 각각의 언어 사용자 간에 ‘어떤 언어가 더 뛰어난가?’ 라는 논쟁을 일으켰다. 그러나 그런 논쟁은 대체적으로 기술적으로 너무 세부적인 곳에 집착한 의미 없는 논쟁이었다      먼저 루비 공식페이지에 접속해서 본인OS에 맡게 RUBY를 설치하자 버전은 최신버전을 권장한다    👉🏻루비 공식 DOC        아래와 사진과 같이 다음 버튼을눌러 쭉 설치를 진행한다  하기 그림과 같은 창이 나온다면 Enter를 눌러서 1,3 기본 옵션 설치가 되도록 진행하자[Step02] jekyll 및 bundle 설치  cmd 명령프롬프트를 작업관리자로 열어서 하기 명령어로 jekyll과 bundle을 설치해주도록 한다$gem install jekyll bundle      설치 확인    cmd 명렴프롬프트 창에서 ruby -v 명령어를 수행하여 잘설치되었는지 확인하자      [Step03] jekyll 스킨 선택jekyll 블로그를 사용하기위해서 수동으로 직접 만들 수 있지만 그러려면 시간이 많이 소비되고 ruby언어를 또 학습하는 번거로움이 발생한다 따라서 이미 기본 틀이 구성되어있는 jekyll 스킨을 설치하여 변경해서 사용해보도록 한다하기 링크에 접속하여 원하는 블로그 스킨을 다운받도록 하자👉🏻jekyll스킨 테마 다운받기필자는 Gitbook Theme 라는 테마를 선택하였고 Download버튼을 클릭하면 소스 파일들이 zip파일로 압축되어 다운받아진다다운로드가 완료되었으면 압축을 풀고 cmd 명령프롬프트 창을 열어서 cd명령어로 해당 폴더로 이동하여 bundle 명령어를 수행한다 (폴도 경로는 필자와 다를 수 있으니 압축푼 폴더 경로를 잘 확인하자 )  여기서 bundle 명령어를 사용한 이유는 jekyll 스킨들마다 필요한 gem 라이브러리들이 다양하게 있는데 해당 의존성들을 다운받기 위해서 수행하는것이다$ cd C:\\Users\\whrpw\\Downloads\\vszhub-not-pure-poole-v0.1.0-15-g114901d\\vszhub-not-pure-poole-114901d$ bundle로컬에서 실행해보기 위해 해당 폴더에서 하기 명령어를 수행해보자$ jekyll serve하기 그림과 같이 수행이 잘된다면 웹으로 접속해보도록 하자 👉🏻로컬 jekyll접속잘 접속이되는것이 확인되었다면 jekyll 로컬 블로그 구축에 성공한것이다"
  },
  
  {
    "title": "Javascript API",
    "url": "/posts/javascript_api/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-05-24 12:33:00 +0900",
    





    
    "snippet": "API란  Application Programming Interface(애플리케이션 프로그램 인터페이스)의 약자로, 소프트웨어 응용 프로그램에서 다른 소프트웨어 구성 요소 또는 서비스와 상호 작용하기 위한 인터페이스를 제공하는 프로그래밍 기술이다  EX) 약국에 두통약을 사러갔다고 과정했을때 우리는 약사에게 어떤 약을 달라고 요청을하게되고 약사는 그 ...",
    "content": "API란  Application Programming Interface(애플리케이션 프로그램 인터페이스)의 약자로, 소프트웨어 응용 프로그램에서 다른 소프트웨어 구성 요소 또는 서비스와 상호 작용하기 위한 인터페이스를 제공하는 프로그래밍 기술이다  EX) 약국에 두통약을 사러갔다고 과정했을때 우리는 약사에게 어떤 약을 달라고 요청을하게되고 약사는 그 요청에 따라 약을 찾아서 약을 건네주는 응답을 한다.          우리는 위처럼 요청하는 프로그램이고 약사는 요청에 따른 약(데이터)을 찾아서 응답해주는 API와 동일하다.API의 종류Ajax  Ajax(Asynchronous JavaScript And XML)의 약자로 Javascript를 사용한 비동기 통신, 클라이언트와 서버간에 데이터를 주고받는 기술이라고 할 수 있다.여기서 비동기 Http통신이란 응답(response)와 요청(request)를 비동기 식으로 다룰 수 있다는것을 뜻하게되는데 예를들어 유튜브를 보고있을때 비동기가 지원되지 않는경우 우리가 댓글을 달게되면 페이지는 다시 렌더링되어 처음부터 영상을 다시봐야하는 상황이 발생하게 된다Axios  Node.js와 브라우저를 통한 Promise API를 활용하는 HTTP 통신 라이브러리로 비동기로 HTTP통신이 가능하며 위의 Ajax에서는 제공되지 않는 return을 promise객체로 해주기 때문에 response데이터를 다루기 쉽다.브라우저의 높은 호환성과 기능면에서 제일 많이 구현되어있어 API중에 제일 많이 사용된다.그럼 Popmise객체는 무엇일까?            Promise객체: 어떤 작업에 관한 `상태 정보`를 갖고 있는 객체작업이 진행중임을 의미하는 pending, 작업이 성공적으로 완료되었음을 의미하는 fulfilled, 작업이 실패했음을 의미하는 rejected              Axios 사용법        [GET요청] : 입력한 url에 존재하는 자원에 요청을한다, GET은 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이다. 주소에 있는 쿼리스트링을 활용해서 정보를 전달하는 것이지 GET메서드는 값이나 상태등을 바꿀 수 없다.  axios.get(url,[,config]  [POST요청] : 새로운 리소스를 생성(create)할 때 사용한다, 로그인, 회원가입 등 사용자가 생성한 파일을 서버에다가 업로드할때 사용한다. Post를 사용하면 주소창에 쿼리스트링이 남지 않기때문에 GET보다 안전하다.  axios.post(\"url주소\",{data객체},[,config])  [Delete요청]: REST 기반 API 프로그램에서 데이터베이스에 저장되어 있는 내용을 삭제하는 목적으로 사용된다, Delete메서드는 서버에 있는 데이터베이스의 내용을 삭제하는 것을 주 목적으로 하기에 두 번째 인자를 아예 전달하지 않는다.  axios.delete(\"/thisisExample/list/30\").then(function(response){    console.log(response);      }).catch(function(ex){      throw new Error(ex)}  [Put요청]: REST 기반 API 프로그램에서 데이터베이스에 저장되어 있는 내용을 갱신하는 목적으로 사용된다.  PUT메서드는 서버에 있는 데이터베이스의 내용을 변경하는 것을 주 목적으로 하고 있다.  axios.put(url[, data[, config]])Fetch  ES6부터 들어온 Javascript 내장 라이브러리로 axios와 마찬가지로 Promise 기반으로 만들어져 데이터 다루기가 쉽다Axios에 비해 기능이 부족하며 브라우저 호환이 낮다.      Fetch API 사용법    fetch(url, options)  .then(response =&gt; response.json())  .then(data =&gt; console.log(data))  .catch(error =&gt; console.log('Error:', error));      url: 필요한 리소스의 URL    options: 요청에 대한 설정, 메소드(GET, POST 등), 헤더, 본문 등을 지정할 수 있다    response.json(): fetch는 HTTP 응답을 나타내는 Response 객체를 반환.json() 메소드는 이 응답을 JSON 형태로 파싱한다    catch: 네트워크 요청에 문제가 생길 경우를 대비해 에러 핸들링을 한다  "
  },
  
  {
    "title": "vscode prettier 설정 및 오류 해결방법",
    "url": "/posts/vscode_prettier/",
    "categories": "Utils, Vscode",
    "tags": "Vscode",
    "date": "2024-05-10 12:33:00 +0900",
    





    
    "snippet": "Prittierprittier은 vscode 확장 패키지 프로그램으로 코드를 자동으로 정렬해주는 기능을 제공한다Prittier 설치1. vscode extenstion 확장 탭에서 Prettier 검색 후 설치를 한다2. 환경설정에서 prettier로 변경ctrl+, 또는 메뉴의 환경설정을 찾아 들어간후 아래와 같이 Default Formatter 설...",
    "content": "Prittierprittier은 vscode 확장 패키지 프로그램으로 코드를 자동으로 정렬해주는 기능을 제공한다Prittier 설치1. vscode extenstion 확장 탭에서 Prettier 검색 후 설치를 한다2. 환경설정에서 prettier로 변경ctrl+, 또는 메뉴의 환경설정을 찾아 들어간후 아래와 같이 Default Formatter 설정에서 None으로 되어있는 부분을 Prettier 로 설정한다적용이 안되는경우검색창에 ‘json’을 검색한 뒤 Edit in setting.json파일로 들어가 editor.formatOnSave의 값이 true인지 확인해보자 값이 없거나 false로 되어있으면 true로 수정 또는 추가하자"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part14 React Query 로그인연동하기",
    "url": "/posts/rn_project_matzip14/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-07 12:33:00 +0900",
    





    
    "snippet": "React Query 사용을 위해 Query Client Provider로 App을 감싸주자[matzip/front/App.tsx]import {NavigationContainer} from '@react-navigation/native';import React from 'react';import RootNavigator from './src/navi...",
    "content": "React Query 사용을 위해 Query Client Provider로 App을 감싸주자[matzip/front/App.tsx]import {NavigationContainer} from '@react-navigation/native';import React from 'react';import RootNavigator from './src/navigations/root/RootNavigator';import {QueryClientProvider} from '@tanstack/react-query';import queryClient from './src/api/queryClient';function App() {  return (    &lt;QueryClientProvider client={queryClient}&gt;      &lt;NavigationContainer&gt;        &lt;RootNavigator /&gt;      &lt;/NavigationContainer&gt;    &lt;/QueryClientProvider&gt;  );}export default App;queryClient 파일 코드 작성[matzip/front/src/api/queryClient.ts]QueryClientProvider로 App을 감싸주었는데 QueryClientProvider 사용을 위해서는 client라는 속성을 사용해야하고 client속성은 따로 파일로 분리하도록한다React Query 는 기본적으로 서버의 재요청을 3번을 하는것을 기본으로하는데 해당 요청을 하지 않는 옵션으로 retry들을 모두 false로준다import {QueryClient} from '@tanstack/react-query';const queryClient = new QueryClient({  defaultOptions: {    queries: {      retry: false,    },    mutations: {      retry: false,    },  },});export default queryClient;[matzip/front/src/hooks/useAuth.ts]import {  QueryKey,  UseQueryOptions,  useMutation,  useQuery,} from '@tanstack/react-query';import {  getAccessToken,  getProfile,  logout,  postLogin,  postSignup,} from '../../api/auth';import {  ResponseError,  UseMutationCustomOptions,  UseQueryCustomOptions,} from '../../types/common';import {removeEncryptStorage, setEncryptStorage} from '../../utils';import axiosInstance from '../../api/axios';import {removeHeader, setHeader} from '../../utils/header';import {useEffect} from 'react';import queryClient from '../../api/queryClient';function useSignup(mutationOptions?: UseMutationCustomOptions) {  return useMutation({    mutationFn: postSignup,    ...mutationOptions,  });}function useLogin(mutationOptions?: UseMutationCustomOptions) {  return useMutation({    mutationFn: postLogin,    onSuccess: ({accessToken, refreshToken}) =&gt; {      setEncryptStorage('refreshToken', refreshToken);      setHeader('Authorization', `Bearer ${accessToken}`);      console.log(        `로그인성공 refreshToken값 : ${refreshToken} Authorization값 : ${accessToken}`,      );      axiosInstance.defaults.headers.common['Authorization'] = accessToken;    },    onSettled: () =&gt; {      queryClient.refetchQueries({queryKey: ['auth', 'getAccessToken']});      queryClient.invalidateQueries({queryKey: ['auth', 'getProfile']});    },    ...mutationOptions,  });}function useGetRefreshToken() {  const {isSuccess, data, isError} = useQuery({    queryKey: ['auth', 'getAccessToken'],    queryFn: getAccessToken,    staleTime: 1000 * 60 * 30 - 1000 * 60 * 3,    refetchInterval: 1000 * 60 * 30 - 1000 * 60 * 3,    refetchOnReconnect: true,    refetchIntervalInBackground: true,  });  useEffect(() =&gt; {    if (isSuccess) {      setHeader('Authorization', `Bearer ${data.accessToken}`);      setEncryptStorage('refreshToken', data.refreshToken);    }  }, [isSuccess]);  useEffect(() =&gt; {    if (isError) {      removeHeader('Authorization');      removeEncryptStorage('refreshToken');    }  }, [isError]);  return {isSuccess, isError};}function useGetProfile(queryOptions?: UseQueryCustomOptions) {  return useQuery({    queryKey: ['auth', 'getProfile'],    queryFn: getProfile,    ...queryOptions,  });}function useLogout(mutationOptions?: UseMutationCustomOptions) {  return useMutation({    mutationFn: logout,    onSuccess: () =&gt; {      removeHeader('Authorization');      removeEncryptStorage('refreshToken');    },    onSettled: () =&gt; {      queryClient.invalidateQueries({queryKey: ['auth']});    },    ...mutationOptions,  });}function useAuth() {  const signupMutation = useSignup();  const refreshTokenQuery = useGetRefreshToken();  const getProfileQuery = useGetProfile({    enabled: refreshTokenQuery.isSuccess,  });  const isLogin = getProfileQuery.isSuccess;  const loginMutation = useLogin();  const logoutMutation = useLogout();  return {    signupMutation,    loginMutation,    isLogin,    getProfileQuery,    logoutMutation,  };}export default useAuth;"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part13 React Query 사용 및 API추가하기",
    "url": "/posts/rn_project_matzip13/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-06 12:33:00 +0900",
    





    
    "snippet": "React Query란리액트 쿼리는 서버 데이터를 가져오고 캐싱하고 동기화하면 업데이트해주는 라이브러리이다React Query 설치(프론트 프로젝트 폴더에서)npm i @tanstack/react-queryReact Query에서 사용할 데이터 타입들을 미리 지정해두자[matzip/front/src/types/domain.ts]type MarkerCo...",
    "content": "React Query란리액트 쿼리는 서버 데이터를 가져오고 캐싱하고 동기화하면 업데이트해주는 라이브러리이다React Query 설치(프론트 프로젝트 폴더에서)npm i @tanstack/react-queryReact Query에서 사용할 데이터 타입들을 미리 지정해두자[matzip/front/src/types/domain.ts]type MarkerColor = 'RED' | 'YELLOW' | 'GREEN' | 'BLUE' | 'PURPLE';type Category = {  [key in MarkerColor]: string;};interface ImageUri {  id?: number;  uri: string;}interface Marker {  id: number;  latitude: number;  longitude: number;  color: MarkerColor;  score: number;}interface Post extends Marker {  title: string;  address: string;  date: Date | string;  description: string;}interface Profile {  id: number;  email: string;  nickname: string | null;  imageUri: string | null;  kakaoImageUri: string | null;  loginType: 'email' | 'kakao' | 'apple';}export type {MarkerColor, Category, ImageUri, Marker, Post, Profile};API전용 폴더도 생성하여 API호출 관련 소스들은 해당 폴더에서 관리하도록하자[matzip/front/src/api/auth.ts]해당 파일은 API를 요청하는 함수를 담아둔 파일로 로그인,회원가입,데이터조회 등 API함수들을 담아두도록한다import axios from 'axios';import axiosInstance from './axios';import {Category, Profile} from '../types/domain';import {getEncryptStorage} from '../utils';type RequestUser = {  email: string;  password: string;};// 회원가입const postSignup = async ({email, password}: RequestUser): Promise&lt;void&gt; =&gt; {  try {    console.log(`step2 PostSignup 호출됨 `);    const {data, status} = await axiosInstance.post('/auth/signup', {      email,      password,    });    console.log(status);    return data;  } catch (e) {    console.log(e);  }};type ResponseToken = {  accessToken: string;  refreshToken: string;};// 로그인const postLogin = async ({  email,  password,}: RequestUser): Promise&lt;ResponseToken&gt; =&gt; {  const {data} = await axiosInstance.post('/auth/signin', {    email,    password,  });  return data;};// 유저 정보 불러오기type ResponseProfile = Profile &amp; Category;const getProfile = async (): Promise&lt;ResponseProfile&gt; =&gt; {  const {data} = await axiosInstance.get('/auth/me');  return data;};// 토큰 갱신 함수const getAccessToken = async (): Promise&lt;ResponseToken&gt; =&gt; {  const refreshToken = await getEncryptStorage('refreshToken');  const {data} = await axiosInstance.get('/auth/refresh', {    headers: {      Authorization: `Bearer ${refreshToken}`,    },  });  return data;};// 사용자 로그아웃함수const logout = async () =&gt; {  await axiosInstance.post('/auth/logout');};export {postSignup, postLogin, getProfile, getAccessToken, logout};export type {RequestUser, ResponseToken, ResponseProfile};[matzip/front/src/api/auth.ts]import axios from 'axios';import {Platform} from 'react-native';// axios에서 제공하는 creact함수로 baseURL 지정이 가능하다 const axiosInstance = axios.create({  baseURL:    Platform.OS === 'android'      ? 'http://192.168.0.25:3030'      : 'http://localhost:3030',  withCredentials: true,});export default axiosInstance;"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part12 앱 로그인 설계 및 기타 프로그램 설치",
    "url": "/posts/rn_project_matzip12/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-05 12:33:00 +0900",
    





    
    "snippet": "앱 로그인 설계  Step1: 앱 실행시 Refresh Api Call을 호출하여 성공, 실패를 나눈다  Step2 :  실패한경우 신규 유저 또는 오래전에 로그인한 사용자로 토큰이 만료된 사용자로 토큰을 제거하고 다시 로그인을 하게하여  로그인 성공시 AccessToken(header), RefreshToken(storage)을 저장하고 메인페이지로...",
    "content": "앱 로그인 설계  Step1: 앱 실행시 Refresh Api Call을 호출하여 성공, 실패를 나눈다  Step2 :  실패한경우 신규 유저 또는 오래전에 로그인한 사용자로 토큰이 만료된 사용자로 토큰을 제거하고 다시 로그인을 하게하여  로그인 성공시 AccessToken(header), RefreshToken(storage)을 저장하고 메인페이지로 이동시킨다성공한 경우 RefreshToken이 아직 살아있는 사용자로 자동 로그인을 하여 메인화면으로 이동시킨다 AccessToken(header), RefreshToken(storage) 토큰들을 모두 갱신시켜서 재저장한다EncryptStorage 설치 및 편의설정RefreshToken을 저장하기 위해 EncryptStorage 를 설치하도록 하자npm install react-native-encrypted-storageEncryptStorage를 편하게 사용하기 위해 아래 파일을 만들고 설정해두자[matzip/front/src/utils/encryptStorage.ts]import EncryptStorage from 'react-native-encrypted-storage';const setEncryptStorage = async &lt;T&gt;(key: string, data: T) =&gt; {  await EncryptStorage.setItem(key, JSON.stringify(data));};const getEncryptStorage = async (key: string) =&gt; {  const storedData = await EncryptStorage.getItem(key);  return storedData ? JSON.parse(storedData) : null;};const removeEncryptStorage = async (key: string) =&gt; {  const data = await getEncryptStorage(key);  if (data) {    await EncryptStorage.removeItem(key);  }};export {setEncryptStorage, getEncryptStorage, removeEncryptStorage};테스트용 백엔드를 만들기위해 데이터베이스인 postgresql 설치👉🏻postgresql 설치URLpostgresql에 쉽게 데이터를 넣고 수정하고할 수 있는 pgadmin 툴 다운로드 및 생성👉🏻pgadmin 설치URL(1) 설치가 완료되었으면 pgadmin을 실행시켜서 Servers -&gt; Register -&gt; Server를 클릭하여 아래와 같이 생성하도록 하자  Name : matzip-app  Host name / address : localhost  Port: 5432  Username/Password: postgres(2) Server를 생성했으면 matzip-app이 생기고 왼쪽에 토글바를 눌러 열면 Databases항목이보인다 Databases우클릭 Create를 눌러서 DB를 생성한다 DB이름 또한 matzip-app으로 생성하였다프로젝트 폴더에 server폴더 생성현재까지 진행한 react-native소스들은 모두 프로젝트폴더내의 front폴더에있을것이다server폴더를 최상위에 하나 더만들어서 최상위에는 front, server가 존재하도록하자server 기본 소스코드 다운 및 실행server 소스가 필요한데 이 프로젝트는 react-native가 중점이기에 server 소스는 기본적인 RestApi기능을 하는 소스만을 사용할것이다 서버 소스파일은 👉🏻소스코드){:target=”_blank”} 여기에서 다운받고 위에서 만들어둔 server폴더에 풀어두자server폴더내의 기본 설정 작업[matzip/server/.env]env파일을 생성하여 아래와 같이 postgresql 및 서버 포트, 토큰 정보등을 담아두도록하자PORT=3030DB_USERNAME=postgresDB_PASSWORD=postgresDB_DATABASE=matzip-appDB_HOST=localhostJWT_SECRET=SecretMatzipJWT_ACCESS_TOKEN_EXPIRATION=30mJWT_REFRESH_TOKEN_EXPIRATION=30d서버의 의존성 패키지를 설치하고 실행시키자npm install npm run start:devFront 폴더에서 Axios 및 ReactQuery 설치npm install axiosnpm install @tanstack/react-query"
  },
  
  {
    "title": "React Lifecycle과 useEffect",
    "url": "/posts/react_lifecycle_useEffect/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-05 12:33:00 +0900",
    





    
    "snippet": "리액트 컴포넌트의 라이프 사이클사람의 인생처럼 리액트 컴포넌트도 태어나고 사라지는 생애주기가 존재한다이를 다른 말로는 라이프 사이클이라고 부르며 리액트 컴포넌트의 라이프 사이클은 크게 3단계로 구분할 수 있다graph TD;    Mount:탄생--&gt;Update:업데이트;    Update:업데이트--&gt;Unmount:죽음;  Mount : ...",
    "content": "리액트 컴포넌트의 라이프 사이클사람의 인생처럼 리액트 컴포넌트도 태어나고 사라지는 생애주기가 존재한다이를 다른 말로는 라이프 사이클이라고 부르며 리액트 컴포넌트의 라이프 사이클은 크게 3단계로 구분할 수 있다graph TD;    Mount:탄생--&gt;Update:업데이트;    Update:업데이트--&gt;Unmount:죽음;  Mount : 컴포넌트를 페이지에 처음 렌더링할 때  Update : State나 Props의 값이 바뀌거나 부모 컴포넌트의 리렌더해 자신도 리렌더링될 때  Unmount : 더 이상 페이지에 컴포넌트를 렌더링하지 않을 때라이플 사이클을 이용하면 컴포넌트가 처음 렌더링될 때 특정 동작을 하도록 만들거나, 업데이트할 때 적절한지 검사하거나,페이지에서 사라질 때 메모리를 정리하는 등 여러 유용한 작업을 단계에 맞게 할 수 있다.useEffect  함수 useEffect는 어떤 값이 변경될 때마다 특정 코드를 실행하는 리액트 훅이다useEffect를 이용하면 컴포넌트의 State값이 바뀔 때마다 변경된 값을 콘솔에 출력하게 할 수 있다useEffect의 용법 : useEffect(callback, [deps]) 첫번째 callback에는 실행시키고자 하는 함수, 두번째 deps에는 의존성 배열로 감시하고자하는 변수가 된다useEffect를 사용하여 하나의 값 검사하기...export default function App() {  const [count, setCount] = useState(1);  const handleSetCount = (value) =&gt; {    setCount(count + value);  };  useEffect(() =&gt; {    console.log(\"count 업데이트: \", count);  }, [count]);...위 소스와 결과물을 보면 useEffect를 선언하면서 첫번째 콜백 실행 함수로 console을 찍도록 하고 두번째 인수로 count라는 맨위에 useState로 선언한 변수를 의존성 배열로 넣어서 감시한다 즉, count가 업데이트되면 console을 찍게된다useEffect를 사용하여 어러개의 값 검사하기...export default function App() {  const [count, setCount] = useState(1);  const [text, setText] = useState(\"\");  const handleSetCount = (value) =&gt; {    setCount(count + value);  };  useEffect(() =&gt; {    console.log(\"count 업데이트: \", count, text);  }, [count]);...위 소스를 보면 useEffect를 선언하면서 의존성 배열을 count와 text 두개를 주었다 이렇게 하면 count나 text의 값이 업데이트 즉 변동이 있으면 console을 찍게된다useEffect를 사용하여 컴포넌트 렌더링만 감시하고싶을때...export default function App() {  const [count, setCount] = useState(1);  const [text, setText] = useState(\"\");  const handleSetCount = (value) =&gt; {    setCount(count + value);  };  useEffect(() =&gt; {    console.log(\"count 업데이트\");  }, [count]);...컴포넌트가 업데이트 즉 재렌더링이 되는경우 감시하고싶으면 두번째 인수인 의존성 배열에 아무값도 주지 않으면 컴포넌트 자체를 감시하게된다useEffect를 사용해서 마운트 시점은 제외하고 업데이트 시점만 콜백 함수 실행위에 컴포넌트 렌더링 감시를 하게되면 처음 실행되는 마운트 시점에도 콜백 함수가 실행되는데 처음 실행되는 마운트 시점을 제외하고 재렌더링 되는 시점만 콜백 함수를 실행하고 싶으면 아래와 같이 useRef 훅을 사용할 수 있다.function App(){    ...    const didMountRef = useRef(false);    useEffect(()=&gt; {        if (!didMountRef.curret){            didMountRef.current = true;            return;        }        else {            console.log(\"컴포넌트 업데이트\");        }    });}위와 같이 컴포넌트를 페이지에 마운트했는지 판단하는 변수 didMountRef를 Ref 객체로 생성하고 초깃값을 false로 설정한다Ref 객체는 돔 요소를 참조하는 것뿐만 아니라 컴포넌트의 변수로도 자주 활용된다.didMountRef.current 값에 따라 해당 컴포넌트가 마운트가 되었는지 안되었는지 활용할 수 있다.따라서 처음 마운트가 되면 didMountRef값이 true가 되고 콘솔이 안찍히게 된다useEffect를 사용해서 마운트 시점에만 콜백 함수 실행이번에는 해당 컴포넌트가 맨 처음 마운트 되는 시점에만 콜백 함수를 실행하고 싶다면 어떻게 할까?    useEffect(()=&gt; {        console.log(\"컴포넌트 마운트\");        }, []);}두번째 인수인 의존성 배열에 빈배열인 []를 주게되면 해당 컴포넌트가 맨 처음 마운트 되는 시점에만 콘솔을 찍게된다."
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part11 폼 사용성 개선하기",
    "url": "/posts/rn_project_matzip11/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-04 12:33:00 +0900",
    





    
    "snippet": "InputField를 수정하여 ForwardRef 사용하기[matzip/front/src/components/InputField.tsx]지난 시간까지 로그인, 회원가입 페이지를 구현하였는데 사용자 편의성을 위해 이메일을 입력후 엔터나 다음버튼을 누르면 비밀번호 입력창으로 자동으로 포커스가되면 좋겠다는 생각을 했다..그러기 위해서는 React 컴포넌트에...",
    "content": "InputField를 수정하여 ForwardRef 사용하기[matzip/front/src/components/InputField.tsx]지난 시간까지 로그인, 회원가입 페이지를 구현하였는데 사용자 편의성을 위해 이메일을 입력후 엔터나 다음버튼을 누르면 비밀번호 입력창으로 자동으로 포커스가되면 좋겠다는 생각을 했다..그러기 위해서는 React 컴포넌트에 ref prop을 넘겨서 그 내부에 있는 HTML 엘리먼트에 접근을 하게 해주는 forwardRef() 함수를 사용해야한다는것을 알게되어 지난번 구현해둔 InputField 컴포넌트에 코드를 추가하고 common이라는 ref를 합쳐주는 파일을 작성하였다[matzip/front/src/utils/common.ts]import {ForwardedRef} from 'react';function mergeRefs&lt;T&gt;(...refs: ForwardedRef&lt;T&gt;[]) {  return (node: T) =&gt; {    refs.forEach(ref =&gt; {      if (typeof ref === 'function') {        ref(node);      } else if (ref) {        ref.current = node;      }    });  };}export {mergeRefs};[matzip/front/src/components/InputField.tsx]import React, {ForwardedRef, forwardRef, useRef} from 'react';import {  Dimensions,  StyleSheet,  TextInput,  View,  TextInputProps,  Text,  Pressable,} from 'react-native';import {colors} from '../constants';import {mergeRefs} from '../utils';interface InputFieldProps extends TextInputProps {  disabled?: boolean;  error?: string;  touched?: boolean;}const deviceHeight = Dimensions.get('screen').height;// 함수로되어있엇던 InputField를 화살표함수로 바꾸어주고 forwardRef를 호출한다const InputField = forwardRef(  (    {disabled = false, error, touched, ...props}: InputFieldProps,    ref?: ForwardedRef&lt;TextInput&gt;,  ) =&gt; {    const innerRef = useRef&lt;TextInput | null&gt;(null);    const handlePressInput = () =&gt; {      innerRef.current?.focus();    };    return (      &lt;Pressable onPress={handlePressInput}&gt;        &lt;View          style={[            styles.container,            disabled &amp;&amp; styles.disabled,            touched &amp;&amp; Boolean(error) &amp;&amp; styles.inputError,          ]}&gt;          &lt;TextInput            ref={ref ? mergeRefs(innerRef, ref) : innerRef}            editable={!disabled}            placeholderTextColor={colors.GRAY_500}            style={[styles.input, disabled &amp;&amp; styles.disabled]}            autoCapitalize=\"none\"            spellCheck={false}            autoCorrect={false}            {...props}          /&gt;          {touched &amp;&amp; Boolean(error) &amp;&amp; (            &lt;Text style={styles.error}&gt;{error}&lt;/Text&gt;          )}        &lt;/View&gt;      &lt;/Pressable&gt;    );  },);const styles = StyleSheet.create({  container: {    borderWidth: 1,    borderColor: colors.GRAY_200,    padding: deviceHeight &gt; 700 ? 15 : 10,  },  input: {    fontSize: 16,    color: colors.BLACK,    padding: 0,  },  disabled: {    backgroundColor: colors.GRAY_200,    color: colors.GRAY_700,  },  inputError: {    borderWidth: 1,    borderColor: colors.RED_300,  },  error: {    color: colors.RED_500,    fontSize: 12,    paddingTop: 5,  },});export default InputField;회원가입 페이지 개선하기[matzip/front/src/screens/auth/SignupScreen.tsx]import React, {useRef} from 'react';import {SafeAreaView, StyleSheet, Text, TextInput, View} from 'react-native';import InputField from '../../components/InputField';import useForm from '../../hooks/useForm';import CustomButton from '../../components/CustomButton';import {validateSignup} from '../../utils';// 로그인에서 구현한 부분과 같이 useForm이라는 만들어둔 훅을 사용하여 데이터를 관리하고// passwordConfirm이라는 새로운 속성을 추가하여 해당 속성은 password 재확인을 위해 사용한다function SignupScreen() {  const passwordRef = useRef&lt;TextInput | null&gt;(null);  const passwordConfirmRef = useRef&lt;TextInput | null&gt;(null);  const signup = useForm({    initialValue: {      email: '',      password: '',      passwordConfirm: '',    },    validate: validateSignup,  });  const handleSubmit = () =&gt; {    console.log(signup.values);  };  return (    &lt;SafeAreaView style={styles.container}&gt;      &lt;View style={styles.inputContainer}&gt;        &lt;InputField        // autoFocus를 주어 해당 페이지에 들어왔을때 여기에 포커스가되도록 설정          autoFocus          placeholder=\"이메일\"          error={signup.errors.email}          touched={signup.touched.email}          inputMode=\"email\"          // 키보드에 다음 버튼을 만들기위해 returnKeyType 옵션을 켜줌          returnKeyType=\"next\"          //키보드가 닫히지 않도록 blurOnSubmit을 false로 줌          blurOnSubmit={false}          // next나 다음 버튼을 키보드에서 눌렀을때 다음 input창으로 넘어가기 위한 옵션추가          onSubmitEditing={() =&gt; passwordRef.current?.focus()}          {...signup.getTextInputProps('email')}        /&gt;        &lt;InputField          ref={passwordRef}          placeholder=\"비밀번호\"          // 비밀번호 경고창 띄우지 않도록          textContentType=\"oneTimeCode\"          error={signup.errors.password}          touched={signup.touched.password}          secureTextEntry          returnKeyType=\"next\"          blurOnSubmit={false}          onSubmitEditing={() =&gt; passwordConfirmRef.current?.focus()}          {...signup.getTextInputProps('password')}        /&gt;        &lt;InputField          ref={passwordConfirmRef}          placeholder=\"비밀번호 확인\"          error={signup.errors.passwordConfirm}          touched={signup.touched.passwordConfirm}          secureTextEntry          onSubmitEditing={handleSubmit}          {...signup.getTextInputProps('passwordConfirm')}        /&gt;      &lt;/View&gt;      &lt;CustomButton label=\"회원가입\" onPress={handleSubmit} /&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({  container: {    flex: 1,    margin: 30,  },  inputContainer: {    gap: 20,    marginBottom: 30,  },});export default SignupScreen;로그인 페이지 개선하기[matzip/front/src/screens/auth/LoginScreen.tsx] import React, {useRef} from 'react'; import {SafeAreaView, StyleSheet, TextInput, View} from 'react-native'; import InputField from '../../components/InputField'; import CustomButton from '../../components/CustomButton'; import useForm from '../../hooks/useForm'; import {validateLogin} from '../../utils';  function LoginScreen() {   const passwordRef = useRef&lt;TextInput | null&gt;(null);   const login = useForm({     initialValue: {email: '', password: ''},     validate: validateLogin,   });    const handleSubmit = () =&gt; {     console.log('login.values', login.values);   };    return (     &lt;SafeAreaView style={styles.container}&gt;       &lt;View style={styles.inputContainer}&gt;         &lt;InputField           autoFocus           placeholder=\"이메일\"           error={login.errors.email}           touched={login.touched.email}           inputMode=\"email\"           returnKeyType=\"next\"           blurOnSubmit={false}           onSubmitEditing={() =&gt; passwordRef.current?.focus()}           {...login.getTextInputProps('email')}         /&gt;         &lt;InputField           ref={passwordRef}           placeholder=\"비밀번호\"           error={login.errors.password}           touched={login.touched.password}           secureTextEntry           returnKeyType=\"join\"           blurOnSubmit={false}           onSubmitEditing={handleSubmit}           {...login.getTextInputProps('password')}         /&gt;       &lt;/View&gt;       &lt;CustomButton         label=\"로그인\"         variant=\"filled\"         size=\"large\"         onPress={handleSubmit}       /&gt;     &lt;/SafeAreaView&gt;   ); }  const styles = StyleSheet.create({   container: {     flex: 1,     margin: 30,   },   inputContainer: {     gap: 20,     marginBottom: 30,   }, });  export default LoginScreen; 폼 개선을 통해 자동으로 다음 포커스로 이동하는 앱 화면"
  },
  
  {
    "title": "React 기본폴더 및 파일구성",
    "url": "/posts/react_setup/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-04 12:33:00 +0900",
    





    
    "snippet": "이번에는 리액트 앱을 CRA(Create React App)으로 생성 후 만들어지는 파일과 폴더의 구성에 대해 작성해본다      package.json 파일 : 해당 프로젝트의 앱에 어떤 라이브러리가 설치되어있는지, 리액트 버전은 몇 버전인지 등에 대한 정보를 알 수 있다        public 폴더 : 리액트에서 공용으로 사용하고 있는 폰트 파일...",
    "content": "이번에는 리액트 앱을 CRA(Create React App)으로 생성 후 만들어지는 파일과 폴더의 구성에 대해 작성해본다      package.json 파일 : 해당 프로젝트의 앱에 어떤 라이브러리가 설치되어있는지, 리액트 버전은 몇 버전인지 등에 대한 정보를 알 수 있다        public 폴더 : 리액트에서 공용으로 사용하고 있는 폰트 파일, 이미지 파일, 등을 저장하는 폴더이다.        src 폴더 : 소스의 약자인 src 폴더는 해당 프로젝트의 소스를 저장하는 폴더이다 이 폴더는 리액트를 사용하는 동안 자바스크립트 파일들을 한데 모아놓는 곳으로, 프로젝트에서 사용할 소스 파일을 저장한다.        node_modules : 해당 프로젝트 앱에서 사용되는 라이브러리들이 설치되어있는 폴더이다.  "
  },
  
  {
    "title": "React 개발환경 설정 방법",
    "url": "/posts/react_install/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-04 12:33:00 +0900",
    





    
    "snippet": "이번에는 리액트 앱을 직접 만들고 어떻게 사용하는지를 확인해본다Create React App으로 리액트 앱 만들기리액트 앱은 처음 만들 때 꽤 복잡한 설정을 직접 해주어야 한다. Node.js를 많이 사용해본 사람에게는 쉬울 수 있지만 입문자에게는 꽤나 큰 장벽이다따라서 리액트 앱을 만들기 위해 Create React App이라는 Node.js 라이브...",
    "content": "이번에는 리액트 앱을 직접 만들고 어떻게 사용하는지를 확인해본다Create React App으로 리액트 앱 만들기리액트 앱은 처음 만들 때 꽤 복잡한 설정을 직접 해주어야 한다. Node.js를 많이 사용해본 사람에게는 쉬울 수 있지만 입문자에게는 꽤나 큰 장벽이다따라서 리액트 앱을 만들기 위해 Create React App이라는 Node.js 라이브러리를 이용할 예정이다. Create React App은 복잡한 설정 없이 리액트 앱을 만들어 주는 고마운 라이브러리이다  “Create React App은 보일러 플레이트”  Create React App처럼 복잡한 설정 없이 쉽게 프로젝트를 생성하도록 돕는 개발 도구를 보일러 플레이트라고 한다. 보일러 플레이트란 ‘보일러를 찍어내는 틀’이라는 의미를 담고 있으며 보일러 플레이트를 이용하면 처음 보일러를 만들 때처럼 복잡한 구조를 염두에 두지 않고도 쉽게 보일러를 만들 수 있다.Node.js와 npm설치  nodejs는 자바스크립트로 네트워크 어플리케이션을 개발할 수 있도록 환경구성을 도와주는 라이브러리  npm는 node package manager 의 약자로 프로젝트에서 필요하는 외부 라이브러리 버전등을 관리해주는 라이브러리이며 nodejs설치시 npm은 자동으로 설치된다      (1) nodejs 다운로드 페이지 에서 운영체제에 맞게 설치하기        (2) 터미널을 열어 하기 명령어로 설치확인 (각 버전명이 나오면 정상)    $ node --version$ npm --version      React 프로젝트 만들기(1) cmd 명령프롬프트 혹은 vscode의 터미널을 열어서 하기 명령어를 수행###### 프로젝트 생성 명령어 ######$ npx create-react-app &lt;만들고자하는 프로젝트 이름&gt;(2) cmd 명령프롬프트 혹은 vscode의 터미널을 열어서 하기 명령어를 수행###### 프로젝트 폴더로 이동후 프로젝트 실행 명령어 ######$ cd &lt;위에서 생성한 프로젝트 이름&gt;$ npm start(3) 웹을 열어서 접속되는지 확인하기[실행 영상]리액트 앱에는 어떻게 접속하는걸까위에서 “create-react-app”으로 리액트 앱을 만들고 “npm run start” 명령으로 앱을 구동해 보았다. 그 결과 리액트 앱을 실행하면 http://localhost:3000으로 접속한다는 사실을 알게 되었다.그렇다면 어떤 원리로 리액트 앱에 접속하는 걸까? 결론부터 말하자면 Create React App으로 만든 리액트 앱에는 “웹 서버”가 내장되어 있다. 즉, npm run start 명령을 실행하면 브라우저가 리액트 앱에 접속하도록 앱에 내장된 웹 서버가 동작하며 결국 내장된 웹 서버 주소로 브라우저가 자동으로 접속하게되는것이다.보여지는 구성은 어떻게 되는걸까사용자가 주소 http://localhost:3000으로 리액트 앱에 대한 서비스를 요청하면, 리액트 앱 서버는 우선 웹 페이지 파일인 public 폴더의 index.html을 보낸다.index.html 파일내의 아래와 같이 ReactDOM.createRoot는 인수로 전달된 요소를 리액트 앱의 루트로 만들어 반환하는 메서드를 사용한다.“const root = ReactDOM.createRoot(document.getElementById(‘root’));”이 코드의 의미를 다시 정리하면 돔에서 id가 ‘root’인 요소를 루트로 만들어 root 라는 변수에 저장한다. 바로 public 폴더의 index.html에 있는 “div” 태그가 바로 루트 요소이다."
  },
  
  {
    "title": "React Elements",
    "url": "/posts/react_Element/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-04 12:33:00 +0900",
    





    
    "snippet": "Elements 개요Elements는 요소, 성분의 뜻으로 React앱 또는 기존 웹을 구성하는 가장 작은 블록이다많은 Elemnets들을 관리하는 주최를 DOM이라 하며 기존 웹에도 DOM이 당연히 존재한다기존 웹을 React에서 관리하기 위해 기존 웹 HTML 파일 어딘가에 div태그 있다고 가정했을때 이 안에 들어가는 모든 엘리먼트들을 React...",
    "content": "Elements 개요Elements는 요소, 성분의 뜻으로 React앱 또는 기존 웹을 구성하는 가장 작은 블록이다많은 Elemnets들을 관리하는 주최를 DOM이라 하며 기존 웹에도 DOM이 당연히 존재한다기존 웹을 React에서 관리하기 위해 기존 웹 HTML 파일 어딘가에 div태그 있다고 가정했을때 이 안에 들어가는 모든 엘리먼트들을 React DOM에서 관리하기 위해 ROOT DOM노드를 생성한다Element RenderingReact로 구현된 애플리케이션의 경우 대부분 하나의 ROOT DOM 노드가 있으며 React Element를 렌더링 하기 위해서는 우선 DOM Element를 ReactDOM.createRoot()에 전달한 다음, React Element를 root.render()에 전달해야 한다$ node --version$ npm --versionRendering 된 Element 업데이트하기React의 Element는 불변객체이다 즉, Element를 생성한 이후에는 해당 Element의 자식이나 속성을 변경할 수없다 따라서 Element 요소의 내용을 바꾸고 싶을때는 새로운 Element를 생성하고 이를 다시 root.render()로 다시 Rendering하는 방법뿐이다.매번 다시 렌더링을하지만 ReactDom은 내용이 변경된 Element만 업데이트를한다예시) 초시계"
  },
  
  {
    "title": "Step4 React Components",
    "url": "/posts/react_Component/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-04 12:33:00 +0900",
    





    
    "snippet": "Component 개요React는 모든 페이지가 Component로 구성되어있고 하나의 Component는 여러개의 Component로 구성될 수 있다 (블록을 생각하면 이해하기 쉽다)Component는 JavaScript함수와 유사하며 Props라고 하는 임의의 값을 받은 후 화면에 어떻게 표시되는지를 기술하는 React Element를 반환한다Co...",
    "content": "Component 개요React는 모든 페이지가 Component로 구성되어있고 하나의 Component는 여러개의 Component로 구성될 수 있다 (블록을 생각하면 이해하기 쉽다)Component는 JavaScript함수와 유사하며 Props라고 하는 임의의 값을 받은 후 화면에 어떻게 표시되는지를 기술하는 React Element를 반환한다Component 생성 function Welcome(props) {   return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; }위 함수는 Props 객체 인자를 받은 후 React Element를 return 즉 반환하는 컴포넌트이다이러한 컴포넌트는 JavaScript 함수이기 때문에 말 그대로 함수 컴포넌트라고도 호칭한다최근에 나온 ES6 Class를 사용해서도 컴포넌트를 정의할 수 있다class Welcome extends React.Component {  render() {    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;  }}Component 렌더링 예시function Welcome(props) {  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}const root = ReactDOM.createRoot(document.getElementById('root'));// &lt;Welcome name=\"Sara\" /&gt; 엘리먼트로 root.render()를 호출합니다.// React는 {name: 'Sara'}를 props로 하여 Welcome 컴포넌트를 호출합니다.const element = &lt;Welcome name=\"Sara\" /&gt;;// Welcome 컴포넌트는 결과적으로 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 엘리먼트를 반환합니다.root.render(element);// React DOM은 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 엘리먼트와 일치하도록 DOM을 효율적으로 업데이트합니다."
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part10 회원가입 페이지 구현",
    "url": "/posts/rn_project_matzip10/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-03 12:33:00 +0900",
    





    
    "snippet": "회원가입 페이지 구현하기[matzip/front/src/screens/auth/SignupScreen.tsx]import React from 'react';import {SafeAreaView, StyleSheet, Text, View} from 'react-native';import InputField from '../../components/Inp...",
    "content": "회원가입 페이지 구현하기[matzip/front/src/screens/auth/SignupScreen.tsx]import React from 'react';import {SafeAreaView, StyleSheet, Text, View} from 'react-native';import InputField from '../../components/InputField';import useForm from '../../hooks/useForm';import CustomButton from '../../components/CustomButton';import {validateSignup} from '../../utils';// 로그인에서 구현한 부분과 같이 useForm이라는 만들어둔 훅을 사용하여 데이터를 관리하고 passwordConfirm이라는 새로운 속성을 추가하여 해당 속성은 password 재확인을 위해 사용한다function SignupScreen() {  const signup = useForm({    initialValue: {      email: '',      password: '',      passwordConfirm: '',    },    validate: validateSignup,  });  return (    &lt;SafeAreaView style={styles.container}&gt;      &lt;View style={styles.inputContainer}&gt;        &lt;InputField          placeholder=\"이메일\"          error={signup.errors.email}          touched={signup.touched.email}          inputMode=\"email\"          {...signup.getTextInputProps('email')}        /&gt;        &lt;InputField          placeholder=\"비밀번호\"          error={signup.errors.password}          touched={signup.touched.password}          secureTextEntry          {...signup.getTextInputProps('password')}        /&gt;        &lt;InputField          placeholder=\"비밀번호 확인\"          error={signup.errors.passwordConfirm}          touched={signup.touched.passwordConfirm}          secureTextEntry          {...signup.getTextInputProps('passwordConfirm')}        /&gt;      &lt;/View&gt;      &lt;CustomButton label=\"회원가입\" /&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({  container: {    flex: 1,    margin: 30,  },  inputContainer: {    gap: 20,    marginBottom: 30,  },});export default SignupScreen;유효성 검증 컴포넌트 추가하기[matzip/front/src/utils/validate.ts]전에 사용자가 입력한 데이터 유효성을 검사하는 컴포넌트로 단순 정규식과 비교하여 에러메세지를 리턴할 수 있도록 구현하였던 컴포넌트에 회원가입 페이지도 검증할 수 있도록 변경해보자 type UserInfomation = {   email: string;   password: string; };  function validateUser(values: UserInfomation) {   const errors = {     email: '',     password: '',   };    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(values.email)) {     errors.email = '올바른 이메일 형식이 아닙니다.';   }   if (!(values.password.length &gt;= 8 &amp;&amp; values.password.length &lt;= 20)) {     errors.password = '비밀번호는 8~20자 사이로 입력해주세요.';   }    return errors; }  function validateLogin(values: UserInfomation) {   return validateUser(values); }  function validateSignup(values: UserInfomation &amp; {passwordConfirm: string}) {   const errors = validateUser(values);   const signupErrors = {...errors, passwordConfirm: ''};    if (values.password !== values.passwordConfirm) {     signupErrors.passwordConfirm = '비밀번호가 일치하지 않습니다';   }   return signupErrors; }  export {validateLogin, validateSignup}; 유효성 검사를 적용한 앱화면"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part9 로그인 데이터 유효성 검증 및 리팩토링",
    "url": "/posts/rn_project_matzip09/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-02 12:33:00 +0900",
    





    
    "snippet": "useForm 훅 구현하기[matzip/front/src/hooks/useForm.ts]리액트에서 훅은 v16.8에 새로 도입된 기능으로, 함수형 컴포넌트(Functional Component)에서 사용되는 몇가지 기술들을 일컫는다. 리액트 훅은 함수형 컴포넌트(Functional Component)가 클래스형 컴포넌트(Class Component)의...",
    "content": "useForm 훅 구현하기[matzip/front/src/hooks/useForm.ts]리액트에서 훅은 v16.8에 새로 도입된 기능으로, 함수형 컴포넌트(Functional Component)에서 사용되는 몇가지 기술들을 일컫는다. 리액트 훅은 함수형 컴포넌트(Functional Component)가 클래스형 컴포넌트(Class Component)의기능을 사용 할 수 있도록 해주며 대표적인 예로는 useState, useEffect 등이 존재한다해당 훅을 사용하여 로그인페이지등에서 사용자가 입력한 input 데이터를 가공하는 작업을 진행한다import {useEffect, useState} from 'react';// useForm의 규격 정의 // initialValue는 email, password 데이터의 객체값// validate는 email, password 데이터를 정규식으로 검사후 리턴 받은 객체값 interface UseFormProps&lt;T&gt; {  initialValue: T;  validate: (values: T) =&gt; Record&lt;keyof T, string&gt;;}// values는 email, password 데이터의 객체값// touched는 true,false의 값을 갖고있으며 사용자가 해당 input박스를 터치했는지 확인// errors는 정규식에 따른 이메일, 패스워드 검사 결과 에러메세지를 담는 객체function useForm&lt;T&gt;({initialValue, validate}: UseFormProps&lt;T&gt;) {  const [values, setValues] = useState(initialValue);  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});// 밑에서 정의한 getTextInputProps 함수에 의해서 발동되는 핸들러로 사용자로부터 받은 입력데이터를 values라는 객체에 담는다   const handleChangeText = (name: keyof T, text: string) =&gt; {    console.log(name);    setValues({      ...values,      [name]: text,    });  };// 밑에서 정의한 getTextInputProps 함수에 의해서 발동되는 핸들러로 사용자가 해당 input값을 터치했는지를 감지한다  const handleBlur = (name: keyof T) =&gt; {    setTouched({      ...touched,      [name]: true,    });  };// input에서 입력할때마다 호출되는 함수로 위에 정의한 value, onChangeText, onBlur 값을 저장 및 리턴하기 위한 함수이다  const getTextInputProps = (name: keyof T) =&gt; {    const value = values[name];    const onChangeText = (text: string) =&gt; handleChangeText(name, text);    const onBlur = () =&gt; handleBlur(name);    return {value, onChangeText, onBlur};  };// 렌더링이 될때마다, 값이 바뀔 때마다 사용되는 훅으로 값이 들어올대마다 validate 컴포넌트를 통해 검사후 에러메세지를 newErrors에 담는다  useEffect(() =&gt; {    const newErrors = validate(values);    setErrors(newErrors);  }, [validate, values]);  return {values, errors, touched, getTextInputProps};}export default useForm;유효성 검증 컴포넌트 구현하기[matzip/front/src/utils/validate.ts]사용자가 입력한 데이터 유효성을 검사하는 컴포넌트로 단순 정규식과 비교하여 에러메세지를 리턴할 수 있도록 구현하였다 type UserInfomation = {   email: string;   password: string; };  function validateLogin(values: UserInfomation) {   const errors = {     email: '',     password: '',   };    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(values.email)) {     errors.email = '올바른 이메일 형식이 아닙니다.';   }   if (!(values.password.length &gt;= 8 &amp;&amp; values.password.length &lt;= 20)) {     errors.password = '비밀번호는 8~20자 사이로 입력해주세요.';   }    return errors; }  export {validateLogin}; 로그인 스크린 수정[matzip/front/src/screens/LoginScreens.ts]로그인 화면 페이지를 수정하여 위에서 구현한 유효성검사와 입력데이터 훅을 사용하여 처리해보자import React from 'react';import {SafeAreaView, StyleSheet, View} from 'react-native';import InputField from '../../components/InputField';import CustomButton from '../../components/CustomButton';import useForm from '../../hooks/useForm';import {validateLogin} from '../../utils';// 만들어둔 useForm 훅에 email과 password의 초기값 객체 전달 및 유효성 검증 함수 전달function LoginScreen() {  const login = useForm({    initialValue: {email: '', password: ''},    validate: validateLogin,  });// 아직은 미구현으로 단순 로그인 버튼을 눌렀을때 console.log로 사용자가 입력한 아이디와 비밀번호를 출력하도록 임시 구현  const handleSubmit = () =&gt; {    console.log('login.values', login.values);  };  return (    &lt;SafeAreaView style={styles.container}&gt;      &lt;View style={styles.inputContainer}&gt;        &lt;InputField          placeholder=\"이메일\"          error={login.errors.email}          touched={login.touched.email}          inputMode=\"email\"          {...login.getTextInputProps('email')}        /&gt;        &lt;InputField          placeholder=\"비밀번호\"          error={login.errors.password}          touched={login.touched.password}          secureTextEntry          {...login.getTextInputProps('password')}        /&gt;      &lt;/View&gt;      &lt;CustomButton        label=\"로그인\"        variant=\"filled\"        size=\"large\"        onPress={handleSubmit}      /&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({  container: {    flex: 1,    margin: 30,  },  inputContainer: {    gap: 20,    marginBottom: 30,  },});export default LoginScreen;유효성 검사를 적용한 앱화면"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part8 홈 스크린 및 Input컴포넌트 구현하기",
    "url": "/posts/rn_project_matzip08/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-05-01 12:33:00 +0900",
    





    
    "snippet": "최초 화면에 로고를 표시하기 위해 로고 파일 넣기[matzip/front/src/assets/matzip.png] 해당 경로로 폴더 및 로고파일 넣어주도록하자[matzip/front/src/screens/AuthHomeScreen.tsx] 파일 코드를 수정하자  20번째 줄에 react-native에서 기본으로 제공하는 Image 컴포넌트를 사용해서 ...",
    "content": "최초 화면에 로고를 표시하기 위해 로고 파일 넣기[matzip/front/src/assets/matzip.png] 해당 경로로 폴더 및 로고파일 넣어주도록하자[matzip/front/src/screens/AuthHomeScreen.tsx] 파일 코드를 수정하자  20번째 줄에 react-native에서 기본으로 제공하는 Image 컴포넌트를 사용해서 로고를 불러오도록하였다 resizeMode 옵션으로 contain을 주어 이미지의 가로 세로 비율을 유지한 상태로 이미지를 리사이징하며 이미지의 모든 영역이 뷰 안에 보이게하도록 하였다 style은 하단에 따로 지정하도록했다 source는 로고 경로import {StackScreenProps} from '@react-navigation/stack';import React from 'react';import {  Button,  Dimensions,  Image,  SafeAreaView,  StyleSheet,  View,} from 'react-native';import {AuthStackParamList} from '../../navigations/stack/AuthStackNavigator';import {authNavigations} from '../../constants/navigations';import CustomButton from '../../components/CustomButton';type AuthHomeScreenProps = StackScreenProps&lt;AuthStackParamList&gt;;function AuthHomeScreen({navigation}: AuthHomeScreenProps) {  return (    &lt;SafeAreaView style={styles.container}&gt;      &lt;View style={styles.imageContainer}&gt;        &lt;Image          resizeMode=\"contain\"          style={styles.image}          source={require('../../assets/matzip.png')}        /&gt;      &lt;/View&gt;      &lt;View style={styles.buttonContainer}&gt;        &lt;CustomButton          label=\"로그인하기\"          onPress={() =&gt; navigation.navigate(authNavigations.LOGIN)}        /&gt;        &lt;CustomButton          label=\"회원가입하기\"          variant=\"outlined\"          onPress={() =&gt; navigation.navigate(authNavigations.SIGNUP)}        /&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({  container: {    flex: 1,    margin: 30,    alignItems: 'center',  },  imageContainer: {    flex: 1.5,    width: Dimensions.get('screen').width / 2,  },  image: {    width: '100%',    height: '100%',  },  buttonContainer: {    flex: 1,    gap: 10,  },});export default AuthHomeScreen;InputField 컴포넌트 구현하기[matzip/front/src/components/InputField.tsx]로그인 및 회원가입 페이지 외에도 입력받는 창을 중복적으로 사용하게될텐데 해당 입력 창을 컴포넌트로 작성하여 쉽게 불러와서 사용할 수 있도록 하려고 한다먼저 입력 창 InputField 컴포넌트 코드를 작성해보도록 한다import React, {useRef} from 'react';import {  Dimensions,  Pressable,  StyleSheet,  Text,  TextInput,  TextInputProps,  View,} from 'react-native';import {colors} from '../constants';// TextInputProps를 확장하여 props를 넘겨받아서 사용할 수 있도록하자interface InputFieldProps extends TextInputProps {  disabled?: boolean;  error?: string;  touched?: boolean;}const deviceHeight = Dimensions.get('screen').height;const InputField = ({  disabled = false,  error,  touched,  ...props}: InputFieldProps) =&gt; {  // 입력창 포커스를 조금 더 정확하게 잡기위해 (주변 클릭해도 입력창으로갈 수 있게) useRef를 활용  const innerRef = useRef&lt;TextInput | null&gt;(null);  const handlePressInput = () =&gt; {    innerRef.current?.focus();  };  return (    &lt;Pressable onPress={handlePressInput}&gt;      &lt;View        style={[          styles.container,          disabled &amp;&amp; styles.disabled,          touched &amp;&amp; Boolean(error) &amp;&amp; styles.inputError,        ]}&gt;        &lt;TextInput          editable={!disabled}          placeholderTextColor={colors.GRAY_500}          style={[styles.input, disabled &amp;&amp; styles.disabled]}          autoCapitalize=\"none\"          spellCheck={false}          autoCorrect={false}          {...props}        /&gt;        // error변수의 데이터를 확인하여 값이 없으면 안보여주고 값이있고 touche된 상태면 에러를 보여준다        {touched &amp;&amp; Boolean(error) &amp;&amp; &lt;Text style={styles.error}&gt;{error}&lt;/Text&gt;}      &lt;/View&gt;    &lt;/Pressable&gt;  );};const styles = StyleSheet.create({  container: {    borderWidth: 1,    borderColor: colors.GRAY_200,    padding: deviceHeight &gt; 700 ? 15 : 10,  },  input: {    fontSize: 16,    color: colors.BLACK,    padding: 0,  },  disabled: {    backgroundColor: colors.GRAY_200,    color: colors.GRAY_700,  },  inputError: {    borderWidth: 1,    borderColor: colors.RED_300,  },  error: {    color: colors.RED_500,    fontSize: 12,    paddingTop: 5,  },});export default InputField;LoginScreen 파일 코드 작성[matzip/front/src/screens/LoginScreen.tsx]위에서 만들어둔 InputField 컴포넌트를 불러와서 입력창을 만들도록한다import React, {useState} from 'react';import {SafeAreaView, StyleSheet, Text, TextInput, View} from 'react-native';import InputField from '../../components/InputField';function LoginScreen() {  // const [email, setEmail] = useState('');  // const [password, setPassword] = useState('');  // const handleChangeEmail = (text: string) =&gt; {  //   setEmail(text);  // };  // const handleChangePassword = (text: string) =&gt; {  //   setPassword(text);  // };      // 사용자로부터 입력받은 이메일,비밀번호 데이터를 담기 위한 state지정(바로 위에 주석 코드에서는 이메일 패스워드를 따로 따로 받았지만 코드를 리팩토링하여 하나의 객체로 받음)  const [values, setValues] = useState({    email: '',    password: '',  });  // 사용자가 터치를 했는지 안했는지에 따라 이벤트를 다르게하기위해 state를지정함  const [touched, setTouched] = useState({    email: false,    password: false,  });  // 사용자가 입력할때마다 데이터를 state로 넘겨주기 위함  const handleChangeText = (name: string, text: string) =&gt; {    setValues({      ...values,      [name]: text,    });  };  // 이메일 혹은 비밀번호 데이터가 정규식에 적합한지 확인하기위해 엔터 혹은 해당 focus를 떠났을때를 감지하는 blur이벤트 핸들러를 만들어서 touched에 값을 넣어주었다  const handleBlur = (name: string) =&gt; {    setTouched({      ...touched,      [name]: true,    });  };  return (    &lt;SafeAreaView style={styles.container}&gt;      &lt;View style={styles.inputContainer}&gt;        &lt;InputField          placeholder=\"이메일\"          error={'이메일을 입력하세요'}          touched={touched.email}          inputMode=\"email\"          value={values.email}          onChangeText={text =&gt; handleChangeText('email', text)}          onBlur={() =&gt; handleBlur('email')}        /&gt;        &lt;InputField          placeholder=\"비밀번호\"          error={'비밀번호를 입력하세요'}          touched={touched.password}          secureTextEntry          value={values.password}          onChangeText={text =&gt; handleChangeText('password', text)}          onBlur={() =&gt; handleBlur('password')}        /&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({  container: {    flex: 1,    margin: 30,  },  inputContainer: {    gap: 20,  },});export default LoginScreen;"
  },
  
  {
    "title": "React란",
    "url": "/posts/react_about/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-01 12:33:00 +0900",
    





    
    "snippet": "React란React는 페이스북에서 개발한 오픈 소스 자바스크립트 라이브러리이며 컴포넌트라는 작은 조각들로 UI를 구성한다 또한 Virtual Dom이라는 개념을 사용하여 성능을 최적화한다주요 특징      가독성과 유지보수성: JSX 문법을 사용하여 컴포넌트 기반으로 UI를 작성할 수 있으므로 가독성이 높고 유지보수가 용이하며 각 컴포넌트는 독립적으...",
    "content": "React란React는 페이스북에서 개발한 오픈 소스 자바스크립트 라이브러리이며 컴포넌트라는 작은 조각들로 UI를 구성한다 또한 Virtual Dom이라는 개념을 사용하여 성능을 최적화한다주요 특징      가독성과 유지보수성: JSX 문법을 사용하여 컴포넌트 기반으로 UI를 작성할 수 있으므로 가독성이 높고 유지보수가 용이하며 각 컴포넌트는 독립적으로 작성되어 관련 로직이나 스타일이 캡슐화되어 있다        재사용 가능한 컴포넌트: React는 컴포넌트 기반의 아키텍처를 채택하고 있어, 재사용 가능한 UI 요소를 쉽게 작성할 수 있다 이로써 개발 속도를 높이고 일관된 UI를 유지할 수 있다        가상 DOM과 성능 최적화: React는 Virtual DOM을 사용하여 실제 DOM과의 차이를 최소화하여 성능을 향상시킨다, 변경된 부분만 업데이트되므로 불필요한 렌더링이나 DOM 조작을 최소화 가능        배우기 쉬운 문법: React의 문법은 간단하고 직관적이며, 자바스크립트와 JSX를 사용하여 작성되며 이는 새로운 개발자들이 빠르게 학습하고 프로젝트에 참여할 수 있도록 도와준다        라이브러리와 생태계의 풍부함: React는 다양한 라이브러리와 플러그인이 존재하며, 이러한 생태계는 개발 생산성을 높이고 다양한 기능을 추가할 수 있는 환경을 제공한다        커뮤니티와 지원: React는 매우 큰 개발자 커뮤니티를 보유하고 있으며, 많은 문제에 대한 해결책과 도움을 얻을 수 있다. 또한 페이스북과 다른 기업들이 백업을 제공하고 있어 안정적인 지원을 받을 수 있다  장점(1) 빠른 업데이트와 렌더링 속도 : Virtual DOM을 사용하여 사용자에게 빠른 렌더링 속도를 보여준다(2) 리액트는 Component로 구성되어있기 때문에 재사용성이 높게 개발하기가 쉽다(3) 든든한 지원군 Meta…(4) 활발한 지식공유와 방대한 커뮤니티단점(1) 방대한 학습량 (새로운 개념들이 많기에..)(2) 잦은 업데이트에 따른 학습 난이도가 높다(3) 높은 상태관리 복잡도코드로 이해해보기아래와 같이 각 페이지들을 보여주는 간단한 html소스를 작성하였을때문제점이 있다.바로 “중복코드” 라는 문제점인데 저렇게 모든 페이지에 header부분을 수동으로 입력하게되면 header내용을 수정하려면 모든 페이지를 직접 수정해야하는 문제가 발생할 것이다.컴포넌트를 사용하지 않은 예제[index.html]&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;!-- HEADER --&gt;    &lt;header&gt;      &lt;h1&gt;안녕하세요 조계진입니다&lt;/h1&gt;    &lt;/header&gt;    &lt;article&gt;      &lt;h3&gt;이 페이지는 HOME 화면입니다&lt;/h3&gt;    &lt;/article&gt;  &lt;/body&gt;&lt;/html&gt;[about.html]&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;!-- HEADER --&gt;    &lt;header&gt;      &lt;h1&gt;안녕하세요 조계진입니다&lt;/h1&gt;    &lt;/header&gt;    &lt;article&gt;      &lt;h3&gt;이 페이지는 About 화면입니다&lt;/h3&gt;    &lt;/article&gt;  &lt;/body&gt;&lt;/html&gt;컴포넌트를 사용한 예제위와 다르게 header 컴포넌트 파일을 하나 생성하여 header태그를 리턴하는 함수를 만들고 모든 페이지에서는 해당 header 컴포넌트만 불러와서 간편하고 쉬운 유지보수를할 수 있다.[header.html]function MyHeader() {  return (    &lt;header&gt;      &lt;h1&gt;안녕하세요 조계진입니다&lt;/h1&gt;    &lt;/header&gt;  );}[about.html]&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;!-- HEADER --&gt;    &lt;MyHeader /&gt;    &lt;article&gt;      &lt;h3&gt;이 페이지는 About 화면입니다&lt;/h3&gt;    &lt;/article&gt;  &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "JSX란",
    "url": "/posts/jsx/",
    "categories": "Framework, React",
    "tags": "React",
    "date": "2024-05-01 12:33:00 +0900",
    





    
    "snippet": "개요      JSX 는 JavaScript 문법을 확장한것으로 JavaScript + XML/HTML로 볼 수 있다        JSX는 리액트로 프로젝트를 개발할 때 사용되므로 공식적인 자바스크립트 문법은 아니다        JSX는 React “엘리먼트(element)”를 생성한다. React 엘리먼트는 브라우저 DOM 엘리먼트와 달리 일반 객체...",
    "content": "개요      JSX 는 JavaScript 문법을 확장한것으로 JavaScript + XML/HTML로 볼 수 있다        JSX는 리액트로 프로젝트를 개발할 때 사용되므로 공식적인 자바스크립트 문법은 아니다        JSX는 React “엘리먼트(element)”를 생성한다. React 엘리먼트는 브라우저 DOM 엘리먼트와 달리 일반 객체이다.        React는 JSX 사용이 필수가 아니지만, JS 코드 안에서 UI관련 작업을 할 수 있기 때문에 시각적으로 더 도움이 된다. 또한 JSX를 사용하면 React가 더욱 도움이 되는 에러 및 경고 메시지를 표시할 수 있게 해준다      [JSX를 사용하면 아래와 같이 XML, HTML코드를 변수에 넣는것도 가능하다]JSX를 사용하는 이유(1) JSX에는 div, span 같은 HTML 태그를 사용할 수 있으며, 개발자가 만든 컴포넌트도 JSX 안에서 작성할 수 있다(2) JSX는 HTML 코드와 비슷하기 때문에 일반 자바스크립만 사용한 코드보다 더 익숙하며 가독성이 좋다"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part7 Pressable 컴포넌트 개념과 Button 컴포넌트 구현하기",
    "url": "/posts/rn_project_matzip07/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-19 12:33:00 +0900",
    





    
    "snippet": "공통 컴포넌트여러 페이지에서 버튼과 같이 동일한 스타일을 여러번 사용하고 싶은경우 컴포넌트를 생성해 가져다 사용하면 효율적으로 구현할 수 있다Pressable 컴포넌트Pressable 컴포넌트는 터치 이벤트를 처리하는 데 사용되는 컴포넌트이다👉🏻리액트네이티브 Pressable 공식문서 여기를 참고기본적으로 touchableopacity와 같이 버튼의 ...",
    "content": "공통 컴포넌트여러 페이지에서 버튼과 같이 동일한 스타일을 여러번 사용하고 싶은경우 컴포넌트를 생성해 가져다 사용하면 효율적으로 구현할 수 있다Pressable 컴포넌트Pressable 컴포넌트는 터치 이벤트를 처리하는 데 사용되는 컴포넌트이다👉🏻리액트네이티브 Pressable 공식문서 여기를 참고기본적으로 touchableopacity와 같이 버튼의 역할을 하지만, 더 다양한 press 단계를 추적할 수 있다.      onPress : 터치가 해제된 후에 호출        onPressIn : 터치 되었을 때 호출        onPressOut : 터치가 해지 되었을 때 호출        onLongPress : 일정 시간(delayLongPress={2000}) 동안 터치가 지속되었을 때 호출  CustomButton 파일 코드 작성[matzip/front/src/components/CustomButton.tsx]  14번째 줄에 PressableProps를 상속받은 이유는 custombutton로 각 컴포넌트에서 onpress 이벤트를 보내는데 onpress이벤트를 처리하기 위해서는 PressableProps를 상속받아서 사용해야한다label속성은 버튼을 불러올때 버튼이름, variant 속성은 테두리색 여부,  size속성은 버튼의 크기, inValid속성은 버튼 활성화 상태를 저장하기 위해 정의해두었다 각 속성에 따라 스타일을 바꾸도록 하단 코드에 스타일시트로 작성하였다  21번째 줄에 Dimensions.get('screen').height 은 현재 기기의 화면 사이즈를 출력하는데 해당 사이즈를 추출해서 버튼 크기등을 조정하기 위해 deviceHeight에 받았다  23번째 줄부터 실제로 각 컴포넌트에서 호출하는 CustomButton부분의 파라미터를 지정한다 ...props 로 받는 이유는 각 컴포넌트에서 CustomButton을 호출할때 onPress로 터치 이벤트를 전달하는데 해당 이벤트를 담아서 바로 처리할 수 있도록  PressableProps를 상속받은 이유기 때문에 ...props를 사용하여 받아주었다  29번째 줄에 위에서 추가한 interface를 타입으로 지정하여 타입 검사를 진행한다  32번째 줄부터 Pressable을 사용하면 리턴 값으로 &lt;Pressable&gt;&lt;/Pressable&gt; 을 리턴하는데 disabled 활성화 속성값, style속성 값, pops 를 리턴하여 처리하였다  35번째 줄에 Pressable을 사용하면 pressed라는 이벤트를 받을 수 있는데 버튼을 누르면 pressed는 true값으로 전달된다 해당 기능을 이용하면 38번째 줄 처럼 true냐 false냐의 값에 따라 style을 다르게 지정할 수 있다  39번째 줄은 inValid 속성은 버튼 활성화 상태로 true인 경우에만 styles.inValid를 적용하도록하였다import React from 'react';import {  Dimensions,  Pressable,  PressableProps,  StyleSheet,  Text,  View,} from 'react-native';import {colors} from '../constants';//  pressableprops를 상속받은 이유는 custombutton로 각 컴포넌트에서 onpress 이벤트를 보내는데// onpress이벤트를 처리하기 위해서는 PressableProps를 상속받아서 사용해야한다interface CustomButtonProps extends PressableProps {  label: string; // 버튼의 이름을 나타내기 위한 속성  variant?: 'filled' | 'outlined'; // variant 속성은 색상이있는 버튼인지 테두리 색만 있는 버튼인지 구분  size?: 'large' | 'medium'; // 버튼의 사이즈  inValid?: boolean; // 버튼의 비활성화 상태}// 스마트폰 기기의 화면 정보를 가져옴 (스타일을 기기마다 다르게하기 위해서) const deviceHeight = Dimensions.get('screen').height;function CustomButton({  label,  variant = 'filled',  size = 'large',  inValid = false,  ...props}: CustomButtonProps) {  return (    // 여러 스타일을 적용할 때는 배열[]안에 콤마로 구분해서 넣으면 된다    &lt;Pressable      disabled={inValid}      // inValid가 true일때만 styles.invlid 적용      style={({pressed}) =&gt; [        styles.container,        styles[size],        pressed ? styles[`${variant}Pressed`] : styles[variant],        inValid &amp;&amp; styles.inValid,      ]}      {...props}&gt;      &lt;Text style={[styles.text, styles[`${variant}Text`]]}&gt;{label}&lt;/Text&gt;    &lt;/Pressable&gt;  );}const styles = StyleSheet.create({  container: {    borderRadius: 3,    justifyContent: 'center',  },  inValid: {    opacity: 0.5,  },  filled: {    backgroundColor: colors.PINK_700,  },  outlined: {    borderColor: colors.PINK_700,    borderWidth: 1,  },  filledPressed: {    backgroundColor: colors.PINK_700,  },  outlinedPressed: {    backgroundColor: colors.PINK_500,    borderWidth: 1,    opacity: 0.5,  },  large: {    width: '100%',    paddingVertical: deviceHeight &gt; 700 ? 15 : 10,    alignItems: 'center',    justifyContent: 'center',  },  medium: {    width: '50%',    paddingVertical: deviceHeight &gt; 700 ? 12 : 8,    alignItems: 'center',    justifyContent: 'center',  },  text: {fontSize: 16, fontWeight: '700'},  filledText: {color: colors.WHITE},  outlinedText: {color: colors.PINK_700},});export default CustomButton;Colors 상수화 파일 코드 작성[matzip/front/src/constants/colors.ts]색깔을 담고있는 상수파일을 저번에 만들어두었는데 해당 컴포넌트에서 반복되는 색상들을 추가하여 상수파일에서 가져와 사용하도록 하였다const colors = {  PINK_700: '#C63B64',  PINK_500: '#BF5C79',  GRAY_200: '#E7E7E7',  GRAY_500: '#8E8E8E',  GRAY_700: '#575757',  WHITE: '#fff',  BLACK: '#000',  RED_300: '#FFB4B4',  RED_500: '#FF5F5F',};export {colors};AuthHomeScreen 파일 코드 작성[matzip/front/src/screens/AuthHomeScreen.tsx]해당 스크린은 로그인을 안한 사용자가 로그인 버튼 및 회원가입 버튼을 보게되는 스크린으로위에서 만들어둔 custombutton 컴포넌트를 사용하여 버튼을 만들도록한다      13번째 줄에 CustomButton을 불러와 버튼을 생성하고 파라미터로 label과 variant 그리고 onPress를 전달한다 로그인에서는 variant 속성을 넘기지 않는데 CustomButton 기본 값이 filled로 되어있기 때문에 회원가입에서만 variant를 전달하여 테두리 있는 버튼을 생성하였다    onPress로 전달하는 값은 navigator에 지정해둔 스크린값으로 각각 상수화했던 변수를 넘겨주어 처리하도록 하였다.  import {StackScreenProps} from '@react-navigation/stack';import React from 'react';import {Button, SafeAreaView, StyleSheet, View} from 'react-native';import {AuthStackParamList} from '../../navigations/stack/AuthStackNavigator';import {authNavigations} from '../../constants/navigations';import CustomButton from '../../components/CustomButton';type AuthHomeScreenProps = StackScreenProps&lt;AuthStackParamList&gt;;function AuthHomeScreen({navigation}: AuthHomeScreenProps) {  return (    &lt;SafeAreaView&gt;      &lt;View&gt;        &lt;CustomButton          label=\"로그인하기\"          onPress={() =&gt; navigation.navigate(authNavigations.LOGIN)}        /&gt;        &lt;CustomButton          label=\"회원가입하기\"          variant=\"outlined\"          onPress={() =&gt; navigation.navigate(authNavigations.SIGNUP)}        /&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({});export default AuthHomeScreen;CustomButton을 적용한 앱화면"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part6 스크린 구조 및 옵션 설정",
    "url": "/posts/rn_project_matzip06/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-18 12:33:00 +0900",
    





    
    "snippet": "스크린 폴더 구조화하기현재 스크린파일들은 [matzip/front/src/navigations/screens] 밑에 있는데 조금 더 세분화하여 구조화를 진행한다      screens                  auth                  AuthHomeScreen.tsx          LoginScreen.tsx          Si...",
    "content": "스크린 폴더 구조화하기현재 스크린파일들은 [matzip/front/src/navigations/screens] 밑에 있는데 조금 더 세분화하여 구조화를 진행한다      screens                  auth                  AuthHomeScreen.tsx          LoginScreen.tsx          SignupScreen.tsx                            calender                  CalendarHomeScreen.tsx                            feed                  FeedHomeScreen.tsx                            map                  MapHoemScreen.tsx                    MainDrawerNavigator 코드 작성[matzip/front/src/navigations/drawer/MainDrawerNavigator.tsx]로그인된 사용자 화면인 drawer navigator에 피드 화면과 캘린더 화면을 추가하기 위해 코드를 추가한다  11, 12번째 줄 feed, calendar 스크린을 추가한다import {createDrawerNavigator} from '@react-navigation/drawer';import MapHomeScreen from '../../screens/map/MapHomeScreen';import FeedHomeScreen from '../../screens/feed/FeedHomeScreen';import CalendarHomeScreen from '../../screens/calender/CalendarHomeScreen';const Drawer = createDrawerNavigator();function MainDrawerNavigator() {  return (    &lt;Drawer.Navigator&gt;      &lt;Drawer.Screen name=\"MapHome\" component={MapHomeScreen} /&gt;      &lt;Drawer.Screen name=\"FeedHome\" component={FeedHomeScreen} /&gt;      &lt;Drawer.Screen name=\"CalendarHome\" component={CalendarHomeScreen} /&gt;    &lt;/Drawer.Navigator&gt;  );}export default MainDrawerNavigator;FeedHomeScreen 코드 작성[matzip/front/src/navigations/screen/feed/FeedHomeScreen .tsx]import React from 'react';import {StyleSheet, Text, View} from 'react-native';function FeedHomeScreen() {  return (    &lt;View&gt;      &lt;Text&gt;피드홈&lt;/Text&gt;    &lt;/View&gt;  );}const styles = StyleSheet.create({});export default FeedHomeScreen;FeedHomeScreen 코드 작성[matzip/front/src/navigations/screen/calender/CalendarHomeScreen.tsx]import React from 'react';import {StyleSheet, Text, View} from 'react-native';function CalendarHomeScreen() {  return (    &lt;View&gt;      &lt;Text&gt;캘린더&lt;/Text&gt;    &lt;/View&gt;  );}const styles = StyleSheet.create({});export default CalendarHomeScreen;SignupScreen 코드 작성[matzip/front/src/navigations/screen/auth/SignupScreen .tsx]비로그인 사용자인 stack navigation에서  사용할 회원가입 스크린도 간단하게 추가해두도록하자import React from 'react';import {StyleSheet, Text, View} from 'react-native';function SignupScreen() {  return (    &lt;View&gt;      &lt;Text&gt;회원가입스크린&lt;/Text&gt;    &lt;/View&gt;  );}const styles = StyleSheet.create({});export default SignupScreen;constants 상수 파일 코드 수정[matzip/front/src/constants/navigations.ts]  4번째 줄에 회원가입 파라미터로 사용할 SIGNUP을 추가해두었다const authNavigations = {  AUTH_HOME: 'AuthHome',  LOGIN: 'Login',  SIGNUP: 'Signup',} as const;export {authNavigations};AuthStackNavigator 파일 코드 수정[matzip/front/src/navigations/stack/AuthStackNavigator.tsx]  13번째 줄에 [authNavigations.SIGNUP]: undefined; 를 추가하여 상수화한 SIGNUP도 파라미터 타입으로 지정해두도록 한다  42번째 줄에 회원가입 스크린도 추가하도록 한다.import {createStackNavigator} from '@react-navigation/stack';import React from 'react';import {StyleSheet} from 'react-native';import AuthHomeScreen from '../../screens/auth/AuthHomeScreen';import LoginScreen from '../../screens/auth/LoginScreen';import {authNavigations} from '../../constants';import SignupScreen from '../../screens/auth/SignupScreen';export type AuthStackParamList = {  [authNavigations.AUTH_HOME]: undefined;  [authNavigations.LOGIN]: undefined;  [authNavigations.SIGNUP]: undefined;};const Stack = createStackNavigator&lt;AuthStackParamList&gt;();function AuthStackNavigator() {  return (    &lt;Stack.Navigator      screenOptions={{        cardStyle: {          backgroundColor: 'white',        },        headerStyle: {          backgroundColor: 'white',          shadowColor: 'gray',        },        headerTitleStyle: {          fontSize: 15,        },        headerTintColor: 'black',      }}&gt;      &lt;Stack.Screen        name={authNavigations.AUTH_HOME}        component={AuthHomeScreen}        options={{headerTitle: '', headerShown: false}}      /&gt;      &lt;Stack.Screen        name={authNavigations.LOGIN}        component={LoginScreen}        options={{headerTitle: '로그인'}}      /&gt;      &lt;Stack.Screen        name={authNavigations.SIGNUP}        component={SignupScreen}        options={{headerTitle: '회원가입'}}      /&gt;    &lt;/Stack.Navigator&gt;  );}const styles = StyleSheet.create({});export default AuthStackNavigator;AuthHomeScreen 파일 코드 수정[matzip/front/src/navigations/screen/auth/AuthHomeScreen.tsx]  15번째 줄에 회원가입 버튼도 추가해두도록 한다import {StackScreenProps} from '@react-navigation/stack';import React from 'react';import {Button, SafeAreaView, StyleSheet, View} from 'react-native';import {AuthStackParamList} from '../../navigations/stack/AuthStackNavigator';import {authNavigations} from '../../constants';type AuthHomeScreenProps = StackScreenProps&lt;AuthStackParamList&gt;;function AuthHomeScreen({navigation}: AuthHomeScreenProps) {  return (    &lt;SafeAreaView&gt;      &lt;View&gt;        &lt;Button          title=\"로그인화면으로 이동\"          onPress={() =&gt; navigation.navigate(authNavigations.LOGIN)}&gt;&lt;/Button&gt;        &lt;Button          title=\"회원가입으로 이동\"          onPress={() =&gt; navigation.navigate(authNavigations.SIGNUP)}&gt;&lt;/Button&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({});export default AuthHomeScreen;"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part5 Drawer Navigation 설치 및 적용",
    "url": "/posts/rn_project_matzip05/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-18 12:33:00 +0900",
    





    
    "snippet": "Drawer Navigator란아래와 같이 화면 간 탐색을 위해 왼쪽(때로는 오른쪽)의 서랍을 사용할 수 있게해주는 기능이다해당 프로젝트에서는 사용자가 바로 Drawer Navigation기능을 사용하는것이 아닌 로그인에 성공한 사용자만 Drawer기능을 사용하고 로그인하지 않은 사용자는 Stack Navigation기능을 사용한다Darawer Nav...",
    "content": "Drawer Navigator란아래와 같이 화면 간 탐색을 위해 왼쪽(때로는 오른쪽)의 서랍을 사용할 수 있게해주는 기능이다해당 프로젝트에서는 사용자가 바로 Drawer Navigation기능을 사용하는것이 아닌 로그인에 성공한 사용자만 Drawer기능을 사용하고 로그인하지 않은 사용자는 Stack Navigation기능을 사용한다Darawer Navigator 설치npm install @react-navigation/drawernpm install react-native-gesture-handler react-native-reanimatedPlugin설정[matzip/front/babel.config.js] 파일을 수정한다기존에 작성되어있는 module.exports 가 보이고 presets 속성값이 보일텐데 하단에 plugins를 추가하자module.exports = {  presets: ['module:@react-native/babel-preset'],  plugins: ['react-native-reanimated/plugin'],};Drawer Navigator 코드 작성[matzip/front/src/navigations/drawer/MainDrawerNavigator.tsx] 파일을 작성한다  4번째 줄 stack navigator 사용했던것과 동일하게  createDrawerNavigator를 불러와서 Drawer로 사용하도록하자  7번째 줄 Drawer.Navigator로 Drawer.Screen을 감싸고 Drawer.Screen에는 이동할 Screen들을 정의한다import {createDrawerNavigator} from '@react-navigation/drawer';import MapHomeScreen from '../../screens/MapHomeScreen';const Drawer = createDrawerNavigator();function MainDrawerNavigator() {  return (    &lt;Drawer.Navigator&gt;      &lt;Drawer.Screen name=\"MapHome\" component={MapHomeScreen} /&gt;    &lt;/Drawer.Navigator&gt;  );}export default MainDrawerNavigator;MapHomeScreen 코드 작성[matzip/front/src/navigations/screens/MapHomeScreen.tsx] 파일을 작성한다Drawer Navigation의 Screen으로 사용할 MapHomeScreen코드를 작성한다import React from 'react';import {StyleSheet, Text, View} from 'react-native';function MapHomeScreen() {  return (    &lt;View&gt;      &lt;Text&gt;맵 스크린&lt;/Text&gt;    &lt;/View&gt;  );}const styles = StyleSheet.create({});export default MapHomeScreen;RootNavigator 코드 작성[matzip/front/src/navigations/root/RootNavigator.tsx] 파일을 작성한다사용자가 앱을 실행했을때 제일 먼저 걸쳐가는 곳으로 로그인된 사용자인지 아닌지를 구분하는 부분으로 사용할 것이다  1, 2번째 줄에 stack 과 drawer의 navigator 파일들을 import해주도록하자  5번째 줄에 추후에 로그인 검증을 타고 상태값으로 drawer로 보낼지 stack으로 보낼지를 정하겠지만 현재는 임시로 isLoggedIn을 true로 줘서 로그인된 사용자로 가정하고 작성한다  7번째 줄에 5번째 줄의 isLoggedIn정보에 따라 로그인된 상태(true)면 drawer로 로그인이 안된 상태(false)면 stack으로 보내도록한다import AuthStackNavigator from '../stack/AuthStackNavigator';import MainDrawerNavigator from '../drawer/MainDrawerNavigator';function RootNavigator() {  const isLoggedIn = true;  return &lt;&gt;{isLoggedIn ? &lt;MainDrawerNavigator /&gt; : &lt;AuthStackNavigator /&gt;}&lt;/&gt;;}export default RootNavigator;App코드 작성[matzip/front/App.tsx] 파일을 작성한다  이전 코드에서 사용하지 않는 코드는 모두 제거하였다  8번째 줄에서 위에서 작성한 RootNavigator로 앱 실행시 제일 먼저 처리하도록 변경하였다import {NavigationContainer} from '@react-navigation/native';import React from 'react';import RootNavigator from './src/navigations/root/RootNavigator';function App() {  return (    &lt;NavigationContainer&gt;      &lt;RootNavigator /&gt;    &lt;/NavigationContainer&gt;  );}export default App;Drawer 적용된 현재 화면Android 실행 오류시  npx react-native start –reset-cache  cd android -&gt; .\\gradlew clean -&gt; npm run android"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part4 상수화와 navigation 고도화",
    "url": "/posts/rn_project_matzip04/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-18 12:33:00 +0900",
    





    
    "snippet": "반복되는 값과 변경되지 않는 변수들을 상수화하기위해 상수 파일을 만든다[matzip/front/src/constants/navigations.ts] 파일을 작성한다authNavigations는 각 스크린들의 네임을 매번 호출하기때문에 따로 상수화를 해주고 export로 외부에서 가져올 수 있도록하였다나중에 버튼 색상등 반복되어 사용되는 고정 변수들은 ...",
    "content": "반복되는 값과 변경되지 않는 변수들을 상수화하기위해 상수 파일을 만든다[matzip/front/src/constants/navigations.ts] 파일을 작성한다authNavigations는 각 스크린들의 네임을 매번 호출하기때문에 따로 상수화를 해주고 export로 외부에서 가져올 수 있도록하였다나중에 버튼 색상등 반복되어 사용되는 고정 변수들은 해당 파일에 선언하려고한다const authNavigations = {  AUTH_HOME: 'AuthHome',  LOGIN: 'Login',} as const;export {authNavigations};상수화 사용 및 타입지정으로 AuthStackNavigator 코드 작성[matzip/front/src/navigations/stack/AuthStackNavigator.tsx] 파일을 작성한다먼저 AuthStackNavigator.tsx파일은 네비게이션 라우팅 기능을 수행하는 파일로 어떤 페이지로 이동할때 제일 먼저 거쳐가는 곳이다기존 내용에서 변경 부분을 확인해보자  6번째 줄에 상수화를 했던 authNavigations를 import해준다  8번째 줄에 해당 네비게이터에 들어오는 파라미터 (로그인, 회원가입등)를 타입으로 지정하여 개발자 실수를 줄이기위해 작성하였다 export한 이유는 다른 스크린에서도 해당 타입으로 검사후 전달하기 위해서 사용  12번째 줄에 제네릭 파라미터로 타입을 위에 8번째 줄에서 작성한 type검사를 진행하여 받는다  17, 21번째 줄 각각 네비게이터에서 관리하고있는 스크린 페이지들의 이름을 상수화로 작성하였다 name={authNavigations.HOME,authNavigations.LOGIN}import {createStackNavigator} from '@react-navigation/stack';import React from 'react';import {StyleSheet} from 'react-native';import AuthHomeScreen from '../screens/AuthHomeScreen';import LoginScreen from '../screens/LoginScreen';import {authNavigations} from '../constants';export type AuthStackParamList = {  [authNavigations.AUTH_HOME]: undefined;  [authNavigations.LOGIN]: undefined;};const Stack = createStackNavigator&lt;AuthStackParamList&gt;();function AuthStackNavigator() {  return (    &lt;Stack.Navigator&gt;      &lt;Stack.Screen        name={authNavigations.AUTH_HOME}        component={AuthHomeScreen}      /&gt;      &lt;Stack.Screen name={authNavigations.LOGIN} component={LoginScreen} /&gt;    &lt;/Stack.Navigator&gt;  );}const styles = StyleSheet.create({});export default AuthStackNavigator;AuthHomeScreen 파일 코드 작성네비게이터의 관리받고있는 사용자 최초화면 AuthHomeScreen을 수정하도록하자  1번째 줄 Stack의 Screen으로 렌더링되는 컴포넌트는 자동으로 navigation props와 route props를 주입받는다  2번째 줄 상수화시킨 파일을 불러오자  6번째 줄 위에서 네비게이터에 전달되는 파라미터를 제네릭 파라미터로 타입검사를하게끔 코드를 작성하였기 때문에 해당 AuthHomeScreen 스크린 파일에서도 타입을 하나 만들고 네비게이터에서 만들어둔 타입을 그대로 받아서 사용하자  7번째 줄 AuthHomeScreen 파라미터의 값 타입을 6번째 줄에서 만든 타입으로 검사하도록하자  14번째 줄 로그인버튼을 눌렀을때 네비게이션으로 전달되는 파라미터를 위에 2번째줄에서 상수화한 authNavigations.LOGIN 를 사용하자import {StackScreenProps} from '@react-navigation/stack';import {authNavigations} from '../constants';import React from 'react';import {Button, SafeAreaView, StyleSheet, View} from 'react-native';import {AuthStackParamList} from '../navigation/AuthStackNavigator';type AuthHomeScreenProps = StackScreenProps&lt;AuthStackParamList&gt;;function AuthHomeScreen({navigation}: AuthHomeScreenProps) {  return (    &lt;SafeAreaView&gt;      &lt;View&gt;        &lt;Button          title=\"로그인화면으로 이동\"          onPress={() =&gt; navigation.navigate(authNavigations.LOGIN)}&gt;&lt;/Button&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({});export default AuthHomeScreen;"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part3 stack navigation",
    "url": "/posts/rn_project_matzip03/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-17 12:33:00 +0900",
    





    
    "snippet": "Stack Navigationstack navigator라는 컨트롤러가 하위에 stack screen을 갖는데  새로운 스크린으로 이동할 때마다 Stack 맨 위에 싸여서, 순차적으로 앞뒤 화면 이동이 가능하게 해주는 기능이다navigation 기능을 위해 AuthStackNavigator 코드 작성[matzip/front/src/navigations...",
    "content": "Stack Navigationstack navigator라는 컨트롤러가 하위에 stack screen을 갖는데  새로운 스크린으로 이동할 때마다 Stack 맨 위에 싸여서, 순차적으로 앞뒤 화면 이동이 가능하게 해주는 기능이다navigation 기능을 위해 AuthStackNavigator 코드 작성[matzip/front/src/navigations/stack/AuthStackNavigator.tsx] 파일을 작성한다해당 파일은 로그인화면이나 회원가입화면 등 여러 컴퍼넌트 페이지로 자연스럽게 이동할 수 있도록 사용되는 navigation 및 stack을 작성한다import {createStackNavigator} from '@react-navigation/stack';import React from 'react';import {StyleSheet, View} from 'react-native';import AuthHomeScreen from '../screens/AuthHomeScreen';import LoginScreen from '../screens/LoginScreen';function AuthStackNavigator() {  const Stack = createStackNavigator();  return (    &lt;Stack.Navigator&gt;      &lt;Stack.Screen name=\"AuthHome\" component={AuthHomeScreen} /&gt;      &lt;Stack.Screen name=\"Login\" component={LoginScreen} /&gt;    &lt;/Stack.Navigator&gt;  );}const styles = StyleSheet.create({});export default AuthStackNavigator;  createStackNavigator : createStackNavigator 메서드는 Screen이랑 Navigator라는 두개의 속성을 반환하는 함수이다 위에서는 Stack이라는 변수에 담아서 Screen과 Navigator를 편하게 불러오기위해 사용되었다  Navigator : 다른 언어에서의 라우터 기능과 비슷한 Navigator는 감싸준 Screen들(컴포넌트)을 컨트롤할 수 있도록한다  Stack.Screen의 name과 component 프로퍼티 : name은 스크린의 이름이고 component에는 컴포넌트 이름을 적어주면된다메인 파일인 App 코드 작성위에서 작성한 AuthStackNavigator를 통해 스크린을 컨트롤하기위해서 시작파일인 App을 변경한다import {NavigationContainer} from '@react-navigation/native';import React, {useState} from 'react';import {  Button,  SafeAreaView,  StyleSheet,  Text,  TextInput,  View,} from 'react-native';import AuthStackNavigator from './src/navigation/AuthStackNavigator';function App() {  const [name, setname] = useState('');  const handleChangeInput = (text: string) =&gt; {    console.log(text);    setname(text);  };  return (    &lt;NavigationContainer&gt;      &lt;AuthStackNavigator /&gt;    &lt;/NavigationContainer&gt;  );}const styles = StyleSheet.create({  container: {},  input: {},});export default App;최초화면인 AuthHomeScreen 코드 작성로그인 화면으로 이동할 수 있는 버튼을 만들어 해당 버튼에 navigation을 연결해주었다import React from 'react';import {Button, SafeAreaView, StyleSheet, View} from 'react-native';function AuthHomeScreen({navigation}) {  return (    &lt;SafeAreaView&gt;      &lt;View&gt;        &lt;Button          title=\"로그인화면으로 이동\"          onPress={() =&gt; navigation.navigate('Login')}&gt;&lt;/Button&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({});export default AuthHomeScreen;  컴포넌트들은 navigation이라는 props를 받을 수 있고 해당 navigation.navigate을통해 화면 전환 기능을 사용할 수 있다 , navigation.navigate안에 값에는 이동하고 싶은 페이지 네임을 AuthStackNavigator파일에서 작성한 컴포넌트 네임으로 작성해준다[현재까지 완성된 부분]"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part2 최초화면 및 로그인 화면 초기구성",
    "url": "/posts/rn_project_matzip02/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-16 12:33:00 +0900",
    





    
    "snippet": "최초화면인 AuthHomeScreen 코드 작성[matzip/front/src/screens/AuthHomeScreen.tsx] 파일을 작성한다해당 파일은 로그인화면으로 이동, 회원가입화면으로 이동등의 기능을 갖는 사용자 최초 화면으로 사용예정import React from 'react';import {Button, SafeAreaView, Style...",
    "content": "최초화면인 AuthHomeScreen 코드 작성[matzip/front/src/screens/AuthHomeScreen.tsx] 파일을 작성한다해당 파일은 로그인화면으로 이동, 회원가입화면으로 이동등의 기능을 갖는 사용자 최초 화면으로 사용예정import React from 'react';import {Button, SafeAreaView, StyleSheet, View} from 'react-native';function AuthHomeScreen() {  return (    &lt;SafeAreaView&gt;      &lt;View&gt;        &lt;Button title=\"로그인화면으로 이동\"&gt;&lt;/Button&gt;      &lt;/View&gt;    &lt;/SafeAreaView&gt;  );}const styles = StyleSheet.create({});export default AuthHomeScreen;  SafeAreaView : 핸드폰 기기에서 최상단 시계있는 부분등 사용하면 겹치는 부분을 제외하고 화면에 그릴 수 있도록 영역 지정하는 기능  View : 리액트에서 html의 div태그와 비슷한 기능을하는 View가 있다고 생각할 수 있다로그인화면인 LoginScreen 코드 작성[matzip/front/src/screens/LoginScreen.tsx] 파일을 작성한다해당 파일은 로그인화면으로 사용자가 로그인을 하기 위해 표시되는 로그인 페이지이다해당 페이지에서는 임시로 페이지만 작성해두고 다음에 버튼 기능등을 추가하도록 한다import React from 'react';import {StyleSheet, Text, View} from 'react-native';function LoginScreen() {  return (    &lt;View&gt;      &lt;Text&gt;로그인 스크린&lt;/Text&gt;    &lt;/View&gt;  );}const styles = StyleSheet.create({});export default LoginScreen;"
  },
  
  {
    "title": "맛집 앱 만들기 프로젝트 Part1 프로젝트 설치 및 기본설정",
    "url": "/posts/rn_project_matzip01/",
    "categories": "Project, ReatNative",
    "tags": "ReatNative",
    "date": "2024-04-15 12:33:00 +0900",
    





    
    "snippet": "프로젝트 설명맛집을 기록하고 기록한 내용을 공유하는 앱을 만드는 프로젝트이다그럼 프로젝트를 생성해보도록한다 프로젝트의 구조를 먼저 구상해보자      front          App.tsx      src                  navigation                          AuthStackNavigator.tsx      ...",
    "content": "프로젝트 설명맛집을 기록하고 기록한 내용을 공유하는 앱을 만드는 프로젝트이다그럼 프로젝트를 생성해보도록한다 프로젝트의 구조를 먼저 구상해보자      front          App.tsx      src                  navigation                          AuthStackNavigator.tsx                                screens                          AuthHomeScreen.ts              LoginScreen.tsx                                          ReactNative에 필요한 환경 준비하기설치 및 적용 방법 : 👉🏻리액트네이티브 기본환경구성 여기를 참고하여 하기 프로그램을 설치 및 환경설정 준비를하도록하자  Chocolatey  Nodejs  Python  React Native CLI  JDK  안드로이드 스튜디오프로젝트 만들기(1) RN프로젝트 생성npx react-native@latest init matzipApp(2) 만들어진 프로젝트로 이동후 실행npx react-native run-androidvscode 확장패키지[react의 기본 컴포넌트 구성 기본 코드를 만들어주는 확장플러그인 사용법은 srnf 를 입력후 엔터]  simple-front-snippets[javascript 및 typescript 등 코드를 자동 정렬해주는 기능의 확장플러그인 설치 및 적용 방법 : 👉🏻Prittier]  Prittier필요 패키지 설치[상단바 부분과 하단바 부분의 사용을 위해 navigation 패키지를 설치 ]  npm install @react-navigation/native  npm install react-native-screens react-native-safe-area-context[각 페이지(스크린)으로 이동하기 위해 Stack Navigator를 설치]  npm install @react-navigation/stack  npm install react-native-gesture-handler  npm install @react-native-masked-view/masked-view추가 설정  [android/app/src/main/java/MainActivity.java 또는 MainActivity.kt 파일 최하단에 아래 코드 추가]  override fun onCreate(savedInstanceState: Bundle?) {    super.onCreate(null)  }  [android/app/src/main/java/MainActivity.java 또는 MainActivity.kt 파일 상단에 하기 import 구문 추가]  import android.os.Bundle;  [index.js 파일에 하기 import 하기]  import 'react-native-gesture-handler';"
  },
  
  {
    "title": "Typescript as const 효과적인 상수관리",
    "url": "/posts/typescript04/",
    "categories": "Develop, Typescript",
    "tags": "Typescript",
    "date": "2024-04-02 12:33:00 +0900",
    





    
    "snippet": "리터럴 타입(readonly)과 프리미티브 타입타입스크립트에서는 string, number 등과 같이 포괄적인 타입에도 명확한 값(리터럴 타입)을 설정하는것이 가능하다예를들어 아래와 같이 name을 let으로 선언했을경우 string타입이라는 포괄적인 의미를 가지고있는 primitive type을 갖는다let name = '홍길동';console.lo...",
    "content": "리터럴 타입(readonly)과 프리미티브 타입타입스크립트에서는 string, number 등과 같이 포괄적인 타입에도 명확한 값(리터럴 타입)을 설정하는것이 가능하다예를들어 아래와 같이 name을 let으로 선언했을경우 string타입이라는 포괄적인 의미를 가지고있는 primitive type을 갖는다let name = '홍길동';console.log(typeof(name)); // string 타입으로 출력하지만 아래와 같이 let으로 선언했는데도 불구하고 as const 키워드를 사용하면 정확한 값을 타입으로 갖는 리터럴 타입(readonly)을 갖게할 수 있다 아래 코드를 보면 let으로 name만 선언했을경우 추론적인 string타입이었겠지만 as const키워드를 붙였기때문에 name에는 정확한 값인 홍길동의 값만 갖을 수 있다let name = '홍길동' as const;name = \"이순신\" // error Type '이순신' is not assignable to type '홍길동'객체에서의 상수 관리아래 코드와 같이 Colors라는 각 컬러 데이터를 담은 객체 변수를 만들었을때를 예를들어보자해당 객체의 각 속성(red,blue,green)의 추론된 값을 보면 리터럴 타입(readonly)이 아닌 프리미티브 타입으로 추론된 것을 알 수 있다그 이유는 객체는 언제든 객체 내부의 값들을 바꿀 수 있기 때문이다.const Colors = {       red: \"#FF0000\",       blue: \"#0000FF\",       green: \"#008000\", }그럼 어떻게해야 속성들도 값을 고정해버리는 강력한 리터럴 타입으로 지정할 수 있을까?바로 위에서 배운 as const 키워드를 아래 코드처럼 동일하게 사용하면 된다const Colors = {       red: \"#FF0000\",       blue: \"#0000FF\",       green: \"#008000\", } as const;"
  },
  
  {
    "title": "Typescript 인터페이스(Interface)",
    "url": "/posts/typescript03/",
    "categories": "Develop, Typescript",
    "tags": "Typescript",
    "date": "2024-04-02 12:33:00 +0900",
    





    
    "snippet": "Typescript 인터페이스인터페이스는 상호 간에 정의한 약속 혹은 규칙을 의미한다.타입스크립트에서의 인터페이스는 보통 다음과 같은 범주에 대해 약속을 정의할 수 있다  객체의 스펙(속성과 속성의 타입)  함수의 파라미터  함수의 스펙(파라미터 타입, 반환 타입 등)  배열과 객체를 접근하는 방식  클래스인터페이스 사용해보기먼저 인터페이스를 사용하지...",
    "content": "Typescript 인터페이스인터페이스는 상호 간에 정의한 약속 혹은 규칙을 의미한다.타입스크립트에서의 인터페이스는 보통 다음과 같은 범주에 대해 약속을 정의할 수 있다  객체의 스펙(속성과 속성의 타입)  함수의 파라미터  함수의 스펙(파라미터 타입, 반환 타입 등)  배열과 객체를 접근하는 방식  클래스인터페이스 사용해보기먼저 인터페이스를 사용하지 않은 경우와 해당 코드를 인터페이스로 정의한 코드로 예를 들어보자//함수에 전달할 24살 홍길동이라는 person객체를 만들었다const person = {    name : '홍길동',    age : 24}// obj라는 매개변수로 받고 해당 매개변수의 속성중 age라는 특정 속성의 타입이 number지정되어있다function helloMsg(obj: {age: number}){    console.log(obj.age);}// 맨위에서 만든 홍길동 객체를 helloMsg 전달하여 호출한다helloMsg(person)대표적인 데이터 타입들을 알아보자      String : 자바스크립트 변수의 타입이 문자열인 경우 하기 코드와 같이 선언한다    let name: string = \"bts\"; // 문자열의 값을 갖는다            Number:  자바스크립트 변수의 타입이 숫자인 경우 하기 코드와 같이 선언한다    let count: number = 5; // 정수중 값을 갖는다            Boolean:  자바스크립트 변수의 타입이 진위값인 경우 하기 코드와 같이 선언한다    let isLoggedIn: boolean = true; // true, false 중 값을 갖는다            Array:  자바스크립트 변수의 타입이 배열인 경우 하기 코드와 같이 선언한다    let arr: number[] = [1,2,3];            Tuple:  자바스크립트 변수의 타입이 배열이며 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열인 경우 하기 코드와 같이 선언한다    let arr: [string, number] = ['bts', 14];            Any:  기존에 자바스크립트로 구현되어 있는 웹 서비스 코드에 타입스크립트를 점진적으로 적용할 때 활용하면 좋은 타입, 단어 의미 그대로 모든 타입에 대해서 허용한다    let str: any = 'hi';let num: any = 10;let arr: any = ['a', 2, true];            Void:  반환 값이 없는 함수의 반환 타입, 아래와 같이 return이 없거나 return이 있더라도 반환하는 값이 없으면 함수의 반환 타입을 void로 지정한다    function printSomething(): void {  console.log('sth');}  function returnNothing(): void {  return;}      Typescript 함수[함수 기본타입] 기존의 자바스크립트에 타입만 추가되는 형태로 아래와 같다// a와 b라는 파라미터를 받으며 해당 파라미터는 number 데이터 타입만 들어올 수 있다// 리턴값 역시 타입이 number로 리턴하는 값은 number 데이터 타입이어야한다function sum(a: number, b: number): number {  return a + b;}  타입스크립트는 함수의 파라미터를 모두 필수 값으로 간주한다  따라서 기본적으로 함수의 매개변수를 설정하면 undefined, null 타입이라도 파라미터로 넘겨야하며 컴파일러에서 정의된 매개변수 값이 넘어 왔는지 확인한다  매개변수는 존재하지만 안넘기고 싶은 파라미터라면 아래와 같이 ? 키워드를 사용할 수 있다  function sum(a: number, b?: number): number {  return a + b;}sum(10, 20); // 30sum(10, 20, 30); // error, too many parameterssum(10); // 타입 에러 없음  [ES6 Rest문법이 적용된 함수]Rest문법을 모른다면 👉🏻ES6 공식DOC 에서 자바스크립트의 Rest문법을 참고하자  function sum(a: number, ...nums: number[]): number {    const totalOfNums = 0;    for (let key in nums) {      totalOfNums += nums[key];    }    return a + totalOfNums;  }"
  },
  
  {
    "title": "Typescript 문법",
    "url": "/posts/typescript02/",
    "categories": "Develop, Typescript",
    "tags": "Typescript",
    "date": "2024-04-02 12:33:00 +0900",
    





    
    "snippet": "Typescript 데이터 타입타입스크립트로 변수나 함수와 같은 자바스크립트 코드에 타입을 정의할 수 있다대표적인 데이터 타입들을 알아보자      String : 자바스크립트 변수의 타입이 문자열인 경우 하기 코드와 같이 선언한다    let name: string = \"bts\"; // 문자열의 값을 갖는다            Number:  자바스...",
    "content": "Typescript 데이터 타입타입스크립트로 변수나 함수와 같은 자바스크립트 코드에 타입을 정의할 수 있다대표적인 데이터 타입들을 알아보자      String : 자바스크립트 변수의 타입이 문자열인 경우 하기 코드와 같이 선언한다    let name: string = \"bts\"; // 문자열의 값을 갖는다            Number:  자바스크립트 변수의 타입이 숫자인 경우 하기 코드와 같이 선언한다    let count: number = 5; // 정수중 값을 갖는다            Boolean:  자바스크립트 변수의 타입이 진위값인 경우 하기 코드와 같이 선언한다    let isLoggedIn: boolean = true; // true, false 중 값을 갖는다            Array:  자바스크립트 변수의 타입이 배열인 경우 하기 코드와 같이 선언한다    let arr: number[] = [1,2,3];            Tuple:  자바스크립트 변수의 타입이 배열이며 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열인 경우 하기 코드와 같이 선언한다    let arr: [string, number] = ['bts', 14];            Any:  기존에 자바스크립트로 구현되어 있는 웹 서비스 코드에 타입스크립트를 점진적으로 적용할 때 활용하면 좋은 타입, 단어 의미 그대로 모든 타입에 대해서 허용한다    let str: any = 'hi';let num: any = 10;let arr: any = ['a', 2, true];            Void:  반환 값이 없는 함수의 반환 타입, 아래와 같이 return이 없거나 return이 있더라도 반환하는 값이 없으면 함수의 반환 타입을 void로 지정한다    function printSomething(): void {  console.log('sth');}  function returnNothing(): void {  return;}      Typescript 함수[함수 기본타입] 기존의 자바스크립트에 타입만 추가되는 형태로 아래와 같다// a와 b라는 파라미터를 받으며 해당 파라미터는 number 데이터 타입만 들어올 수 있다// 리턴값 역시 타입이 number로 리턴하는 값은 number 데이터 타입이어야한다function sum(a: number, b: number): number {  return a + b;}  타입스크립트는 함수의 파라미터를 모두 필수 값으로 간주한다  따라서 기본적으로 함수의 매개변수를 설정하면 undefined, null 타입이라도 파라미터로 넘겨야하며 컴파일러에서 정의된 매개변수 값이 넘어 왔는지 확인한다  매개변수는 존재하지만 안넘기고 싶은 파라미터라면 아래와 같이 ? 키워드를 사용할 수 있다  function sum(a: number, b?: number): number {  return a + b;}sum(10, 20); // 30sum(10, 20, 30); // error, too many parameterssum(10); // 타입 에러 없음  [ES6 Rest문법이 적용된 함수]Rest문법을 모른다면 👉🏻ES6 공식DOC 에서 자바스크립트의 Rest문법을 참고하자  function sum(a: number, ...nums: number[]): number {    const totalOfNums = 0;    for (let key in nums) {      totalOfNums += nums[key];    }    return a + totalOfNums;  }"
  },
  
  {
    "title": "Javascript 구조 분해 할당",
    "url": "/posts/javascript_01/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-04-02 12:33:00 +0900",
    





    
    "snippet": "구조 분해 할당이란객체와 배열은 자바스크립트에서 가장 많이 쓰이는 자료 구조이다키를 가진 데이터 여러 개를 하나로 사용할 때 객체를, 각 컬렉션에 데이터를 순서대로 저장할 땐 배열을 사용한다그러다보니 함수에 객체나 배열을 전달해야 하는 경우가 생긴다 또한 객체나 배열에 저장된 데이터 전체가 아닌 일부만 전달이 필요한 경우가 생기기도 한다.먼저 사용해보...",
    "content": "구조 분해 할당이란객체와 배열은 자바스크립트에서 가장 많이 쓰이는 자료 구조이다키를 가진 데이터 여러 개를 하나로 사용할 때 객체를, 각 컬렉션에 데이터를 순서대로 저장할 땐 배열을 사용한다그러다보니 함수에 객체나 배열을 전달해야 하는 경우가 생긴다 또한 객체나 배열에 저장된 데이터 전체가 아닌 일부만 전달이 필요한 경우가 생기기도 한다.먼저 사용해보면서 이해해보도록 하자[배열 분해하기]배열의 요소를 다른곳에 저장 혹은 사용하기 위해서는 해당 배열의 요소를 인덱스로 접근하였지만,분해 할당을 통해 인덱스 없이도 각 요소에 접근이 가능하다// 이름과 성을 요소로 가진 배열let arr = [\"Bora\", \"Lee\"]// 구조 분해 할당을 이용해// firstName엔 arr[0]을 surname엔 arr[1]을 할당let [firstName, surname] = arr;alert(firstName); // Boraalert(surname);  // Lee특정 요소는 필요하지 않을 때 하기 코드 처럼 쉼표를 사용하여 해당 요소를 무시할 수도 있다// 두 번째 요소는 필요하지 않음let [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];alert( title ); // Consul[객체 분해하기]구조 분해 할당으로 객체도 분해할 수 있다.let options = {  title: \"Menu\",  width: 100,  height: 200};let {title, width, height} = options;alert(title);  // Menualert(width);  // 100alert(height); // 200"
  },
  
  {
    "title": "Javascript 함수의 Call & Apply & Bind",
    "url": "/posts/javascript_call_apply_bind/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-04-02 12:33:00 +0900",
    





    
    "snippet": "Call 함수란먼저 Call을 사용하기전에 왜 사용하는지를 알아보자모든 함수는 실행할때 함수 앞에 작성한 오브젝트를 this로 참조한다 하기 코드를 보자위 코드처럼 현재 함수를 실행하는곳이 어느 위치(오브젝트)냐가 즉 this가 되고 this에 따라 함수 결과값이 달라진다그럼 어떻게 해야 데이터 중심적인 결과를 도출할 수 있을까?바로 모든 Javasc...",
    "content": "Call 함수란먼저 Call을 사용하기전에 왜 사용하는지를 알아보자모든 함수는 실행할때 함수 앞에 작성한 오브젝트를 this로 참조한다 하기 코드를 보자위 코드처럼 현재 함수를 실행하는곳이 어느 위치(오브젝트)냐가 즉 this가 되고 this에 따라 함수 결과값이 달라진다그럼 어떻게 해야 데이터 중심적인 결과를 도출할 수 있을까?바로 모든 Javascript 함수에 내장되어있는 Call함수를 사용하면 된다.위에 코드를 Call함수를 사용하여 정상적인 결과를 만들어보자Call 함수를 사용하여 현재 this가 hello라는 객체라고 알려주어 messg라는 값을 잘 출력하는것을 볼 수 있다.Call 함수 사용법은 func.call(thisArg[, arg1[, arg2[, ...]]]) 로 사용하면 된다Apply 함수란apply()는 위에서 배운 Call()과 동일하지만 뒤에 받는 함수의 파라미터가 배열인 경우에 사용된다var korea = {    name: \"한국\",    age: 100};var us = {    name: \"미국\",    age: 80};function updateName(name, age){    this.name=name;    this.age=age;}// 첫번째 인수인 this를 korea객체로 주어서 오브젝트를 지정하고 두번째 인수를 배열로주었다// 배열이 아니었으면 위에서 배운 call을 사용할 수 있지만 인자가 배열이기 때문에 apply를 사용한다updateName.apply(korea, [\"대한민국\",150]); // 결과 값이 name: 대한민국, age: 150 잘나오는것을 확인할 수 있다console.log(korea);만약 call로 배열 인자를 처리하고 싶다면 ES6문법인 Spread 문법을 사용할 수 있다하기 코드는 위 코드 apply에서 call로 변경한 코드이다var korea = {    name: \"한국\",    age: 100};var us = {    name: \"미국\",    age: 80};function updateName(name, age){    this.name=name;    this.age=age;}const updateData = [\"대한민국\", 150];// 첫번째 인수인 this를 korea객체로 주어서 오브젝트를 지정하고 두번째 인수는 위에 배열 변수를 만든 후 // Spread문법으로 나열하였다// call로도 배열을 처리할 수 있다updateName.call(korea, ...updateData); // 결과 값이 name: 대한민국, age: 150 잘나오는것을 확인할 수 있다console.log(korea);Bind 함수란Bind 키워드를 사용하면 this의 값을 영구적으로 바꿀 수 있다var korea = {    name: \"한국\",    age: 100};var us = {    name: \"미국\",    age: 80};function updateName(name, age){    this.name=name;    this.age=age;}// bind 키워드를 사용하여 updateKorea함수를 사용하면 항상 this가 korea이게 만들 수 있다const updateKorea = updateName.bind(korea);// call이나 apply를 사용하지 않아도 updateKorea가 this를 korea로 갖고있기 때문에 // 바로 파라미터만 전달하여 업데이트할 수 있다updateKorea(\"대한민국\", 150); // 결과 값이 name: 대한민국, age: 150 잘나오는것을 확인할 수 있다console.log(korea);"
  },
  
  {
    "title": "Javascript Map함수",
    "url": "/posts/javascript_map/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-04-02 12:33:00 +0900",
    





    
    "snippet": "Map 함수란Map함수는  콜백 함수를 이용해 각각의 요소에 호출해서 그 값을 변환할 수 있게 해준다. 다시 말하자면 콜백 함수는 배열의 각 요소에 실행된다예를들어 간단한 예제 코드를 보도록한다먼저 다음과 같은 배열 요소가 있다고 가정해본다[단순한 Javascript 배열]  //배열 arr을 만들고 1~5 까지 숫자를 넣어둔다   const arr ...",
    "content": "Map 함수란Map함수는  콜백 함수를 이용해 각각의 요소에 호출해서 그 값을 변환할 수 있게 해준다. 다시 말하자면 콜백 함수는 배열의 각 요소에 실행된다예를들어 간단한 예제 코드를 보도록한다먼저 다음과 같은 배열 요소가 있다고 가정해본다[단순한 Javascript 배열]  //배열 arr을 만들고 1~5 까지 숫자를 넣어둔다   const arr = [1, 2, 3, 4, 5];해당 배열의 각 요소에 10을 곱해야 한다고 생각해보자 그럼 아래와 같이 for문이 제일 먼저 떠오를 수 있다[for문을 사용한 배열 요소 처리]  let arr = [1, 2, 3, 4, 5];    for (let i = 0; i &lt; arr.length; i++){    arr[i] = arr[i] * 10;  }    console.log(arr); // [10, 20, 30, 40, 50]하지만 Array.map() 함수를 사용하면 더욱 간결한 코드로 동일 결과 값을 얻을 수 있다 하기 코드처럼[Array.map 함수를 사용한 배열 요소 처리]  let arr = [1, 2, 3, 4, 5];    let modifiedArr = arr.map(function(element){      return element *10;  });    console.log(modifiedArr); // [10, 20, 30, 40, 50]다른도 보면서 어떤 상황일때 편하게 Map함수를 사용할 수 있는지 보도록 한다[Array.map 함수를 사용한 객체 배열 요소 처리]  let users = [    {firstName : \"Susan\", lastName: \"Steward\"},    {firstName : \"Daniel\", lastName: \"Longbottom\"},    {firstName : \"Jacob\", lastName: \"Black\"}  ];    let userFullnames = users.map(function(element){      return `${element.firstName} ${element.lastName}`;  })    console.log(userFullnames);  // [\"Susan Steward\", \"Daniel Longbottom\", \"Jacob Black\"]"
  },
  
  {
    "title": "Typescript 개요",
    "url": "/posts/typescript01/",
    "categories": "Develop, Typescript",
    "tags": "Typescript",
    "date": "2024-04-01 12:33:00 +0900",
    





    
    "snippet": "Typescript개요  타입스크립트는 자바스크립트의 슈퍼셋인 오픈소스 프로그래밍 언어이다. 마이크로소프트에서 개발, 유지하고 있으며 엄격한 문법을 지원한다. C#의 리드 아키텍트이자 델파이, 터보 파스칼의 창시자인 Anders Hejlsberg가 개발에 참여한다. 클라이언트 사이드와 서버 사이드를 위한 개발에 사용할 수 있다. 타입스크립트는 자바스크...",
    "content": "Typescript개요  타입스크립트는 자바스크립트의 슈퍼셋인 오픈소스 프로그래밍 언어이다. 마이크로소프트에서 개발, 유지하고 있으며 엄격한 문법을 지원한다. C#의 리드 아키텍트이자 델파이, 터보 파스칼의 창시자인 Anders Hejlsberg가 개발에 참여한다. 클라이언트 사이드와 서버 사이드를 위한 개발에 사용할 수 있다. 타입스크립트는 자바스크립트 엔진을 사용하면서 커다란 애플리케이션을 개발할 수 있게 설계된 언어이다.자바스크립트의 슈퍼셋이기 때문에 자바스크립트로 작성된 프로그램이 타입스크립트 프로그램으로도 동작한다. 타입스크립트에서 자신이 원하는 타입을 정의하고 프로그래밍을 하면 자바스크립트로 컴파일되어 실행할 수 있다. 타입스크립트는 모든 운영 체제, 모든 브라우저, 모든 호스트에서 사용 가능한 오픈 소스이다.  -위키 백과 -위의 위키내용과 같이 타입스크립트는 자바스크립트와 다른점이 많지 않다자바스크립트의 모든 단점을 보완하여 만든 언어이며 동적인 자바스크립트 언어에 타입을 미리 부여함으로써 컴파일 시 에러를 잡을 수 있다.Javascript와 Typescript의 차이(1) 자바스크립트 언어는 동적 타입 언어로 변수의 타입이 런타임 즉 실행 시간에 결정된다(2) 타입스크립트 언어는 정적 타입 언어로 변수의 타입이 컴파일 단계에서 타입 체크를 진행한다Typescript의 장점타입스크립트를 사용해야하는 가장 큰 이유로 자바스크립트의 단점을 이해 해야 한다자바스크립트는 클래스 기반 객체지향 언어로 유연성이 뛰어나다 장점으로는 자유도가 높으나 단점으로는 코드가 복잡해질 수 있고 디버그가 증가하는 문제를 일으킨다.  타입스크립트는 정적 타입 언어로 컴파일 단계에서 오류를 포착하여 사전에 에러를 잡을 수 있고 명시적인 정적 타입의 지정은 개발자의 의도를 명확하게 코드로 기술할 수 있게 한다 이는 코드의 가독성을 높이고 컴파일 시 안정적이고 예측할 수 있게 하며 디버깅을 쉽게할 수 있다  타입스크립트는 높은 생산성을 자랑한다. 자바스크립트의 경우 코드를 작성할 때, 객체의 필드 또는 함수, 매개변수등으로 들어오는 값이 무엇인지 알기 위해 시간을 소모했지만 타입스크립트는 변수 이름뿐만 아니라 그 데이터의 자료형까지 알 수 있게되어 소모 시간을 줄여준다 즉 생산성을 높인다Typescript의 단점  타입스크립트는 초기 설정이 어렵다, 타입스크립트는 독자적인 언어가 아니므로 기존에 존재하는 자바스크립트 엔진에서 실행된다 즉 타입스크립트언어로 코드를 작성하여도 컴파일시 자바스크립트언어로 컴파일된다  타입스크립트의 장점인 타입지정 규칙으로 때로는 생산성이 떨어지기도 한다. 매번 변수등 타입을 개발자가 직접 지정해야하므로 생산성이 저하되는 경우가 발생한다."
  },
  
  {
    "title": "vue 입문 Level01",
    "url": "/posts/vue_level01/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-03-04 12:33:00 +0900",
    





    
    "snippet": "vue의 기본 구조SPA와 RouterVue 기반 애플리케이션은 흔히 SPA(Single Page Application, 한 화면으로 구성된 애플리케이션을 말한다)로 구성되는데, 이때 한 페이지 내에서도 다른 페이지로 이동할 필요 없이 마치 여러 개의 페이지가 있는 듯한 방식으로 작동하게 해 주는 것이 바로 Vue Router이다.이는 보통 사이트의 ...",
    "content": "vue의 기본 구조SPA와 RouterVue 기반 애플리케이션은 흔히 SPA(Single Page Application, 한 화면으로 구성된 애플리케이션을 말한다)로 구성되는데, 이때 한 페이지 내에서도 다른 페이지로 이동할 필요 없이 마치 여러 개의 페이지가 있는 듯한 방식으로 작동하게 해 주는 것이 바로 Vue Router이다.이는 보통 사이트의 큰 틀 안에 &lt;router-view&gt; 태그를 삽입하고, 라우터가 보여 줄 컴포넌트를 이 태그 안에 렌더링한다. 라우터가 보여 줄 컴포넌트는 &lt;router-link&gt;의 클릭이나 JS 함수 호출 등으로 변경할 수 있다.간단한 예를 들어보자면 블로그를 만들 때 MainPage 컴포넌트와 Profile 컴포넌트, Posts 컴포넌트를 만든 후, 각각 컴포넌트로의 링크를 담은 &lt;router-link&gt;를 내비게이션 바에 넣어 놓고, 그 아래에 &lt;router-view&gt;를 놓으면 내비게이션 바에서 링크를 누르는 대로 보여지는 컴포넌트가 바뀌면서 마치 일반적인 여러 페이지로 구성된 블로그와 같이 작동하게 된다.하지만 실제로는 페이지를 이동하지 않기 때문에 로딩 시간도 훨씬 적고, 화면이 사라졌다 다시 나타나는 지저분한 효과 없이 즉시 화면이 전환된다. 원한다면 애니메이션을 넣는 것도 가능하다상태 관리Vue 컴포넌트들 간의 데이터 공유를 도와주는 라이브러리들이다.Vue기능만으로 컴포넌트 간에 데이터를 공유하려면 상위 컴포넌트에서 하위 컴포넌트로 Property를 넘기거나, 하위에서 상위 컴포넌트로 이벤트를 송신하는 방법이 있는데,이 방식을 사용하면 해당 컴포넌트에서 멀리 떨어진 컴포넌트까지 데이터를 공유하려고 할 때 상당히 골치가 아파진다. 그래서 아래와 같은 라이브러리가 개발되어 데이터 공유및 상태 저장을 간결하고 쉽게 만들 수 있게 되었다.      vuex : 예전에 사용되던 라이브러리. Vuex는 중앙화된 Store 안에 state를 통해 애플리케이션의 상태를 관리힌다. 중앙화된 store 속 데이터는 컴포넌트 어디서나 자유롭게 읽을 수 있으며, Store 안에 등록할 수 있는 동기적 함수인 Mutation을 통해 데이터를 변경할 수 있다. Vuex를 사용함으로써 얻을 수 있는 편의성이 매우 크기에, 좀 규모가 되는 Vue 애플리케이션을 작성할 때 없어서는 안 되는 물건이었으나 Pinia로 대체되고 있다.    pinia : 기존 사용되더누아리의 Vuex를 대체하는 신규 라이브러리. 상대적으로 간결한 문법과 뛰어난 TypeScript 지원을 내세운 Pinia가 등장하여 공식적으로 권장되는 상태 관리 라이브러리로 지정되었고, 예전의Vuex는 유지보수 단계에 진입한 상태이다. 따라서 신규 프로젝트 개발 시에는 Pinia의 사용이 권장된다  vue 기본 구조"
  },
  
  {
    "title": "Javascript Spread와 Rest Parameters",
    "url": "/posts/javascript_spread_rest/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-02-25 12:33:00 +0900",
    





    
    "snippet": "Spread Operator전개 연산자는 ES6이후부터 사용할 수 있는 문법으로 배열 또는 객체를 하나하나 넘기는 용도로 사용된다배열, 문자열과 같은 반복 가능한(iterable) 요소 앞에 사용해서 배열의 개별 요소를 다른 배열이나 함수의 인자로 펼쳐서 넘기는게 가능하다 객체에 대해 전개 연산자를 사용하면 객체의 속성을 넘기는 것도 가능하며 배열 복...",
    "content": "Spread Operator전개 연산자는 ES6이후부터 사용할 수 있는 문법으로 배열 또는 객체를 하나하나 넘기는 용도로 사용된다배열, 문자열과 같은 반복 가능한(iterable) 요소 앞에 사용해서 배열의 개별 요소를 다른 배열이나 함수의 인자로 펼쳐서 넘기는게 가능하다 객체에 대해 전개 연산자를 사용하면 객체의 속성을 넘기는 것도 가능하며 배열 복사라고도 부른다사용방법은 전개하고자하는 배열 앞에 ... 기호를 붙인다여러 예제를 통해 사용법을 익혀보자(1)배열 전개 연산자  const fruits = ['사과', '바나나', '망고'];  const newFruits = ['포도', ...fruits];    console.log(fruits); // 결과 : ['사과', '바나나', '망고']  console.log(newFruits); // 결과 :['포도', '사과', '바나나', '망고'](2) 객체 전개 연산자   const person = {       name: '홍길동',       age: 20,       city: \"서울\"   }   // person 객체를 전개연산자로 객체복사를하고 job을 추가하여 newPerson을 만든다   const newPerson = {...person, job: '개발자'};      console.log(person); // 결과 : {name: '홍길동', age: 20, city: '서울'}   console.log(newPerson); // 결과 : {name: '홍길동', age: 20, city: '서울', job : '개발자'}(3) 문자열 전개 연산자  const msg = \"Hello\";  const newMsg = '${msg} I am Javascript';    console.log(msg); // 결과 : Hello  cosnole.log(newMsg); // 결과 : Hello I am Javascript Rest ParametersRest Parameters는 위의 스프레드 연산자와 사용방법은 동일하다차이점은 스프레드 연산자의 경우 객체, 배열 복사등에 사용하지만 Rest의 경우 함수의 파라미터로 사용된다Rest Parameter도 예제를 보면서 사용법을 익혀보자(1) Rest 파라미터만 함수에 전달하는 경우function addFun(a, b, c){  console.log(a, b, c);}const numbers = [1, 2, 3];addFun(numbers); // 결과 : [1, 2, 3] undefined undefinedaddFun(numbers[0], numbers[1], numbers[2]); // 결과 :  1 2 3addFun(...numbers); // 결과 : 1 2 3(2) Rest 파라미터외에 여러 파라미터를 함수에 전달하는 경우  const numbers = [1, 2, 3];    function addFun(a, b, c, d, e, f){    console.log(a, b, c, d, e, f);  }    addFun(...numbers, 10, ...numbers);  // 결과 : 1 2 3 10 1 2"
  },
  
  {
    "title": "IntelliJ Springboot 한글 인코딩",
    "url": "/posts/IntelliJspring_encoding/",
    "categories": "Utils, IntelliJ",
    "tags": "IntelliJ",
    "date": "2024-02-15 12:33:00 +0900",
    





    
    "snippet": "문제  IntelliJ에서 Springboot를 작업하다보면 콘솔에 하기 그림과 같이 한글이 깨져 출력되는 경우  API호출에 따른 Response에서 한글이 깨져서 응답되는경우해결방법Step01 IntelliJ설정 변경하기 사진과 같이메뉴 -&gt; Settings -&gt; File Encodings -&gt; 모두 UTF-8로 변경 후 저장Ste...",
    "content": "문제  IntelliJ에서 Springboot를 작업하다보면 콘솔에 하기 그림과 같이 한글이 깨져 출력되는 경우  API호출에 따른 Response에서 한글이 깨져서 응답되는경우해결방법Step01 IntelliJ설정 변경하기 사진과 같이메뉴 -&gt; Settings -&gt; File Encodings -&gt; 모두 UTF-8로 변경 후 저장Step02 VM Options 변경메뉴 -&gt; Help -&gt; Edit Custom VM Options 를 클릭하여 설정파일을 열고 최하단에 하기 사진과 같이 2개의 내용 추가-Dfile.encoding=UTF-8-Dconsole.encoding=UTF-8Step03 Gradle Rebuild화면 맨 오른편에 Gradle 메뉴를 선택하여 하기 그림과 같이 순서대로 Rebuild를 진행한다우측 Gradle메뉴 -&gt; Tasks -&gt; build -&gt; clean우측 Gradle메뉴 -&gt; Tasks -&gt; build -&gt; buildStep04 프로젝트 재시작해당 프로젝트를 재구동하여 한글이 정상 출력되는지 확인한다"
  },
  
  {
    "title": "Vue vite란",
    "url": "/posts/vue_vite/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-02-07 12:33:00 +0900",
    





    
    "snippet": "vite(비트)란?비트는 자바스크립트 네이티브 모듈 (opens new window)을 기반으로 한 데브 서버이다, 이미 현대 프런트엔드 개발 생태계는 웹팩을 중심으로 개발 환경과 배포 시스템이 구축되어 있다 그런데 왜 비트와 같은 도구들이 나왔을까? 그 이유는 웹팩을 사용할 때보다 훨씬 더 빠르게 개발하고 배포할 수 있기 때문이다 왜 빠른지 이해하기...",
    "content": "vite(비트)란?비트는 자바스크립트 네이티브 모듈 (opens new window)을 기반으로 한 데브 서버이다, 이미 현대 프런트엔드 개발 생태계는 웹팩을 중심으로 개발 환경과 배포 시스템이 구축되어 있다 그런데 왜 비트와 같은 도구들이 나왔을까? 그 이유는 웹팩을 사용할 때보다 훨씬 더 빠르게 개발하고 배포할 수 있기 때문이다 왜 빠른지 이해하기 위해서는 먼저 번들링과 자바스크립트 네이티브 모듈을 이해해야 한다번들링이란?브라우저에서 ESM(ES Modules)을 지원하기 전까지는 자바스크립트 모듈화를 네이티브 레벨에서 진행할 수 없었다. 따라서 개발자들은 웹팩, Rollup, Parcel과 같은 도구를 이용하여 번들링(Bundling)이라는 우회적인 방법을 사용해야 했다[ESM이란]      ESM : 모듈화 문법인 import, export를 별도의 도구 없이 브라우저 자체에서 소화해 낼 수 있는 모듈 방식을 의미한다 만약 아래와 같은 코드를 웹팩과 같은 번들러 없이 브라우저에서 실행하면 에러가 발생한다      // app.jsimport { sum } from './math.js';console.log(sum(10, 20));&lt;script src=\"./app.js\"&gt;&lt;/script&gt;            하지만, 이제는 script 태그에 아래와 같이 type=”module” 속성을 추가하면 정상 동작하는 것을 볼 수 있다      &lt;script type=\"module\" src=\"./app.js\"&gt;&lt;/script&gt;            이렇게 브라우저에서 import와 export를 소화할 수 있는 능력이 바로 ESM이다      Vite의 특징비트는 로컬에서 개발할 때 번들링을 하지 않고 ESM 방식을 사용하기 때문에 로컬 서버 구동 속도가 매우 빠르다 500개 정도 되는 모듈을 갖고 있는 웹 서비스를 웹팩 데브 서버 (opens new window)와 비트로 비교해 본다면 실행 시간이 20 ~ 30배 이상 차이가 난다. 웹팩 데브 서버는 처음 로컬 서버를 시작할 때 관련 있는 모듈들을 번들링 해서 메모리에 적재하는 시간이 필요하기 때문에 당연히 어느 정도의 시간이 필요하지만 비트는 번들링을 하지 않고 바로 서버를 실행하기 때문에 명령어를 실행함과 동시에 서버가 바로 구동된다"
  },
  
  {
    "title": "pinia란",
    "url": "/posts/vue_pinia/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-02-07 12:33:00 +0900",
    





    
    "snippet": "pinia란Pinia는 Composition API 기반에서 동작하는 상태 관리자이다여태까지 Vue에서 사용되던 가장 보편적이고 유명한 상태 관리자는 Vuex였습니다.그런데 Vue의 개발자, Even You는 본인의 트위터에서 Vuex 5와 Pinia는 사실상 완전 동일한 프로젝트로 생각해야 한다고 말한 바 있습니다.Vuex 5에서 원하던 기능들의 대...",
    "content": "pinia란Pinia는 Composition API 기반에서 동작하는 상태 관리자이다여태까지 Vue에서 사용되던 가장 보편적이고 유명한 상태 관리자는 Vuex였습니다.그런데 Vue의 개발자, Even You는 본인의 트위터에서 Vuex 5와 Pinia는 사실상 완전 동일한 프로젝트로 생각해야 한다고 말한 바 있습니다.Vuex 5에서 원하던 기능들의 대부분을 이미 Pinia에서 지원하고 있었기에, Vuex 프로젝트를 유지하는 대신 Pinia를 공식적으로 지원한다고 Pinia의 공식 문서에 적혀 있습니다.번들링이란?브라우저에서 ESM(ES Modules)을 지원하기 전까지는 자바스크립트 모듈화를 네이티브 레벨에서 진행할 수 없었다. 따라서 개발자들은 웹팩, Rollup, Parcel과 같은 도구를 이용하여 번들링(Bundling)이라는 우회적인 방법을 사용해야 했다[ESM이란]      ESM : 모듈화 문법인 import, export를 별도의 도구 없이 브라우저 자체에서 소화해 낼 수 있는 모듈 방식을 의미한다 만약 아래와 같은 코드를 웹팩과 같은 번들러 없이 브라우저에서 실행하면 에러가 발생한다      // app.jsimport { sum } from './math.js';console.log(sum(10, 20));&lt;script src=\"./app.js\"&gt;&lt;/script&gt;            하지만, 이제는 script 태그에 아래와 같이 type=”module” 속성을 추가하면 정상 동작하는 것을 볼 수 있다      &lt;script type=\"module\" src=\"./app.js\"&gt;&lt;/script&gt;            이렇게 브라우저에서 import와 export를 소화할 수 있는 능력이 바로 ESM이다      Vite의 특징비트는 로컬에서 개발할 때 번들링을 하지 않고 ESM 방식을 사용하기 때문에 로컬 서버 구동 속도가 매우 빠르다 500개 정도 되는 모듈을 갖고 있는 웹 서비스를 웹팩 데브 서버 (opens new window)와 비트로 비교해 본다면 실행 시간이 20 ~ 30배 이상 차이가 난다. 웹팩 데브 서버는 처음 로컬 서버를 시작할 때 관련 있는 모듈들을 번들링 해서 메모리에 적재하는 시간이 필요하기 때문에 당연히 어느 정도의 시간이 필요하지만 비트는 번들링을 하지 않고 바로 서버를 실행하기 때문에 명령어를 실행함과 동시에 서버가 바로 구동된다"
  },
  
  {
    "title": "LangChain이란",
    "url": "/posts/langchain/",
    "categories": "Develop, Python",
    "tags": "Python",
    "date": "2024-01-31 12:33:00 +0900",
    





    
    "snippet": "LangChain 이란LangChain을 알기위해선 먼저 LLM(대형 언어 모델)에 대해 알아야한다LLM은 방대한 양의 데이터를 기반으로 사전에 학습이 되어진 초대형 딥 러닝 모델이다  LM (언어 모델, Language Model) 이란, 인간의 언어를 이해하고 생성하도록 훈련된 일종의 인공지능 모델LNP vs LLMNLP는 인간의 언어를 이해하고 ...",
    "content": "LangChain 이란LangChain을 알기위해선 먼저 LLM(대형 언어 모델)에 대해 알아야한다LLM은 방대한 양의 데이터를 기반으로 사전에 학습이 되어진 초대형 딥 러닝 모델이다  LM (언어 모델, Language Model) 이란, 인간의 언어를 이해하고 생성하도록 훈련된 일종의 인공지능 모델LNP vs LLMNLP는 인간의 언어를 이해하고 처리하는 데 초점을 맞춘 인공지능 분야이며 컴퓨터가 자연어 텍스트를 이해하고 분석하는 기술을 개발하는 것을 목표로 한다 활용 분야는 “문장 구문 분석, 텍스트 분류, 기계 번역, 질의 응답 시스템, 감정 분석” 등과 같은 다양한 작업에 활용LLM은 LNP의 한 부분으로 그 안에서 특정한 접근 방식과 모델을 가리키는 한 가지 형태이다프로젝트 구성  Backend : SpringBoot  Frontend : Vue  IDE : Eclipse IDE  Database : MySQL필요한 프로그램 설치Eclipse 설치이클립스 설치 페이지[이클립스에서 Spring Boot 설치]메뉴 툴팁 =&gt; Help =&gt; Eclipse Marketplace 선택spring 으로 검색 =&gt; Spring Tools 4 (aka Spring Tool Suite 4) 설치"
  },
  
  {
    "title": "Vue Chap3",
    "url": "/posts/vue03/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-01-21 12:33:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Git(깃) 사용방법",
    "url": "/posts/usegit/",
    "categories": "Utils, Git",
    "tags": "Git",
    "date": "2024-01-20 12:33:00 +0900",
    





    
    "snippet": "Git은 무엇일까?      깃은 형상 관리 도구중 하나로 버전 관리 시스템이라고도 불린다    깃은 개발 소스코드를 효과적으로 관리할 수 있게 해주는 무료, 공개소프트웨어이다    분산형 관리 시스템이기에 같은 파일을 여러 명이 동시에 작업하는 병렬 개발이 가능하다  Github는 무엇일까?  깃은 형상을 관리할 수 있게 하는 버전 관리 도구라면 깃...",
    "content": "Git은 무엇일까?      깃은 형상 관리 도구중 하나로 버전 관리 시스템이라고도 불린다    깃은 개발 소스코드를 효과적으로 관리할 수 있게 해주는 무료, 공개소프트웨어이다    분산형 관리 시스템이기에 같은 파일을 여러 명이 동시에 작업하는 병렬 개발이 가능하다  Github는 무엇일까?  깃은 형상을 관리할 수 있게 하는 버전 관리 도구라면 깃허브는 해당 코드들을 저장하기 위해 사용되는 서버 즉 웹 호스팅 서비스이다Git 설치깃 설치 페이지 에서 설치를 진행한다쭉 진행하다 보면 컴포넌트 설정하는 부분이 나오는데 기본값을 사용해도 무방하며 필요에 따라서 선택하도록 한다 특별히 중요하게 다룰 옵션은 없어서 잘 모르겠다면 기본값을 사용하는 걸 추천에디터를 선택하는 창이 나오는데 Git에서 기본으로 사용할 에디터를 지정하는 단계로 Git에서 Commit등 메시지를 남길때 선택한 에디터 창을 열어준다저자는 VSC를 주로 사용하기에 해당 에디터를 선택하였다기본 브랜치 명을 선택하는 창이 나오는데 과거에는 기본 브랜치로 master를 많이 사용했지만 최근들어 main으로 변경하는 추세이다따라서 저자는 main으로 변경하여 넘어가도록 한다다음 메뉴부터는 대부분 기본으로 사용하는 기능으로 NEXT로 넘어가도록 한다Git 초기 설정  유저 설정 (커밋에 기록할 사용자 이름과 이메일을 설정)유저 설정 (커밋에 기록할 사용자 이름과 이메일을 설정)  Github Repositories → New → Repository name 등 작성 후 Create Repository  생성된 repository의 Git 주소 복사  작업 중인 서버의 프로젝트 디렉토리로 이동하여 $git init  $git remote add origin [Git 주소]  $git branch -M main (브랜치를 master에서 main으로 변경)  $git branch (현재 branch 확인)  $git add -A (수정된 파일 전부를 스테이징 영역에 추가, $git add . 으로 현 디렉토리만으로 제한 가능)  $git status (현재 add 내역 확인)  $git commit -m “Initial commit” (스테이지 영역 → 로컬 repository)  $git log (commit 이력 확인)  $git push origin main (로컬 repository → 원격 repository)핵심 요약#유저 설정git config --global user.name \"사용자이름\"git config --global user.email \"사용자이메일\"#확인git config --global user.namegit config --global user.email#기본 브랜치명 변경git config --global init.defaultBranch maingit config --global init.defaultBranch# 깃허브에서 레포지 생성 부터 업로드까지 Github Repositories → New → Repository name 등 작성 후 Create Repository생성된 repository의 Git 주소 복사작업 중인 서버의 프로젝트 디렉토리로 이동하여 $git init(현재 디렉토리를 기준으로 Git 저장소 생성, .git 디렉토리 생성됨)$git remote add origin [Git 주소]$git add -A (수정된 파일 전부를 스테이징 영역에 추가, $git add . 으로 현 디렉토리만으로 제한 가능)$git status (현재 add 내역 확인)$git commit -m \"Initial commit\" (스테이지 영역 → 로컬 repository)$git log (commit 이력 확인)$git push origin main (로컬 repository → 원격 repository)11-1. ! [rejected] main -&gt; main (non-fast-forward) 에러 발생할 경우 $git push origin +main 시도# 깃허브 원격저장소에서 수정사항을 로컬로 가져오기 Pull &amp; Fetch$git pull &lt;remote_name&gt; &lt;branch_name&gt;#연결된 원격 저장소 확인$git remote --verbose#원격 연결을 삭제$git remote remove &lt;remote-name&gt;#현재 브랜치 이름 변경$git branch -M main (브랜치명을 main으로 변경)#등록된 브랜치의 상세한 정보 확인$git branch -v#현재 연결된 원격 저장소의 브랜치 확인$git branch -r# 브랜치 생성하기$git branch [생성할 branch_name]$git push [remote_name] [생성할 branch_name] #push를 안해주면 로컬저장소에만 해당 branch가 생성되어있고 원격저장소엔 브랜치가없음# 브랜치 이동하기$git switch [이동할 브랜치명]# 로컬에서 원격의 브랜치를 찾을 수 있도록 갱신$git remote update# 원격 + 로컬 저장소 확인$git branch -a# 원격 저장소의 브랜치 가져오기$git branch -a 로 브랜치 확인 $git checkout -t origin/[브랜치명]# 브랜치 삭제$git branch -d [삭제할 브랜치명]# 원격저장소의 브랜치를 삭제$git push [romote_name] --delete [삭제할 브랜치명]# 로그 $ git log --all --graph --oneline##### --all 로그 전체를 보여준다##### --graph 그래프형식을 이용해 표현해준다##### --oneline 한 커밋당 한줄로 표현해준다.Git 주요용어  커밋 (commit) : 파일을 추가하거나 변경 내용을 저장소에 저장  푸시 (push) : 파일을 추가하거나 변경 내용을 원격 저장소에 업로드"
  },
  
  {
    "title": "Vue Route 기능 사용하기",
    "url": "/posts/vue_route/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-01-20 12:33:00 +0900",
    





    
    "snippet": "Route란Route(라우트)는 길, 방향의 의미로 웹 서비스를 이용해보면 로그인시 URL이 /login 회원가입시에는 /create 이런식으로 URL을 보내게되는데각 서비스마다 URL을 다르게하여 처리하는 방법을 Route기능이라고 한다Vue에서 Route기능 사용하기Route 설치프롬프트로 npm install vue-router/@4 를 입력하여...",
    "content": "Route란Route(라우트)는 길, 방향의 의미로 웹 서비스를 이용해보면 로그인시 URL이 /login 회원가입시에는 /create 이런식으로 URL을 보내게되는데각 서비스마다 URL을 다르게하여 처리하는 방법을 Route기능이라고 한다Vue에서 Route기능 사용하기Route 설치프롬프트로 npm install vue-router/@4 를 입력하여 설치한다vue 라우터의 경우 버전에 따라 사용방법이 조금씩 상이할 수 있으므로 공식 홈페이지에서 각 버전별 사용법을 참고하자 =&gt; Vue Router 공식 페이지vue 샘플 라우터 추가라우터를 설치한 후 처음부터 라우터를 전부 타이핑하여 만들 수 있지만 vue에서 기본으로 제공하는 샘플 라우터를 사용하여 본인에 맞게 수정 및 추가하여 사용할 수 있다추가하는 방법은 프롬프트에서 vue 프로젝트 폴더로 이동후 vue add router 명령어를 프롬프트에서 수행한다수행 후 vue 프로젝트 폴더 -&gt; src -&gt; router라는 샘플 폴더가 생성된다"
  },
  
  {
    "title": "Vue Axios 라이브러리 사용하기",
    "url": "/posts/vue_axios/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-01-20 12:33:00 +0900",
    





    
    "snippet": "Axios란Axios는 Vue에서 Ajax전송을 도와주는 Http 클라이언트 라이브러리이다Ajax를 사용하다보면 발생할 수 있는 불편함을 보완해주는 기능들을 제공한다  [Ajax]Ajax는 Asynchronous JavaScript and XML의 약자로 빠르게 동작하는 동적인 웹 페이지를 만들기 위해 개발 기법의 하나이다Ajax는 웹 페이지 전체를 ...",
    "content": "Axios란Axios는 Vue에서 Ajax전송을 도와주는 Http 클라이언트 라이브러리이다Ajax를 사용하다보면 발생할 수 있는 불편함을 보완해주는 기능들을 제공한다  [Ajax]Ajax는 Asynchronous JavaScript and XML의 약자로 빠르게 동작하는 동적인 웹 페이지를 만들기 위해 개발 기법의 하나이다Ajax는 웹 페이지 전체를 다시 로딩하지 않고도 웹 페이지의 일부분만 갱신이 가능하며 Ajax를 이용하여 백그라운드 영역에서 백엔드 서버와 통신하여 결과를 웹페이지 일부에만 표시할 수 있다Ajax 는 아래와 같은 다양 형태의 데이터를 주고받을 수 있다      JSON    XML    HTML    텍스트 파일등  Axios 설치프롬프트에서 npm install axios 를 입력하여 설치한다Axios 사용 예제"
  },
  
  {
    "title": "Vue Chap2",
    "url": "/posts/vue02/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-01-20 12:33:00 +0900",
    





    
    "snippet": "프로젝트 구성  Backend : SpringBoot  Frontend : Vue  IDE : Eclipse IDE  Database : MySQL필요한 프로그램 설치Eclipse 설치이클립스 설치 페이지[이클립스에서 Spring Boot 설치]메뉴 툴팁 =&gt; Help =&gt; Eclipse Marketplace 선택spring 으로 검색 =&...",
    "content": "프로젝트 구성  Backend : SpringBoot  Frontend : Vue  IDE : Eclipse IDE  Database : MySQL필요한 프로그램 설치Eclipse 설치이클립스 설치 페이지[이클립스에서 Spring Boot 설치]메뉴 툴팁 =&gt; Help =&gt; Eclipse Marketplace 선택spring 으로 검색 =&gt; Spring Tools 4 (aka Spring Tool Suite 4) 설치vue 설치 - Nodejsvue를 편하고 효율적으로 사용하기 위해서는 npm(nodejs package manager)이라는 라이브러리를 사용해야하는데 npm은 기본적으로 Nodejs를 설치할 때 같이 설치되는 라이브러리이다 따라서 Nodejs를 먼저 설치하도록 한다Nodejs 설치 페이지vue 설치nodejs 설치가 완료된 후 cmd(프롬프트)를 열어서 npm install -g @vue/cli 명령어를 수행하여 vue를 설치한다설치가 완료되면 npm ls -g 명령어로 설치 완료를 확인한다프로젝트 생성 (Spring Boot / Vue 각각)Spring Boot 프로젝트 생성이클립스 IDE를 실행 후file =&gt; new =&gt; Other =&gt; Spring Boot =&gt; Spring Starter Project 선택하고 Next프로젝트로 사용할 프로젝트명 입력 후 Next프로젝트에 필요한 라이브러리 및 의존성 패키지를 미리 설치하는 것으로 저자는 하기 4개의 라이브러리를 선택하였다  Spring Boot DevTools : 라우터로 전송되는 내용들에 대한 코드가 변경되면, 자동으로 어플리케이션을 재시작하여 브라우저에도 업데이트를 해주는 역할  Lombok : 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리이다. Lombok을 이용하면 Getter, Setter, Equlas, ToString 등과 다양한 방면의 코드를 자동완성 시킬 수 있다  Thymeleaf : 흔히 View Template(뷰 템플릿)이라고 부르며 뷰 템플릿은 컨트롤러가 전달하는 데이터를 이용하여 동적으로 화면을 구성할 수 있게 해준다 기존 JSP에서는 많은 기능을 제공하고 전체적인 화면을 디자인하는데 부족하였지만 타임리프는 스프링 프레임워크외에 노드JS나 다른 웹 서버에서도 뷰 템플릿을 사용할 수 있도록한다  spring web : 스프링으로 웹페이지를 만들 때 필수적인 것들이 들어있다Vue 프로젝트 생성cmd(프롬프트)를 실행해서 cd명령어로 위에서 생성한 Spring Boot 프로젝트 폴더로 이동한다 이렇게 하는 이유는 다음에 진행할 Spring Boot와 Vue를 연동하기 위해서이다이동이 완료되었다면 vue create [프로젝트명] 을 입력하여 프로젝트를 생성한다생성한 프로젝트 폴더로 이동후 npm run serve명령어를 수행하면 기본 예제코드로 vue 서버가 open된다 http://localhost:8080 로 접속하여 정상적으로 프로젝트가 생성되었는지 확인한다[Spring Boot 프로젝트 생성한 위치 복사][해당 위치에서 vue 프로젝트 생성]생성시 나오는 질문에서는 기본 Default 로 선택[해당 URL 접속화면]프로젝트 연동(Spring Boot / Vue)위에서 진행한 내용만 봐도 Spring Boot와 Vue는 각각 실행되는 환경인것을 알 수 있다하지만 지금 진행하는 프로젝트는 Spring Boot만 실행시켰을때 Vue도 같이 구동되어 사용할 수 있도록 하고자하기 때문에 연동 작업을 진행한다먼저 Vue에서 빌드하여 배포되는 폴더를 Spring Boot 프로젝트 내로 떨어지도록 수정한다[생성된 vue 프로젝트 폴더내의 vue.config.js파일 수정]module.exports = defineConfig({  ...  // npm run build 타겟 디렉토리 (백엔드쪽!)  outputDir: \"../src/main/resources/static\",    // npm run server 개발 진행시 포트가 다르기 때문에 프록시 설정해줘야 함  // target : 백엔드 port가 들어감  // changeOrigin -&gt; true로 해야 cros 문제 해결할 수 있음  devServer: {    proxy: {      '/': {        target: \"http://localhost:8080\",        changeOrigin: true,      }    }  }[생성된 vue 프로젝트 폴더내의 package.json 파일 수정]  “serve” : “vue-cli-service serve –port 3000”  “build” : “vue-cli-service build –watch”[위 작업이 모두 완료되었다면 재빌드를 진행한다]cmd(프롬프트)를 실행후 vue프로젝트 폴더로 이동하여 npm run build 명령어를 수행하여 빌드를 진행한다빌드 후 아래와 같이 이클립스에서 F5 새로고침 후 /src/main/resources/static 폴더가 생성되었다면 성공이다[이클립스에서 Spring Boot를 실행해보자]프로젝트명 우클릭 =&gt; Run AS =&gt; Spring Boot App브라우저에서 127.0.0.1:8080 스프링부트 포트로 접속했을때 vue 페이지가 나온다면 연동 성공이다"
  },
  
  {
    "title": "Vue Chap2",
    "url": "/posts/vue02-(copy)/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-01-20 12:33:00 +0900",
    





    
    "snippet": "프로젝트 구성  Backend : SpringBoot  Frontend : Vue  IDE : Eclipse IDE  Database : MySQL필요한 프로그램 설치Eclipse 설치이클립스 설치 페이지[이클립스에서 Spring Boot 설치]메뉴 툴팁 =&gt; Help =&gt; Eclipse Marketplace 선택spring 으로 검색 =&...",
    "content": "프로젝트 구성  Backend : SpringBoot  Frontend : Vue  IDE : Eclipse IDE  Database : MySQL필요한 프로그램 설치Eclipse 설치이클립스 설치 페이지[이클립스에서 Spring Boot 설치]메뉴 툴팁 =&gt; Help =&gt; Eclipse Marketplace 선택spring 으로 검색 =&gt; Spring Tools 4 (aka Spring Tool Suite 4) 설치vue 설치 - Nodejsvue를 편하고 효율적으로 사용하기 위해서는 npm(nodejs package manager)이라는 라이브러리를 사용해야하는데 npm은 기본적으로 Nodejs를 설치할 때 같이 설치되는 라이브러리이다 따라서 Nodejs를 먼저 설치하도록 한다Nodejs 설치 페이지vue 설치nodejs 설치가 완료된 후 cmd(프롬프트)를 열어서 npm install -g @vue/cli 명령어를 수행하여 vue를 설치한다설치가 완료되면 npm ls -g 명령어로 설치 완료를 확인한다프로젝트 생성 (Spring Boot / Vue 각각)Spring Boot 프로젝트 생성이클립스 IDE를 실행 후file =&gt; new =&gt; Other =&gt; Spring Boot =&gt; Spring Starter Project 선택하고 Next프로젝트로 사용할 프로젝트명 입력 후 Next프로젝트에 필요한 라이브러리 및 의존성 패키지를 미리 설치하는 것으로 저자는 하기 4개의 라이브러리를 선택하였다  Spring Boot DevTools : 라우터로 전송되는 내용들에 대한 코드가 변경되면, 자동으로 어플리케이션을 재시작하여 브라우저에도 업데이트를 해주는 역할  Lombok : 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리이다. Lombok을 이용하면 Getter, Setter, Equlas, ToString 등과 다양한 방면의 코드를 자동완성 시킬 수 있다  Thymeleaf : 흔히 View Template(뷰 템플릿)이라고 부르며 뷰 템플릿은 컨트롤러가 전달하는 데이터를 이용하여 동적으로 화면을 구성할 수 있게 해준다 기존 JSP에서는 많은 기능을 제공하고 전체적인 화면을 디자인하는데 부족하였지만 타임리프는 스프링 프레임워크외에 노드JS나 다른 웹 서버에서도 뷰 템플릿을 사용할 수 있도록한다  spring web : 스프링으로 웹페이지를 만들 때 필수적인 것들이 들어있다Vue 프로젝트 생성cmd(프롬프트)를 실행해서 cd명령어로 위에서 생성한 Spring Boot 프로젝트 폴더로 이동한다 이렇게 하는 이유는 다음에 진행할 Spring Boot와 Vue를 연동하기 위해서이다이동이 완료되었다면 vue create [프로젝트명] 을 입력하여 프로젝트를 생성한다생성한 프로젝트 폴더로 이동후 npm run serve명령어를 수행하면 기본 예제코드로 vue 서버가 open된다 http://localhost:8080 로 접속하여 정상적으로 프로젝트가 생성되었는지 확인한다[Spring Boot 프로젝트 생성한 위치 복사][해당 위치에서 vue 프로젝트 생성]생성시 나오는 질문에서는 기본 Default 로 선택[해당 URL 접속화면]프로젝트 연동(Spring Boot / Vue)위에서 진행한 내용만 봐도 Spring Boot와 Vue는 각각 실행되는 환경인것을 알 수 있다하지만 지금 진행하는 프로젝트는 Spring Boot만 실행시켰을때 Vue도 같이 구동되어 사용할 수 있도록 하고자하기 때문에 연동 작업을 진행한다먼저 Vue에서 빌드하여 배포되는 폴더를 Spring Boot 프로젝트 내로 떨어지도록 수정한다[생성된 vue 프로젝트 폴더내의 vue.config.js파일 수정]module.exports = defineConfig({  ...  // npm run build 타겟 디렉토리 (백엔드쪽!)  outputDir: \"../src/main/resources/static\",    // npm run server 개발 진행시 포트가 다르기 때문에 프록시 설정해줘야 함  // target : 백엔드 port가 들어감  // changeOrigin -&gt; true로 해야 cros 문제 해결할 수 있음  devServer: {    proxy: {      '/': {        target: \"http://localhost:8080\",        changeOrigin: true,      }    }  }[생성된 vue 프로젝트 폴더내의 package.json 파일 수정]  “serve” : “vue-cli-service serve –port 3000”  “build” : “vue-cli-service build –watch”[위 작업이 모두 완료되었다면 재빌드를 진행한다]cmd(프롬프트)를 실행후 vue프로젝트 폴더로 이동하여 npm run build 명령어를 수행하여 빌드를 진행한다빌드 후 아래와 같이 이클립스에서 F5 새로고침 후 /src/main/resources/static 폴더가 생성되었다면 성공이다[이클립스에서 Spring Boot를 실행해보자]프로젝트명 우클릭 =&gt; Run AS =&gt; Spring Boot App브라우저에서 127.0.0.1:8080 스프링부트 포트로 접속했을때 vue 페이지가 나온다면 연동 성공이다"
  },
  
  {
    "title": "Vue Chap1",
    "url": "/posts/vue01/",
    "categories": "Framework, Vue",
    "tags": "Vue",
    "date": "2024-01-20 12:33:00 +0900",
    





    
    "snippet": "[Vue.js란]vue 는 Evan You가 개인 프로젝트로 시작해서 2014년에 배포한 자바스크립트 프레임워크이다뷰는 다음과 같은 이유로 인기가 많다[Vue의 장점]  진입 장벽이 낮고 학습 비용이 적음  스케일의 유연성  한국어 문서뷰에서 화면을 렌더링하는 구조 자체는 DOM이 아니라 자바스크립트 데이터이다 데이터를 기반으로 적절한 DOM을 구축하...",
    "content": "[Vue.js란]vue 는 Evan You가 개인 프로젝트로 시작해서 2014년에 배포한 자바스크립트 프레임워크이다뷰는 다음과 같은 이유로 인기가 많다[Vue의 장점]  진입 장벽이 낮고 학습 비용이 적음  스케일의 유연성  한국어 문서뷰에서 화면을 렌더링하는 구조 자체는 DOM이 아니라 자바스크립트 데이터이다 데이터를 기반으로 적절한 DOM을 구축하는 방식이다 이처럼 데이터를 중심으로 하는 애플리케이션 설계를 데이터 지향이라고한다[뷰의 템플릿]뷰는 DOM을 구축하는 방법으로 템플릿이라는 것을 주로 사용한다 템플릿 구문은 HMTL을 기반으로 하기 때문에 텍스트 에디터와 함께 쉽게 사용이 가능하다[데이터 바인딩]데이터와 렌더링을 동기화하는 구조를 데이터 바인딩이라고 한다다양한 데이터 바인딩 형태의 라이브러리와 프레임워크가 존재하는데 자바스크립트 데이터와 이를 사용하는 위치를 연결해서 데이터에 변경이 있을 때 자동으로 DOM을 업데이트하는 기능으로 대부분 사용한다Vue.js또한 데이터 바인딩과 관련된 수많은 기능을 가지고 있으며 디렉티브라는 것을 기반으로 이러한 기능을 HTML과 비슷한 형태로 사용할 수 있다[Vue 컴포넌트]사이트의 규모가 커지면 자바스크립,HMTL,CSS의 소스코드가 난잡해지며 자바스크립트가 어느 CSS 어떤 부분에 구현되어있는지 등을 알기가 쉽지 않다Vue.js 컴포넌트는 기능별로 자바스크립트와 템블릿을 하나의 세트로 묶어서 다른 기능과 분리하여 개발할 수 있도록 해주는 기능이다[v-로 시작하는 디렉티브란]vus.js를 사용하다보면 템플릿에 v-if, v-bind등 익숙하지 않은 속성들을 볼 수 있는데 이는 모두 특별한 역할을 가지고 있는 속성들이다 이처럼 v-로 시작하는 속성을 디렉티브라고 부르며 주로 데이터 바인딩과 관련된 처리를 한다"
  },
  
  {
    "title": "JSP 자바 웹 프로그래밍 Chap1",
    "url": "/posts/jsp01/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2024-01-17 12:33:00 +0900",
    





    
    "snippet": "[실습을 위한 도구들]  OpenJDK 17 : 자바 프로그램을 컴파일하고 실행해주는 기본 도구  Tomcat 10.1.x : JSP와 서블릿을 실행하기 위한 웹 서버  이클립스 : 전체 도구를 아우르는 통합 개발 환경(IDE)  Oracle 21c Express Edition : 데이터 베이스 관리 시스템  SQL Developer : 그래픽 기반(...",
    "content": "[실습을 위한 도구들]  OpenJDK 17 : 자바 프로그램을 컴파일하고 실행해주는 기본 도구  Tomcat 10.1.x : JSP와 서블릿을 실행하기 위한 웹 서버  이클립스 : 전체 도구를 아우르는 통합 개발 환경(IDE)  Oracle 21c Express Edition : 데이터 베이스 관리 시스템  SQL Developer : 그래픽 기반(GUI)의 Oracle 관리 도구[JSP(JavaServer Pages)란]  HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구  JSP 가 실행되면 자바 서블릿(Servlet) 으로 변환되며 웹 어플리케이션 서버에서 동작되면서 필요한 기능을 수행[웹 서버(Web Server)란]  사용자로부터 HTTP를 통해 요청을 받거나 웹 컨테이너가 전달해준 결과물을 정적인 페이지로 생성하여 사용자에게 응답해주는 소프트웨어를 뜻하며 웹 페이지는 주로 HTML, CSS, 자바스크립트 등으로 구성된다[웹 컨테이너(Web Container)란]  웹 서버가 전송해준 요청을 기초로 동적인 페이지를 생성하여 웹 서버로 돌려준다[WAS(Web Application Server)란]  WAS는 웹 서버(정적인 페이지) + 웹 컨테이너(동적 페이지)를 포함한 개념이며 톰캣이 대표적인 제품이며 외에 웹로직, 웹스피어 등의 제품이 있다[HTTP(Hyper Text Transfer Protocol)와 HTTPS(HTTP Secure) 차이]  HTTP는 웹 서버와 사용자 사이의 통신을 위해 사용하는 통신 프로토콜이며 HTTPS는 HTTP의 보안 요소를 강화하기 위해 만들어진 HTTP의 암호화된 버전 프로토콜이다[프로토콜(Protocol)이란]네트워크를 통해 컴퓨터들이 정보를 주고받는 절차 혹은 통신 규약을 말한다 예를들어 한국인과 미국인이 각자의 모국어로만 말을 한다면 소통을할 수 없다 컴퓨터도 마찬가지이며 서로 다른 컴퓨터들이 대화하는 데 필요한 공통 언어 역할을 해주는게 프로토콜이다 HTTP또한 프로토콜의 한 종류이며 FTP, SMTP등 다양한 프로토콜이 존재한다[포트(Port)란]  컴퓨터 사이에서 데이터를 주고받을 수 있는 통로를 말한다 예를 들어 IP가 주소지와 건물명이라면 Port는 몇호인지를 뜻한다  우리가 이용하는 인터넷상의 모든 서비스는 IP 주소와 함께 포트 번호까지 지정해야 제대로 요청을 전달할 수 있으며 대표적으로 HTTP는 80, HTTPS는 443 포트를 사용한다[정적 웹 페이지와 동적 웹 페이지]  정적 웹 페이지(Static Web Page)란 웹 서버에 저장되어 있는 파일을 그대로 웹 브라우저에 전송해 출력하는 가장 기본적인 웹 페이지를 말한다  동적 웹 페이지(Dynamic Web Page)란 그때그때 내용이 달라질 수 있는 웹 페이지이며 클라이언트의 요청을 해석하여 가장 적절한 웹 페이지를 그때 그때 생성해 보내주는 기술이다대표적으로는 JSP와 서블릿이 있고 다른 기술로는 ASP와 PHP등이있다[Java EE란]"
  },
  
  {
    "title": "workspace",
    "url": "/posts/workspace_v3.4/",
    "categories": "update",
    "tags": "update",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "version",
    "content": "version"
  },
  
  {
    "title": "S3YZNB0M553014V",
    "url": "/posts/S3YZNB0M553014V/",
    "categories": "access",
    "tags": "access",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "access",
    "content": "access"
  },
  
  {
    "title": "MDC1HFAL",
    "url": "/posts/MDC1HFAL/",
    "categories": "access",
    "tags": "access",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "access",
    "content": "access"
  },
  
  {
    "title": "33LW2SNMS",
    "url": "/posts/33LW2SNMS/",
    "categories": "access",
    "tags": "access",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "access",
    "content": "access"
  },
  
  {
    "title": "33HVSNPMS",
    "url": "/posts/33HVSNPMS/",
    "categories": "access",
    "tags": "access",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "access",
    "content": "access"
  },
  
  {
    "title": "058F011111B1",
    "url": "/posts/058F011111B1/",
    "categories": "access",
    "tags": "access",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "access",
    "content": "access"
  },
  
  {
    "title": "S3YZNB0M553014V",
    "url": "/posts/0025_388B_91C9_CA8B/",
    "categories": "access",
    "tags": "access",
    "date": "2024-01-08 11:30:00 +0900",
    





    
    "snippet": "access",
    "content": "access"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 15장",
    "url": "/posts/spring15/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-12-25 12:33:00 +0900",
    





    
    "snippet": "댓글 REST API의 개요REST API를 진행하기전 복습  Rest 컨트롤러 : 댓글 REST API를 위한 컨트롤러로 서비스와 협업, 클라이언트 요청을 받아 응답하며 뷰(View)가 아닌 데이터를 반환한다  서비스 : REST 컨트롤러와 리파지터리 사이에서 비즈니스 로직, 즉 처리 흐름을 담당하며 예외 상황이 발생했을 때 @Transactiona...",
    "content": "댓글 REST API의 개요REST API를 진행하기전 복습  Rest 컨트롤러 : 댓글 REST API를 위한 컨트롤러로 서비스와 협업, 클라이언트 요청을 받아 응답하며 뷰(View)가 아닌 데이터를 반환한다  서비스 : REST 컨트롤러와 리파지터리 사이에서 비즈니스 로직, 즉 처리 흐름을 담당하며 예외 상황이 발생했을 때 @Transactional로 변경된 데이터 롤백  DTO :  사용자에게 보여 줄 댓글 정보를 담은 것, 단순히 클라이언트와 서버 간에 댓글 JSON 데이터 전송  엔티티 : DB 데이터를 담는 자바 객체로 엔티티를 기반으로 테이블을 생성, 리파지터리가 DB속 데이터를 조회하거나 전달할 때 사용  리파지터리 : 엔티티를 관리하는 인터페이스로 데이터 CRUD 등의 기능을 제공, 서비스로부터 댓글 CRUD 등의 명령을 받아 DB에 보내고 응답을 받음  컨트롤러-웨이터, 서비스-주방장, 리파지터리-보조 요리사로 비유댓글 컨트롤러와 서비스 틀 만들기댓글 REST API를 구현하려면 일반 컨트롤러가 아닌 REST 컨트롤러를 만들어야 한다 REST 컨트롤러는 api 패키지에 만들도록한다"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 14장",
    "url": "/posts/spring14/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-12-18 12:33:00 +0900",
    





    
    "snippet": "댓글 엔티티와 리파지터리 만들기게시판에 댓글 생성, 조회, 수정, 삭제하는 댓글 CRUD 기능을 구현한다댓글 기능일반적인 게시판을 보면 하나의 게시글에 수많은 댓글이 달린다, 이러한 관계를 one-to-many(1:n) 일대다 라고 부른다DB에 값을 저장할때는 해당 게시글과 댓글간의 연결관계가 있어야하는데 테이블마다 자신을 대표하는 id가 존재하는데 ...",
    "content": "댓글 엔티티와 리파지터리 만들기게시판에 댓글 생성, 조회, 수정, 삭제하는 댓글 CRUD 기능을 구현한다댓글 기능일반적인 게시판을 보면 하나의 게시글에 수많은 댓글이 달린다, 이러한 관계를 one-to-many(1:n) 일대다 라고 부른다DB에 값을 저장할때는 해당 게시글과 댓글간의 연결관계가 있어야하는데 테이블마다 자신을 대표하는 id가 존재하는데 id와 같이 자신을 대표하는 속성을 대표키(PK, Primary Key)라고 부른다, 대표키는 동일 테이블 내에서 절대 중복된 값이 없어야 한다 PK로 관계를 맺고 연관 대상을 가리키는 속성을 외래키(FK, Foreign Key)라 부른다댓글 엔티티와 리파지터리의 설계JPA(Java Persistence API)  엔티티: DB 데이터를 담는 자바 객체로, 엔티티를 기반으로 테이블 생성  리파지터리: 엔티티를 관리하는 인터페이스로, 데이터 CRUD 등의 기능 제공graph LRA(CommentRepository)--&gt;B[Comment]B--&gt;C(DB)앞서 게시판 작성을 위해 Article 엔티티와 ArticleRepository를 작성한 것처럼, 댓글 작성을 위한 Comment 엔티티와 CommentRepository를 만들도록 한다Comment 엔티티 생성[main/java/entity/Comment]Comment 리포지터리 생성[main/java/repository/CommentRepository]Comment 더미 데이터 생성[main/resources/templates/data.sql]"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 13장",
    "url": "/posts/spring13/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-12-18 12:33:00 +0900",
    





    
    "snippet": "코딩에서의 테스트란테스트란 프로그램의 품질을 검증하는 절차로 코딩한대로 프로그램이 잘 동작하는지를 확인하는 과정이다테스트 도구를 활용해 코드를 검증한다는 것은 테스트 코드를 작성해 실행한다는것으로 테스트 코드는 아래와 같다작성한 코드가 테스트를 통과하면 지속적인 리팩터링으로 코드를 개선한다 그러나 테스트를 통과하지 못하면 잘못된 부분을 찾아 고치는 디...",
    "content": "코딩에서의 테스트란테스트란 프로그램의 품질을 검증하는 절차로 코딩한대로 프로그램이 잘 동작하는지를 확인하는 과정이다테스트 도구를 활용해 코드를 검증한다는 것은 테스트 코드를 작성해 실행한다는것으로 테스트 코드는 아래와 같다작성한 코드가 테스트를 통과하면 지속적인 리팩터링으로 코드를 개선한다 그러나 테스트를 통과하지 못하면 잘못된 부분을 찾아 고치는 디버깅(debugging)을 해야 한다  ‘테스트 주도 개발(TDD, Test Driven Development)’이란 일단 테스트 코드를 만든 후 이를 통과하는 최소한의 코드부터 시작해 점진적으로 코드를 개선 및 확장해 나가는 개발 방식테스트코드 작성[검증하고자 하는 메서드(함수) 마우스 우클릭 -&gt; Generate -&gt; Test 클릭][Testing library는 JUnit5선택 후 아래에서 테스트하고자 하는 메서드 한번 더 체크후 OK 클릭]위와 같이 테스트 코드를 생성하면 ‘test &gt; java &gt; com.example.[프로젝트명]]&gt; service &gt; ArticleServiceTest’로 그 이름과 경로가 자바 코드와 동일하게 생성된다[테스트코드 작성법 3단계]예상 데이터 작성하기import org.junit.jupiter.api.Test;  // Test 패키지 임포트import static org.junit.jupiter.api.Assertions.*; // 앞으로 사용할 수 있는 패키지 임포트@SpringBootTest // 해당 클래스를 스프링 부트와 연동해 통합 테스트를 수행하겠다고 선언하는 것 @SpringBootTest를 사용하면 손쉽게 통합 테스트를 위한 환경을 준비해준다. @SpringBootTest는 모든 빈들을 스캔하고 애플리케이션 컨텍스트를 생성하여 테스트를 실행한다class Project1112ApplicationTests {@Autowired // 스프링 컨테이너에 등록한 빈에게 의존관계주입이 필요할 때, DI(의존성 주입)을 도와주는 어노테이션이다.ArticleService articleService; // articleService 객체 주입@Test // 해당 메서드가 테스트를 위한 코드라고 선언하는 것, 코드 위쪽을 보면 여러 자바 API가 임포트된 것을 확인할 수 있다 @Test 어노테이션을 사용하기 위해 Test 패키지를 임포트했고, 앞으로 사용할 가능성이 있는 패키지도 미리 임포트해 놓았다void index() {// 1. 예상 데이터    Article a = new Article(1L, \"가가가가\", \"1111\");    Article b = new Article(2L, \"나나나나\", \"2222\");    Article c = new Article(3L, \"다다다다\", \"3333\");    List&lt;Article&gt; expected = new ArrayList&lt;Article&gt;(Arrays.asList(a, b, c));  }}예상 데이터를 확인했으므로 각 데이터를 Article 객체 a, b, c에 저장한다 이때 id는 Long 타입이므로 접미사 L을 붙인다a, b, c 3개의 객체를 Arrays.asList() 메서드를 사용해 ArrayList로 합치고 이를 List&lt;Article&gt; 타입의 expected에 저장한다 Arrays 클래스가 빨간색으로 표시되면 마우스를 올린 후 Import class를 클릭하고 Arrays (java.util)을 선택해 관련 패키지를 임포트한다  [Tip]Arrays.asList()메서드해당 메서드는 입력된 배열 또는 2개 이상의 동일한 타입 데이터를 정적 리스트로 만들어 변환한다 정적리스트는 고정 크기이르므로 add()나 remove()메서드를 사용할 수 없다실제 데이터 흭득하기import org.junit.jupiter.api.Test;  // Test 패키지 임포트import static org.junit.jupiter.api.Assertions.*; // 앞으로 사용할 수 있는 패키지 임포트@SpringBootTestclass Project1112ApplicationTests {@AutowiredArticleService articleService; // articleService 객체 주입@Testvoid index() {    // 1. 예상 데이터    Article a = new Article(1L, \"가가가가\", \"1111\");    Article b = new Article(2L, \"나나나나\", \"2222\");    Article c = new Article(3L, \"다다다다\", \"3333\");    List&lt;Article&gt; expected = new ArrayList&lt;Article&gt;(Arrays.asList(a, b, c));    // 2. 실제 데이터    List&lt;Article&gt; articles = articleService.index();    }}articleService.index() 메서드를 호출해 그 결과를 List&lt;Article&gt; 타입의 articles에 받아 오고 모든 게시글을 조회 요청하여 그 결과로 반환되는 게시글의 묶음을 받아 오는 작업이다예상 데이터와 실제 데이터 비교해서 검증하기import org.junit.jupiter.api.Test;  // Test 패키지 임포트import static org.junit.jupiter.api.Assertions.*; // 앞으로 사용할 수 있는 패키지 임포트@SpringBootTestclass Project1112ApplicationTests {@AutowiredArticleService articleService; // articleService 객체 주입@Testvoid index() {    // 1. 예상 데이터    Article a = new Article(1L, \"가가가가\", \"1111\");    Article b = new Article(2L, \"나나나나\", \"2222\");    Article c = new Article(3L, \"다다다다\", \"3333\");    List&lt;Article&gt; expected = new ArrayList&lt;Article&gt;(Arrays.asList(a, b, c));    // 2. 실제 데이터    List&lt;Article&gt; articles = articleService.index();    // 3. 비교 및 검증    assertEquals(expected.toString(), articles.toString());    }}제 데이터와 예상 데이터가 일치하는지 비교한다 비교는 assertEquals(x, y) 메서드를 이용한다 이 메서드는 JUnit에서 제공하는데, 예상 데이터(x)와 실제 데이터(y)를 비교해 일치하면 테스트를 통과시킨다 따라서 x에는 예상 데이터를 문자열로 변환한 expected.toString()을 넣고, y에는 실제 데이터를 문자열로 변환한 articles.toString()을 넣는다"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 12장",
    "url": "/posts/spring12/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-12-12 12:33:00 +0900",
    





    
    "snippet": "서비스와 트랜잭션의 개념서비스란 컨트롤러와 리파지터리 사이에 위치하는 계층으로, 서버의 핵심 기능(비지니스 로직)을 처리하는 순서를 총괄한다 모두 성공해야 하는 일련의 과정을 트랜잭션이라고 하며 트랜잭션이 실패로 돌아갈 경우 진행 초기 단계로 돌리는 것을 롤백이라고 한다서비스 계층 만들기서비스 계층을 추가해서 컨트롤러, 서비스, 리파지터리의 역할을 분...",
    "content": "서비스와 트랜잭션의 개념서비스란 컨트롤러와 리파지터리 사이에 위치하는 계층으로, 서버의 핵심 기능(비지니스 로직)을 처리하는 순서를 총괄한다 모두 성공해야 하는 일련의 과정을 트랜잭션이라고 하며 트랜잭션이 실패로 돌아갈 경우 진행 초기 단계로 돌리는 것을 롤백이라고 한다서비스 계층 만들기서비스 계층을 추가해서 컨트롤러, 서비스, 리파지터리의 역할을 분업해보도록 한다[기존의 컨트롤러에서 서비스와 분업하게 변경됨 –11장 참고]// FirstApiController 파일@GetMapping(\"/api/articles\")public List&lt;Article&gt; index() {//        return articleRepository.findAll();return articleService.index();}@GetMapping(\"/api/articles/{id}\")public Article show(@PathVariable Long id) {//        return articleRepository.findById(id).orElse(null);return articleService.show(id);}// POST@PostMapping(\"/api/articles\")public ResponseEntity&lt;Article&gt; create(@RequestBody ArticleForm dto) {//    public Article create(@RequestBody ArticleForm dto) {//        Article article = dto.toEntity();//        return articleRepository.save(article);Article created = articleService.create(dto);return (created != null) ? // 생성하면 정상, 실패하면 오류 응답ResponseEntity.status(HttpStatus.OK).body(created) :ResponseEntity.status(HttpStatus.BAD_REQUEST).build();}// PATCH@PatchMapping(\"/api/articles/{id}\")public ResponseEntity&lt;Article&gt; update(@PathVariable Long id, @RequestBody ArticleForm dto) {Article updated = articleService.update(id, dto);return (updated != null) ?ResponseEntity.status(HttpStatus.OK).body(updated) :ResponseEntity.status(HttpStatus.BAD_REQUEST).build();}//    //DELETE@DeleteMapping(\"/api/articles/{id}\")public ResponseEntity&lt;Article&gt; delete(@PathVariable Long id) {Article deleted = articleService.delete(id);return (deleted != null) ?ResponseEntity.status(HttpStatus.NO_CONTENT).build() :ResponseEntity.status(HttpStatus.BAD_REQUEST).build();}[서비스를 생성하여 기존의 컨트롤러에서 처리한 부분을 서비스가 처리]// ArticleService 파일@Autowiredprivate ArticleRepository articleRepository; // 게시글 리파지터리 객체 주입public List&lt;Article&gt; index() {return articleRepository.findAll();}public Article show(Long id) {return articleRepository.findById(id).orElse(null);}public Article create(ArticleForm dto) {Article article = dto.toEntity(); // dto를 엔티티로 변환한후 article에 저장if(article.getId()!=null){return null;}return articleRepository.save(article); // article을 db에 저장}public Article update(Long id, ArticleForm dto) {// 1. DTO -&gt; 엔티티 변환하기Article article = dto.toEntity();log.info(\"id: {}, article: {}\", id, article.toString());// 2. 타깃 조회하기Article target = articleRepository.findById(id).orElse(null);// 3. 잘못된 요청 처리하기if (target == null || id != article.getId()){//400. 잘못된 요청 응답!log.info(\"잘못된 요청! id:{}, article:{}\",id,article.toString());return null;}// 4. 업데이트 및 정상 응답(200)하기// 기존 데이터에 새 데이터 붙이기target.patch(article);Article updated = articleRepository.save(article);return updated;}public Article delete(Long id) {// 1. 대상 찾기Article target = articleRepository.findById(id).orElse(null);// 2. 잘못된 요청 처리하기if(target == null){return null;}// 3. 대상 삭제하기articleRepository.delete(target);return target;}ResponseEntity란Spring Framework에서 제공하는 클래스 중 HttpEntity라는 클래스가 존재한다. 이것은 HTTP 요청(Request) 또는 응답(Response)에 해당하는 HttpHeader와 HttpBody를 포함하는 클래스이다[HttpEntity 클래스]public class HttpEntity&lt;T&gt; {private final HttpHeaders headers;@Nullableprivate final T body;}[HttpEntity 클래스를 상속받은 클래스들]HttpEntity 클래스를 상속받아 구현한 클래스가 RequestEntity, ResponseEntity 클래스이다. ResponseEntity는 사용자의 HttpRequest에 대한 응답 데이터를 포함하는 클래스이다. 따라서 HttpStatus, HttpHeaders, HttpBody를 포함한다public class RequestEntity&lt;T&gt; extends HttpEntity&lt;T&gt;public class ResponseEntity&lt;T&gt; extends HttpEntity&lt;T&gt;"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 11장",
    "url": "/posts/spring11/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-12-11 12:33:00 +0900",
    





    
    "snippet": "REST API와 JSAON의 등장 배경웹 서비스를 사용하는 클라이언트는 매우 다양하다 스마트폰, 스마트워치, 태블릿등 서버는 이러한 모든 클라이언트의 요청에 응답해야한다 따라서 효율적인 서버 자원 사용을 위해서 나타난 기술이 REST API(Representational State Transfer API)이다REST API 방식에서는 HTTP 요청에...",
    "content": "REST API와 JSAON의 등장 배경웹 서비스를 사용하는 클라이언트는 매우 다양하다 스마트폰, 스마트워치, 태블릿등 서버는 이러한 모든 클라이언트의 요청에 응답해야한다 따라서 효율적인 서버 자원 사용을 위해서 나타난 기술이 REST API(Representational State Transfer API)이다REST API 방식에서는 HTTP 요청에 대한 응답으로 서버의 자원을 반환한다버는 클라이언트의 요청에 대한 응답으로 화면(view)이 아닌 데이터(data)를 전송한다 이때 사용하는 응답 데이터는 JSON(JavaScript Object Notation)이다과거에는 응답 데이터로 XML을 많이 사용했지만, 최근에는 JSON으로 통일되는 추세이다[XML 예시]&lt;article-form&gt;    &lt;id&gt;1&lt;/id&gt;    &lt;title&gt;가가가가&lt;/title&gt;    &lt;content&gt;1111&lt;/content&gt;&lt;/article-form&gt;[JSON 예시]{    \"id\": 1,    \"title: \"가가가가\",    \"content\": \"1111\"}  ON 데이터는 키(key)와 값(value)으로 구성된 정렬되지 않은 속성(property)의 집합이다 키는 문자열이므로 항상 큰따옴표(““)로 감싸고, 값은 문자열인 경우에만 큰따옴표(““)로 감싸도록 한다JSON 실습Placeholder(API제공 테스 사이트)Placeholder 사이트(https://jsonplaceholder.typicode.com)에 접속한다 이 사이트는 가짜(fake) API를 제공하여 무료로 각종 테스트를 진행할 수 있는 서비스를 제공한다[Placeholder 사이트]위 무료로 제공하는 API사이트를 활용해서 API를 요청해보도록한다Talend API Tester(API요청 테스트 사이트)[Talend API Tester 검색하여 확장 추가][Talend API Tester 실행]GET 요청하고 응답한 값 확인하기[Placeholder 사이트에서 제공하는 API로 요청해보기][Placeholder 사이트에서 응답한 값 확인하기][상태 코드]      1XX(정보) : 요청이 수신돼 처리 중    2XX(성공) : 요청이 정상적으로 처리됨    3XX(리다이렉션 메시지) : 요청을 완료하려면 추가 행동이 필요    4XX(클라이언트 요청 오류) : 클라이언트의 요청이 잘못돼 서버가 요청을 수행할 수 없음    5XX(서버 응답 오류) : 서버 내부에 에러가 발생해 클라이언트 요청에 대해 수행하지 못함  [HTTP 메시지는 시작 라인(start line), 헤더(header), 빈 라인(blank line), 본문(body)으로 구성된다]  • 시작 라인: HTTP 요청 또는 응답 내용이 있으며 시작 라인은 항상 한 줄로 끝난다• 헤더: HTTP 전송에 필요한 부가 정보(metadata)가 있다• 빈 라인: 헤더의 끝을 알리는 빈 줄로, 헤더가 모두 전송되었음을 알린다• 본문: 실제 전송하는 데이터가 있다Post로 요청하고 응답한 값 확인하기[Post로 데이터 생성 요청하기][서버로부터 응답 값 확인하기]PATCH(수정) 요청하고 응답한 값 확인하기URL은 1번 게시글을 수정하도록 https://jsonplaceholder.typicode.com/posts/1로 작성한다[PATCH로 1번 데이터 수정 요청하기][서버로부터 응답 값 확인하기]DELETE(삭제) 요청하고 응답한 값 확인하기URL은 1번 게시글을 삭제하도록 https://jsonplaceholder.typicode.com/posts/1로 작성한다[DELETE로 1번 데이터 삭제 요청하기][서버로부터 응답 값 확인하기]REST 컨트롤러와 일반 컨트롤러의 차이  REST 컨트롤러(FirstApiController)는 JSON이나 텍스트 같은 데이터를 반환하는 반면 일반 컨트롤러(FirstController)는 뷰 페이지를 반환한다[Rest컨트롤러][일반컨트롤러]API 직접 만들어보기GET 요청을 받아 처리할 메서드를 만들기프로젝트 탐색기의 api 패키지에서 마우스 오른쪽 버튼을 누르고 New → Java Class를 선택, 클래스 이름은 FirstApiController로 만들도록한다    @GetMapping(\"/api/hello\")    public String hello() {        return \"hello world!\";[Talend로 위에 만든 API로 요청하기]GET 요청으로 모든 데이터 조회 메서드 만들기GET 메소드로 /api/articles 를 요청하면 DB에 가지고 있는 모든 데이터를 응답할 수 있도록 만든다[/api/FirstApiController]    // 게시글 리파지터리 주입    @Autowired    private ArticleRepository articleRepository;    @GetMapping(\"/api/articles\")    public List&lt;Article&gt; index(){        return articleRepository.findAll();    }[Talend로 위에 만든 API로 모든 데이터 요청하기]GET 요청으로 단일 데이터 조회 메서드 만들기GET 메소드로 /api/articles/{id} 를 요청하면 DB에 가지고 있는 해당 id의 데이터를 응답할 수 있도록 만든다[/api/FirstApiController]    @GetMapping(\"/api/articles/{id}\")    public Article show(@PathVariable Long id) {        return articleRepository.findById(id).orElse(null);    }[Talend로 위에 만든 API로 단일 데이터 요청하기]POST API 요청으로 데이터 생성하기POST 메소드로 생성할 데이터를 dto 매개변수로 받아 온다이렇게 받은 dto는 DB에서 사용할 수 있도록 엔티티로 변환하여 article변수에 넣고, articleRepository를 통해 DB에 저장한다[/api/FirstApiController]    @PostMapping(\"/api/articles\")    // dto 매개변수 앞에 @RequestBody라는 어노테이션을    // 사용한 이유는 기존에는 메서드의 매개변수로 dto로 받아 오기만 하면 됐으나     // 여기서는 json으로 데이터를 받아 와야 하므로 본문에 실어 보내는 데이터를 매개변수로 받아오기 위해 사용한다    public Article create(@RequestBody ArticleForm dto) {        Article article = dto.toEntity();        return articleRepository.save(article);    }[Talend로 위에 만든 API로 데이터 생성 요청하기]PATCH API 요청으로 데이터 수정하기PATCH 메소드로 수정할 데이터와 수정할 대상 id를 dto 매개변수로 받아 오고 엔티티로 변환한다, 이후 해당 id가 존재하는지를 확인하고 수정 결과를 응답한다[/api/FirstApiController]    @PatchMapping(\"/api/articles/{id}\")    public ResponseEntity&lt;Article&gt; update(@PathVariable Long id, @RequestBody ArticleForm dto) {        // 1. DTO -&gt; 엔티티 변환하기        Article article = dto.toEntity();        log.info(\"id: {}, article: {}\", id, article.toString());        // 2. 타깃 조회하기        Article target = articleRepository.findById(id).orElse(null);        // 3. 잘못된 요청 처리하기        if (target == null || id != article.getId()){            //400. 잘못된 요청 응답!            log.info(\"잘못된 요청! id:{}, article:{}\",id,article.toString());            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);        }        // 4. 업데이트 및 정상 응답(200)하기        // 기존 데이터에 새 데이터 붙이기        target.patch(article);        Article updated = articleRepository.save(article);        return ResponseEntity.status(HttpStatus.OK).body(updated);        //DELETE    }[Article.java]    public void patch(Article article) {        if (article.title != null)            this.title = article.title;        if (article.content != null)            this.content = article.content;    }[Talend로 위에 만든 API로 데이터 변경 요청하기]Delete API 요청으로 데이터 삭제하기Delete 메소드로 삭제할 대상을 매개변수로 받고 DB에서 대상 엔티티가 있는지 조회한다[/api/FirstApiController]    @DeleteMapping(\"/api/articles/{id}\")    public ResponseEntity&lt;Article&gt; delete(@PathVariable Long id){        // 1. 대상 찾기        Article target = articleRepository.findById(id).orElse(null);        // 2. 잘못된 요청 처리하기        if(target == null){            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);        }        // 3. 대상 삭제하기        articleRepository.delete(target);        return ResponseEntity.status(HttpStatus.OK).body(null);    }[Talend로 위에 만든 API로 데이터 삭제 요청하기]"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 4장",
    "url": "/posts/spring9/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-11-26 12:33:00 +0900",
    





    
    "snippet": "게시글 Update게시판에 작성한 글을 수정하기 위해서는 해당 글을 불러와 수정할 수 있는 입력 상태로 만들어야 한다 이후 내용을 입력하고 다시 전송하면 DB에 반영돼 최종적으로 수정된다[수정 단계]  &lt;상세 페이지&gt;에서 [Edit] 버튼을 클릭한다  요청을 받은 컨트롤러는 해당 글의 id로 DB에서 데이터를 찾아 가져온다  컨트롤러는 가져...",
    "content": "게시글 Update게시판에 작성한 글을 수정하기 위해서는 해당 글을 불러와 수정할 수 있는 입력 상태로 만들어야 한다 이후 내용을 입력하고 다시 전송하면 DB에 반영돼 최종적으로 수정된다[수정 단계]  &lt;상세 페이지&gt;에서 [Edit] 버튼을 클릭한다  요청을 받은 컨트롤러는 해당 글의 id로 DB에서 데이터를 찾아 가져온다  컨트롤러는 가져온 데이터를 뷰에서 사용할 수 있도록 모델에 등록한다  모델에 등록된 데이터를 &lt;수정 페이지&gt;에서 보여 준다 그러면 사용자가 내용을 수정할 수 있는 상태가 된다  폼 데이터(수정 요청 데이터)를 DTO에 담아 컨트롤러에서 받는다  DTO를 엔티티로 변환한다  DB에서 기존 데이터를 수정 데이터로 갱신한다  수정 데이터를 &lt;상세 페이지&gt;로 리다이렉트 한다&lt;상세 페이지&gt;에서 Edit 버튼 생성  show.mustache 파일{{&gt;layouts/header}}{{#article}}&lt;table class=\"table\"&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th scope=\"col\"&gt;Id&lt;/th&gt;        &lt;th scope=\"col\"&gt;Title&lt;/th&gt;        &lt;th scope=\"col\"&gt;Content&lt;/th&gt;        &lt;th scope=\"col\"&gt;Handle&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;th&gt;{{id}}&lt;/th&gt;        &lt;td&gt;{{title}}&lt;/td&gt;        &lt;td&gt;{{content}}&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;a href=\"/articles/{{article.id}}/edit\" class=\"btn btn-primary\"&gt;Edit&lt;/a&gt;&lt;a href=\"/articles/{{article.id}}/delete\" class=\"btn btn-danger\"&gt;Delete&lt;/a&gt;&lt;a href=\"/articles\"&gt;Go to Article List&lt;/a&gt;{{/article}}{{&gt;layouts/footer}}  href 속성 값의 URL을 보면 id가 article의 속성이므로 {{article.id}}로 사용했는데 표 보통 article의 사용 범위를 {{#article}}{{/article}} 형식으로 지정한 경우에는 {{id}}만 써도 되지만 범위를 따로 지정하지 않았다면 점(.)을 사용해 {{article.id}}라고 표시해야 한다&lt;상세 페이지&gt;에서 Edit 버튼을 누를시 &lt;수정 페이지&gt;로 이동할 수 있도록 Controller에서 맵핑 라우팅을 추가한다  ArticleController 파일@GetMapping(\"/articles/{id}/edit\")public String edit(@PathVariable Long id, Model model) {//수정할 데이터 가져오기Article articleEntity = articleRepository.findById(id).orElse(null); // db에서 수정할 데이터 가져오기//모델에 데이터 등록하기model.addAttribute(\"article\", articleEntity);//articleEntity를 article로 등록// 뷰페이지 설정하기return \"articles/edit\";}  [Tip]      public String edit(@PathVariable Long id, Model model) 부분에서 @PathVariable 는 id변수가 URL 주소에 있는 id변수를 받아 오는 것으로 어노테이션을 특정 지정해야한다 Model model은 모델을 사용하기 위해 model 객체를 받아온다    addAttribute() 메서드로 모델에 데이터를 등록한다 article이라는 이름으로 앞에서 가져온 articleEntity를 등록한다(이렇게 하면 DB에서 가져온 데이터를 article이라는 이름으로 뷰 페이지에서 사용할 수 있다)  &lt;수정 페이지&gt; 파일 생성  edit.mustache 파일{{&gt;layouts/header}}{{#article}}&lt;form class=\"container\" action=\"/articles/update\" method=\"post\"&gt; &lt;!-- 부트스트랩 css코드 --&gt;&lt;input name=\"id\" type=\"hidden\" value=\"{{id}}\"&gt;&lt;div class=\"mb-3\"&gt;    &lt;label class=\"form-label\"&gt;제목&lt;/label&gt;    &lt;input type=\"text\" class=\"form-control\" name=\"title\" value=\"{{title}}\"&gt; &lt;!-- DTO의 title 필드와 연결 --&gt;&lt;/div&gt;&lt;div class=\"mb-3\"&gt;    &lt;label class=\"form-label\"&gt;내용&lt;/label&gt;    &lt;textarea class=\"form-control\" rows=\"3\" name=\"content\"&gt;{{content}}&lt;/textarea&gt; &lt;!-- DTO의 content 필드와 연결 --&gt;&lt;/div&gt;&lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;&lt;a href=\"/articles/{{id}}\"&gt;Back&lt;/a&gt;&lt;/form&gt;{{/article}}{{&gt;layouts/footer}}&lt;수정 페이지&gt;에서 Submit 버튼을 누를시 DB에 수정된 값으로 반영하고 리다이렉션을 위한 라우팅 추가  ArticleController 파일@PostMapping(\"/articles/update\")public String update(ArticleForm form) {// 매개변수로 DTO 받아 오기log.info(form.toString()); // DTO 데이터가 잘들어있는지 로그 찍기Article articleEntity = form.toEntity(); //DTO(form)를 엔티티(articleEntity)로 변환하기log.info(articleEntity.toString()); //엔티티로 잘 변환됐는지 로그 찍기//DB에서 기존 데이터 가져오기Article target = articleRepository.findById(articleEntity.getId()).orElse(null);//기존 데이터 값을 갱신하기if (target != null) {    articleRepository.save(articleEntity); // 엔티티를 DB에 저장(갱신)}return \"redirect:/articles/\" + articleEntity.getId();}sequenceDiagramedit(수정페이지)-&gt;&gt;+DTO(컨트롤러): 데이터 수정 요청 (HTTP)DTO(컨트롤러)-&gt;&gt;+엔티티(리파지터리): DTO를 엔티티로 변환엔티티(리파지터리)-&gt;&gt;+SQL: DB 갱신 (JPA)SQL -&gt;&gt;+edit(수정페이지): 리다이렉트  MVC(Model-View-Controller): 서버 역할을 분담해 처리하는 기법  JPA(Java Persisitence API): 서버와 DB 간 소통에 관여하는 기술  SQL(Structured Query Language): DB 데이터를 관리하는 언어  HTTP(HyperText Transfer Protocol): 데이터를 주고받기 위한 통신 규약게시글 Delete[삭제 단계]  클라이언트가 http 메서드로 특정 게시글의 삭제를 요청  삭제 요청을 받은 컨트롤러는 리파지터리를 통해 db에 저장된 데이터를 찾아 삭제한다 이 작업은 기존 데이터가 있는 경우에만 수행된다  삭제가 완료되면 클라이언트를 결과 페이지로 리다이렉트한다sequenceDiagramshow(상세페이지)-&gt;&gt;+컨트롤러: /articles/{id}/delete컨트롤러-&gt;&gt;+리파지터리: delete(id)컨트롤러-&gt;&gt;+show(상세페이지): redirect:/articles  [Tip]결과 페이지로 리다이렉트할 때 클라이언트에게 삭제 완료 메시지를 띄워주고 싶다면 사용되는 클래스가 RedirectAttributes 이다 RedirectAttributes 객체의 addFlashAttribute()라는 메서드는 리다이렉트된 페이지에서 사용할 일회성 데이터를 등록할 수 있다&lt;상세 페이지&gt; 삭제 버튼 추가하기  show.mustache 파일{{&gt;layouts/header}}{{#article}}&lt;table class=\"table\"&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th scope=\"col\"&gt;Id&lt;/th&gt;        &lt;th scope=\"col\"&gt;Title&lt;/th&gt;        &lt;th scope=\"col\"&gt;Content&lt;/th&gt;        &lt;th scope=\"col\"&gt;Handle&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;th&gt;{{id}}&lt;/th&gt;        &lt;td&gt;{{title}}&lt;/td&gt;        &lt;td&gt;{{content}}&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;a href=\"/articles/{{article.id}}/edit\" class=\"btn btn-primary\"&gt;Edit&lt;/a&gt;&lt;a href=\"/articles/{{article.id}}/delete\" class=\"btn btn-danger\"&gt;Delete&lt;/a&gt;&lt;a href=\"/articles\"&gt;Go to Article List&lt;/a&gt;{{/article}}{{&gt;layouts/footer}}컨트롤러에서 삭제 요청에 따른 처리 만들기  ArticleController 파일    @GetMapping(\"/articles/{id}/delete\") //URL 요청 접수    public String delete(@PathVariable Long id, RedirectAttributes rttr) { //메서드 생성 및 null 값 반환        log.info(\"삭제 요청이 들어왔습니다!!\");        // 1. 삭제할 대상 가져오기        Article target = articleRepository.findById(id).orElse(null);        log.info(target.toString());        // 2. 대상 엔티티 삭제하기        if (target != null) { //삭제할 대상이 있는지 확인            articleRepository.delete(target); //delete() 메서드로 대상 삭제            rttr.addFlashAttribute(\"msg\", \"삭제됐습니다!\");        }        // 3. 결과 페이지로 리다이렉트하기        return \"redirect:/articles\";    }  [Tip]      삭제할 대상 가져오기 DB에 접근해 데이터를 처리할 때는 JPA의 리파지터리를 이용한다              articleRepository.findById(id) 메서드로 DB에 해당 id를 가진 데이터가 있는지 찾아서 만약 찾으면 Article 타입의 target 변수에 저장하고, 찾지 못하면 null을 반환        findById(id)를 호출할 때 사용한 id 변수는 delete() 메서드에 선언되지 않았다 이 id는 @GetMapping(\"/articles/{id}/delete\")의 URL 주소에서 가져오므로 delete() 메서드의 매개변수로 @PathVariable Long id를 써준다            "
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 3장",
    "url": "/posts/spring2/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-11-16 12:33:00 +0900",
    





    
    "snippet": "Part2. 스프링 부트 시작게시판 만들고 새 글 작성하기: Create폼 데이터  폼 데이터는 HTML 요소인 &lt;form&gt; 태그에 실려 전송되는 데이터를 말하며 웹 브라우저에서 서버로 데이터를 전송할 때 사용한다, &lt;form&gt;태그에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받는데 이 데이터를 DTO(Data Transf...",
    "content": "Part2. 스프링 부트 시작게시판 만들고 새 글 작성하기: Create폼 데이터  폼 데이터는 HTML 요소인 &lt;form&gt; 태그에 실려 전송되는 데이터를 말하며 웹 브라우저에서 서버로 데이터를 전송할 때 사용한다, &lt;form&gt;태그에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받는데 이 데이터를 DTO(Data Transfer Object)라 한다[FORM 태그 속성]폼 태그 속성에는 name, action, method, target 등이 있다1. action- 폼 내부에 입력 값들 전송하는(받는사람) 서버 측 URL을 지정한다- 데이터를 보내려면 브라우저가 전송 위치(URL)를 알아야 하기 때문에 이를 위해 action 속성을 사용한다1. name- 전송될 데이터의 이름1. accept-charset- 폼 전송에 사용할 문자 인코딩을 지정한다1. target- action에서 지정한 스크립트 파일을 현재 창이 아닌 다른 위치에 열도록 지정한다1. method (디폴트 값 = get)- 서버로 데이터를 전송하는 방식입니다.- get 방식 or post 방식이 존재한다    1) get 방식    - &lt;form method = \"get\"&gt; &amp; 링크 &amp;  URL 직접 &amp; 자바스크립트 등등    - URL의 끝에 데이터를 첨부해서 전송하는 방식        문제점    - 항상 노출이 된다. (보안에 중요한 데이터는 사용 금지)    - URL 최대 256자까지 (오버플로우 : 데이터 잘림)    - URL은 인코딩 방식이 base64(한글포함x)    - 되도록 영문과 숫자 정도만 전송     1) post 방식    - post 방식 : &lt;form method = \"post\"&gt; 유일    - 패킷의 본문 안에 데이터를 넣어서 전송하는 방식(FM 제대로 된 방식)    - 데이터 노출이 없음(보안상 조금 더 안전)    - 제한 크기 무제한    - 한글 상관없이 전송[Form데이터를 DTO객체로 저장하는 과정]graph LRA(01.뷰 페이지 만들기)--&gt;B[02.컨트롤러 만들기]B--&gt;C(03.DTO 만들기)graph LRD[04.전송 받은 폼 데이터로 DTO 객체에 담기]D--&gt;E(05.DTO를 엔티티로 변환하기)--&gt;F(06.리파지터리로 엔티티를 DB에 저장하기)뷰페이지 만들기[src/main/java/resources/templates/articles/new.mustache]컨트롤러 만들기[/src/main/java/controller/ArticleController][사용자에게 폼 데이터 입력할 수 있는 페이지 제공][사용자가 입력한 폼 데이터를 처리하는 라우트]DTO 만들기[/src/main/java/dto/ArticleForm][사용자에게 폼 데이터 입력할 수 있는 페이지 제공]전송 받은 폼 데이터로 DTO 객체에 담기[/src/main/java/controller/ArticleController][사용자에게 폼 데이터 입력할 수 있는 페이지 제공]폼 데이터와 DTO 필드 매핑하기DTO를 엔티티로 변환하기[엔티티 클래스 생성 /src/main/java/entity/Article]  DTO의 데이터를 받아서 처리하기 위해 엔티티 클래스를 생성한다  DTO 코드를 작성할 때와 같이 title, content 필드를 선언한다 두 필드도 DB에서 인식할 수 있게 @Column 어노테이션을 붙인다 두 필드가 DB 테이블의 각 열(column)과 연결된다  엔티티 클래스에 @Entity이 선언되어있는데 JPA에서 제공하는 어노테이션으로, 이 어노테이션이 붙은 클래스를 기반으로 DB에 테이블이 생성된다 테이블 이름은 클래스 이름과 동일하게 Article로 생성된다  엔티티의 대푯값을 넣는다 대푯값을 id로 선언하고 @Id 어노테이션을 붙입니다. 이어서 @GeneratedValue 어노테이션도 붙여서 대푯값을 자동으로 생성하게 한다(예: 1, 2, 3, …)리파지터리로 엔티티를 DB에 저장하기[리파지터리 인터페이스 생성하기 /src/main/java/repository/ArticleRepository][리파지터리로 엔티티를 DB에 저장하기 /src/main/java/controller/ArticleController]  JPA(Java Persistence API)는 자바 언어로 DB에 명령을 내리는 도구로, 데이터를 객체 지향적으로 관리할 수 있게 JPA의 핵심 도구로는 엔티티(entity)와 리파지터리(repository)가 있다      엔티티: 자바 객체를 DB가 이해할 수 있게 만든 것으로, 이를 기반으로 테이블이 만들어진다    리파지터리: 엔티티가 DB 속 테이블에 저장 및 관리될 수 있게 하는 인터페이스이다  [DTO를 DB에 저장하는 과정]graph LRA(클라이언트에서 데이터 생성)--&gt;B[컨트롤러에서 DTO에 담음]B--&gt;CC(DTO객체를 DB엔티티로 변환)--&gt;D[리파지터리에서 DB엔티티를 DB에 저장]"
  },
  
  {
    "title": "(코딩 자율학습 스프링 부트3) 1,2장",
    "url": "/posts/spring1/",
    "categories": "Framework, SpringBoot",
    "tags": "SpringBoot",
    "date": "2023-11-11 12:33:00 +0900",
    





    
    "snippet": "Part1. 스프링 부트 시작스프링 부트란?  스프링 부트(Spring Boot)는 자바 웹 프로그램을 더욱 쉽고 빠르게 만들기 위한 도구이다스프링 부트에는 자바 웹 프로그램을 만들기 위한 기능과 도구가 모여 있다스프링 부트 개발 환경 설정하기스프링 부트 개발 환경 설정에는 3단계로 이루어진다1단계 : JDK설치하기2단계 : IDE설치하기3단계 : 스...",
    "content": "Part1. 스프링 부트 시작스프링 부트란?  스프링 부트(Spring Boot)는 자바 웹 프로그램을 더욱 쉽고 빠르게 만들기 위한 도구이다스프링 부트에는 자바 웹 프로그램을 만들기 위한 기능과 도구가 모여 있다스프링 부트 개발 환경 설정하기스프링 부트 개발 환경 설정에는 3단계로 이루어진다1단계 : JDK설치하기2단계 : IDE설치하기3단계 : 스프링 부트 프로젝트 만들기JDK 다운로드 및 설치버전 확인하기  JDK란: 자바 개발 키드(Java Development Kit, JDK)는 개발자들이 JVM과 JRE에 의해 실행되고 구동될 수 있는 자바 프로그램을 생성할 수 있게 해준다      JDK 17버전 설치:JDK 다운로드 페이지    버전확인: CMD 터미널 창을 열고 java -version 입력하기IDE 설치  IDE란: 통합 개발 환경(Integrated Development Environment, IDE)는 개발자가 생산성을 높이기 위해 사용하며 코드를 효율적으로 개발하도록 도와주는 소프트웨어이다  IntelliJ IDE설치: IDE 다운로드 페이지스프링 부트 프로젝트만들기스프링 부트 프로젝트는 IDE를 통해서 만들 수 있지만 Spring Initializr 사이트를 통해서 조금 더 쉽게 프로젝트를 생성할 수 있다 Spring Initializr 페이지Gradle(그래이들)과 IntelliJ IDEA  Gradle는 Groovy를 이용한 오픈 소스 빌드 자동화 시스템이다 즉 빌드 도구라할 수 있는데 빠른 기간동안 계속해서 늘어나는 라이브러리의 추가 또는 프로젝트를 진행하며 수많은 라이브러리의 버전을 쉽게 동기화 하기 위해 등장한 것이다IntelliJ IDEA는 인텔리제이 자체에서 제공하는 빌드 자동화 도구이다      차이점 : IntelliJ IDEA는 증분 빌드이며 Gradle은 증분 빌드가 아니다 증분 빌드란 변경된 부분만 빌드를 하는 방식으로 변경되지 않은 것에 대해서는 건너뛰고 빌드를 진행해서 빠른 빌드를 원할 경우 선택하는 방법이다 (단, 정확한 빌드가 되지 않는 경우가 있어서 정확한 빌드를 원한다면 Gradle 빌드 방식을 사용할 것을 추천한다)  Gradle(그래이들)의 핵심 기능  Compile - Java 파일의 소스 코드를 컴퓨터가 이해할 수 있도록 바이트 코드로 변환  Test - 유닛 테스트, UI 테스트  Packaging - 스프링 코드를 패키징 해 .jar 파일이나 .war 파일로 생성  Deploy &amp; Run - 서버 실행뷰 템플릿뷰 템플릿 이란 화면을 담당하는 기술로, 웹 페이지(view)를 하나의 틀(Template)로 만들고 여기에 데이터 변수를 삽입해 서로 다른 페이지를 보여 준다머스테치(Mustache)라는 도구를 사용하면 인텔리제이에서 바로 뷰 템플릿을 생성할 수 있다MVC 패턴화면을 담당하는게 위와 같이 뷰(View)였다면 뷰는 컨트롤러와 모델이라는 두 동료가 있다컨트롤러(Controller)는 클라이언트의 요청에 따라 서버에서 이를 처리하는 역할이고,모델(Model)은 데이터를 관리하는 역할을 한다  웹 페이치를 화면에 보여준다(View)  클라이언트의 요청을 받아 처리한다(Controller)  데이터를 관리한다(Model)위와 같이 역할을 나누는 기법을 MVC(Model-View-Controller)패턴이라고한다어노테이션(annotation)소스 코드에 추가해 사용하는 메타 데이터의 일종으로 메타 데이터는 프로그램에서 처리해야 할 데이터가 아니라 컴파일 및 실행 과정에서 코드를 어떻게 처리해야 할지 알려주는 추가 정보이다"
  },
  
  {
    "title": "클래스와 인스턴스",
    "url": "/posts/class/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-11-10 12:33:00 +0900",
    





    
    "snippet": "Class  Class란      객체를 정의해 놓은 것    객체의 설계도 또는 툴    객체를 생성하는데 사용됨  Class를 사용하는 이유  Class란      코드의 재사용성이 높다 (새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다)    코드의 관리가 용이하다 (코드간의 관계를 이용해서 쉽게 코드를 변경할 수 있다)  ...",
    "content": "Class  Class란      객체를 정의해 놓은 것    객체의 설계도 또는 툴    객체를 생성하는데 사용됨  Class를 사용하는 이유  Class란      코드의 재사용성이 높다 (새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다)    코드의 관리가 용이하다 (코드간의 관계를 이용해서 쉽게 코드를 변경할 수 있다)    신뢰성이 높은 프로그래밍을 가능하게 한다  Class 정의 방법  Class는 객체를 정의하는 과정으로 클래스에는 객체의 모든 속성과 기능이 정의되어 있다class human {    // 속성(변수)    String job;     String sex;    String name;     int age;    // 기능(메서드)    void ageadd() { age++; }    void jobchange() { job=\"callmen\" }객체  객체는 실제로 존재하는 것 사물 또는 개념이다  객체의 용도는 객체가 가지고 있는 기능과 속성에 따라 달라진다  클래스에 정의된 내용대로 메모리에 생성된 것이다객체의 구성 요소들  속성(property)          멤버변수(member variable)      특성(attribute)      필드(field)      상태(state)        기능(function)          메서드(method)      함수(function)      행위(behavior)      객체 생성 방법위에서 생성한 Class를 사용해서 객체를 만드는 과정을 인스턴스화라고 하며 Class로부터 만들어진 객체를 해당 Class의 인스턴스라고 한다  객체 : 모든 인스턴스를 대표하는 포괄적인 의미  인스턴스 : 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미클래스명 참조변수명; // 클래스의 객체를 참조하기 위한 참조변수 선언참조변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장  new 연산자 : 인스턴스(객체)를 생성해주는 역할을 한다메모리(Heap 영역)에 데이터를 저장할 공간을 할당받고 그 공간의 참조값을 객체에게 반환하여 주고 생성자를 호출한다[객체 사용 과정]graph LRA(Class 정의하기 *설계도 그리기*)--&gt;B(Class를 사용해서 객체 생성하기 *설계도를 이용해서 물건 생산하기*)--&gt;C(만들어진 객체를 사용하기 *생산된 물건 사용하기*)"
  },
  
  {
    "title": "생성자와 this",
    "url": "/posts/constructor/",
    "categories": "Develop, Java",
    "tags": "Java",
    "date": "2023-11-10 12:33:00 +0900",
    





    
    "snippet": "생성자      인스턴스(객체)가 생성될 때 호출되는 인스턴스(객체) 초기화 메서드    인스턴스 초기화란 인스턴스 변수들을 초기화하는 것    대부분 객체의 초기화를 목적으로 사용한다  인스턴스 생성 과정graph LRA(new연산자를 통해서 메모리heap영역에 인스턴스 생성)--&gt;B(생성자가 호출되어 실행)--&gt;C(new연산자 결과로 해...",
    "content": "생성자      인스턴스(객체)가 생성될 때 호출되는 인스턴스(객체) 초기화 메서드    인스턴스 초기화란 인스턴스 변수들을 초기화하는 것    대부분 객체의 초기화를 목적으로 사용한다  인스턴스 생성 과정graph LRA(new연산자를 통해서 메모리heap영역에 인스턴스 생성)--&gt;B(생성자가 호출되어 실행)--&gt;C(new연산자 결과로 해당 객체의 주소가 변환되어 참조변수에 저장된다)생성자의 제약조건      생성자의 이름은 클래스의 이름과 같아야한다    생성자는 다른 함수와는 다르게 리턴 값이 없다    생성자는 객체가 생성될때 자동으로 한번 호출된다    생성자는 매개변수 조건에 따라 여러개를 작성할 수 있다(오버로딩)  생성자의 종류매개변수가 있는 생성자class human {    String name;    String job;    int age;     Car() {} // 기본 생성자    Car(String c, String g, int d) { // 생성자            name = c;        job = g;        age = d;    }}생성자를 사용하지 않고 객체에 데이터를 직접 넣을때// 생성자를 사용하지 않았을 때human h = new human();h.name = \"parkdongwon\";h.job = \"student\";h.age = 16;        생성자를 사용하여 객체에 데이터를 직접 넣을때human h = new human(\"parkdongwon\", \"student\", 16);this  this는 객체 즉 자기자신을 나타낸다 this를 사용하는 경우는 아래와 같다this를 사용하는 경우(클래스의 속성과 생성자/메소드의 매개변수의 이름이 같은 경우)  아래 소스와 같이 생성자에서 받는 매개변수의 이름과 클래스의 변수 이름이 같을 경우 java는 매개변수인지 클래스 변수인지 인식을 하지 못해서 값을 제대로 반영하지 못한다// this를 사용하지 않아서 이슈된 코드public class human {    public String name;    public String job;    public int age;    public human(String name, String job, int age) {        name = name;        job = job;        age = age;    }    public static void main(String[] args) {        human h = new human(\"parkdongwon\", \"student\", 16);        System.out.println(\"name: \" + h.name); // name: null        System.out.println(\"job: \" + h.job); // job: null        System.out.println(\"age: \" + h.age); // age: 0    }}// this를 사용해서 정상화된 코드public class human {    public String name;    public String job;    public int age;    public human(String name, String job, int age) {        this.name = name;        this.job = job;        this.age = age;    }    public static void main(String[] args) {        human h = new human(\"parkdongwon\", \"student\", 16);        System.out.println(\"name: \" + h.name); // name: parkdongwon        System.out.println(\"job: \" + h.job); // job: student        System.out.println(\"age: \" + h.age); // age: 16    }}this를 사용하는 경우(클래스에 오버로딩된 다른 생성자 호출)  아래 소스와 같이 생성자가 여러개인 오버로딩된 경우 생성자가 다른 생성자를 호출할때는 this를 사용하여 호출한다  오버로딩 이란 너무 많이 적재했다(Overloading)는 뜻을 가진 단어로 같은 이름의 메서드에 매개변수의 타입, 개수를 다르게 한 것을 말한다// this를 사용하는 경우 (클래스에 오버로딩된 다른 생성자 호출)public class human {    public String name;    public String job;    public int age;    public human(String name, int age) {        // human(String name, String job, int age)를 호출        this(name, \"student\", age);    }        public human(String name, String job, int age) {        this.name = name;        this.job = job;        this.age = age;    }    public static void main(String[] args) {        human h = new human(\"parkdongwon\", \"student\", 16);        System.out.println(\"name: \" + h.name); // name: parkdongwon        System.out.println(\"job: \" + h.job); // job: student        System.out.println(\"age: \" + h.age); // age: 16    }}객체 자신의 참조값을 전달하고 싶을 때// this를 사용하는 경우 (객체 자신의 참조값을 전달하고 싶을 때)public class human {    public String name;    public String job;    public int age;        public human(String name, String job, int age) {        this.name = name;        this.job = job;        this.age = age;    }    //  어떤 메소드에서는 동작을 완료하고 리턴값으로 메소드의 매개변수로 객체, 자기 자신의 참조값을 전달하고 싶어하는 경우    public human getHumanInstance() {            return this;        }   }"
  },
  
  {
    "title": "(인터랙티브 웹 페이지 만들기) Chapter5",
    "url": "/posts/chap5/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-10-22 12:33:00 +0900",
    





    
    "snippet": "Chap1. 자바 스크립트 시작하기  자바 스크립트를 사용하기 위해서는 HTML 파일 내부에 스크립트 코드를 작성하거나, 외부의 자바스크립트 파일을 만들어서 HTML 파일과 연동해야 한다자바와 자바스크립트의 차이는 무엇일까?            구분      자바      자바스크립트                  객체지향      자바는 객체지향 프...",
    "content": "Chap1. 자바 스크립트 시작하기  자바 스크립트를 사용하기 위해서는 HTML 파일 내부에 스크립트 코드를 작성하거나, 외부의 자바스크립트 파일을 만들어서 HTML 파일과 연동해야 한다자바와 자바스크립트의 차이는 무엇일까?            구분      자바      자바스크립트                  객체지향      자바는 객체지향 프로그래밍 언어이며 객체들 사이의 관계를 기반으로 특정한 행동들이 이루어진다      자바스크립트는 객체지향 스크립트 언어이다 객체를 이용한다는 부분은 자바와 동일하다              실행환경      자바 애플리케이션이나 프로그램은 자바 가상기계(JVM) 위에서 실행된다 JVM환경을 생성하기 위해서는 시스템에 JRE, JDK를 설치해야 한다      자바스크립트 웹 애플리케이션은 웹 브라우저 위에서 실행되며 추가적인 환경 설정은 필요하지 않다              모바일 애플리케이션      초기의 휴대전화용 애플리케이션들은 대부분 자바로 작성되어있으며, 안드로이드와 심비안 같은 스마트폰 운영체제에서도 자바를 지원하고 있다      자바스크립트를 이용해서 모바일 애플리케이션을 만들려면 만들 수는 있지만 몇 가지 제약이 있다, 자바 스크립트를 모바일 또는 운영체제에서 실행하려면 네이티브 코드로 변환이 필요하다              컴파일      자바는 프로그래밍 언어로 컴퓨터가 이해할 수 있도록 컴파일이 되어야 한다      자바스크립트는 텍스트로 쓰인 코드로도 실행될 수 있는 스크립트 언어이다      HTML 파일 내부에 자바스크립트 연결하기[Console 기능을 활용하여 실습]&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;&lt;script&gt;console.log(\"Hello world\");&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;  위와 같이 &lt;body&gt; 영역보다 상위인 &lt;head&gt; 영역에 자바스크립트를 넣으면 실행은 되지만웹 브라우저는 HTML 파일을 위에서부터 순서대로 코드를 읽기 때문에 &lt;body&gt;영역을 자바스크립트가 알지 못한다(먼저 생성되었기 때문)[Error 예제]Check Example code html.&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;script&gt;const title = document.querySelector(\"#title\");console.log(title);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=\"title\"&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;  위 소스 또한 head에서 먼저 변수를 선언해서 title이라는 식별 데이터를 가져와서 정의하려 했지만 body영역이 생성되기 전이기 때문에 null 값이 들어간다[수정 예제]Check Example code html.ex02&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=\"title\"&gt;Hello World&lt;/h1&gt;&lt;script&gt;const title = document.querySelector(\"#title\");console.log(title);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;HTML 파일과 외부 자바스크립트 연결하기[ 외부 자바스크립트 예제 1 ]Check Example code html.ex03&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=\"title\"&gt;Hello World&lt;/h1&gt;&lt;script src=\"/script/script.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;  위 방법은 script 파일을 분리 후 body안에 script 파일을 불러오는 방식으로 예전에는 사용하였으나 요즘은 사용하지 않는 방식이다 최근 실무에서는 아래 예제 2번과 같이 사용한다[ 외부 자바스크립트 예제 2 ]Check Example code html.ex04&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;script defer src=\"/script/script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=\"title\"&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;  위 방식은 head 부분에 외부 스크립트를 정의하여 사용하는 방식으로 body 영역을 다 실행한 후 해당 스크립트를 실행한다Chap2. 자바 스크립트로 HTML 요소 선택하기document.querySelector()  querySelector란 무엇?자바 스크립트에서 Html의 클래스 이름 및 태그(요소)를 갖고 오기 위해서 querySelector를 많이 사용한다 단일 요소는 바로 탐색할 수 있지만 요소를 여러개 탐색하려면 하기 querySelectorAll을 이용하는것이 효과적이다const box2 = document.querySelector(\"#wrap .box2\");console.log(box2);&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;script defer src=\"/script/script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;section id=\"wrap\"&gt;&lt;article class=\"box1\"&gt;Text1&lt;/article&gt;&lt;article class=\"box2\"&gt;Text2&lt;/article&gt;&lt;article class=\"box3\"&gt;Text3&lt;/article&gt;&lt;/body&gt;&lt;/html&gt;document.querySelectorAll()  querySelectorAll란 무엇?querySelectorAll문을 이용해서 요소를 여러개 탐색하면 NodeList라는 묶음의 결괏값이 나온다 해당 Nodelist를 사용해서 반복문으로 요소를 하나씩 선택할 수 있다const items = document.querySelector(\"#wrap .article\");for(let item of items){console.log(item);}&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;script defer src=\"/script/script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;section id=\"wrap\"&gt;&lt;article class=\"box1\"&gt;Text1&lt;/article&gt;&lt;article class=\"box2\"&gt;Text2&lt;/article&gt;&lt;article class=\"box3\"&gt;Text3&lt;/article&gt;&lt;/body&gt;&lt;/html&gt;변수  데이터를 저장하는 공간을 변수라고하며 다양한 데이터를 지정하고 담게 되는데 어떤 데이터를 담을것인지를 자료형에 따라 지정된다변수명 네이밍 표기법  헝가리안 표기법(hungarian case)  카멜 표기법(camelcase)  파스칼 표기법(pascal case)  언더바 표기법(snake_case)      헝가리안 표기법(hungarian case)Microsoft 사의 한 헝가리인 개발자가 사용하던 변수명에서 유래된 변수명이다변수의 자료형을 변수명의 접두어로 붙이는 방식으로 간단하게 변수명만 보고 자료형을 인식할 수 있는 방식가독성이 떨어지고 최근에는 개발도구의 발전으로 많이 쓰이지 않는 방식      * 헝가리안 표기법 *public int intMem;private String strAdd;                  카멜 표기법(camelcase)단어와 단어 사이를 대문자로 구분하는 표기법이며 낙타의 혹을 닮아서 낙타(camel) 표기법으로 명명되었다 즉, 첫 단어만 소문자로 지정하고 단어와 단어 사이 뒤의 단어의 첫 글자를 대문자로 표기한다      * 카멜 표기법 *public int myMemCount;private String myHomeAdd;                  파스칼 표기법(pascal case) 모든 단어의 첫 글자만을 대문자로 표기한다      * 파스칼 표기법 *public int MyMemCount;private String MyHomeAdd;                  언더바 표기법(snake_case) 단어와 단어 사이에 _(언더바)를 이용해서 구분 표기한다      * 언더바 표기법 *public int My_Mem_Count;private String My_Home_Add;            변수 초기화(Initialize)  변수를 선언하고 값을 넣지 않으면 해당 변수에는 아무 의미없는, 알수없는 값이 들어 있으며 흔히 쓰레기 값 혹은 NULL값 이라고 부른다변수선언과 함께 데이터를 넣어주는것을 변수선언과 함께 초기화(Initialize)한다고 하며 초기화시 얻는 이점은 아래와 같다  Null값으로 인한 이슈로부터 해방된다  예기치못한 이슈로부터 해방된다자바스크립트로 스타일 제어하기  HTML요소를 자바스크립트를 활용해서 선택 후 변수에 데이터를 넣고 해당 변수를 활용하여 HTML요소의 스타일을 제어해본다const box2 = document.querySelector(\"#wrap .box2\");box2.style.width = \"10%\";box2.style.height = \"200px\";box2.style.backgroundColor = \"blue\";&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;script defer src=\"/script/script.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;section id=\"wrap\"&gt;&lt;article class=\"box1\"&gt;Text1&lt;/article&gt;&lt;article class=\"box2\"&gt;Text2&lt;/article&gt;&lt;article class=\"box3\"&gt;Text3&lt;/article&gt;&lt;/body&gt;&lt;/html&gt;자바스크립트로 이벤트 연결하기자바스크립트를 사용해서 웹 페이지를 출력한 이후에도 사용자 행동(이벤트)에 따라 웹의 요소를 동적으로 변경할 수 있다클릭 이벤트 연결하기[ 자바스크립트 클릭 이벤트 예제 ]Check Example code html.const link = document.querySelector(\"a\");link.addEventListener(\"click\", (e)=&gt;{e.preventDefault();console.log(\"링크를 클릭함!\");})&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content =\"ie=edge\"&gt;&lt;title&gt;Javascript&lt;/title&gt;&lt;script defer src=\"/script/ex05.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"https://www.naver.com\"&gt;click&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;  addEventListener란 무엇? 위 예제 스크립트 소스에서 link 변수에 담겨 있는 a 요소에 .addEventListener() 문을 연결해서 클릭이벤트를 지정했는데 해당 addEventListener 문은 요소명.addEventListener(“이벤트명”,(전달될 값) =&gt; {실행할 구문});으로 사용한다(이벤트명)은 등록할 이벤트명을 임의로 지정하면 되며 (전달될 값)은 리스너로 불리며 이벤트가 발생할 때 응답해서 실행할 동작은 의미한다  preventDefault란 무엇? 이벤트가 발생하면 자동으로 이벤트 객체라는 값이 화살표 함수로 자동 전달하게되는데 preventDefault문은 이벤트의 기능을 실행하지말라는 명령어호버 이벤트 연결하기[ 자바스크립트 호버 이벤트 예제 ]Check Example code html./* 이벤트 변환시 마다 체크 addEventListener */var box = document.getElementById('box');//마우스 오버box.addEventListener('mouseover',function(){box.setAttribute('class','hover');});//마우스 아웃box.addEventListener('mouseout',function(){box.removeAttribute('class');});&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;hover(mouseover + mouseout)&lt;/title&gt;&lt;style&gt;#box{width:100px; height: 100px;border:3px solid black;}#box.hover{    background:orange;    color:white;}&lt;/style&gt;&lt;script defer src=\"/script/ex06.js\"&gt;&lt;/script&gt;        &lt;/head&gt;&lt;body&gt;&lt;div id=\"box\"&gt;&lt;p&gt;마우스를 올려 주세요&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;  setAttribute란 무엇? .setAttribute()는 선택한 요소(element)의 속성(attribute) 값을 정한다요소명.setAttribute( ‘attributename’, ‘attributevalue’ )문법이며 attributename에는 속성 이름을, attributevalue에는 속성값을 넣는다요소의 속성을 제거하기 위해서는 .removeAttribute() 메서드를 사용한다자바스크립트로 클래스 제어하기자바스크립트로 HTML 요소를 선택해서 변수에 저장한 다음 이벤트를 연결하여 스타일을 변경하는일은 실무에서 사용되지 않는다CSS파일에서 정의한 스타일 구문이 우선순위에서 밀려나기 때문에 유지보수에 문제가 발생할 수 있기 때문이다따라서 실무에서는 CSS파일에 특정 클래스 이름에 따라 스타일이 설정되게 정의하고 자바스크립트에서는 해당 CSS파일의 클래스 이름만 추가 또는 제거하는방법으로 스타일을 변경한다[ 자바스크립트 클래스 제어 예제 ]Check Example code html.#wrap {width: 500px;height: 500px;border: 1px;padding: 100px;box-sizing: border-box;margin: 100px auto;}#wrap article{width: 100%;height: 100%;background: aqua;transition: 1s;}#wrap.on article {background: hotpink;}const wrap = document.querySelector(\"#wrap\");const box = wrap.querySelector(\"article\");wrap.addEventListener(\"click\", () =&gt; {//box.style.backgroundColor = \"hotpink\";//wrap.classList.add(\"on\");let isOn = wrap.classList.contains(\"on\"); //classList.contains는 특정 클래스가 선택 요소에 있으면 true 없으면 false를 반환해주는 내장 모듈이다console.log(isOn);if(isOn){wrap.classList.remove(\"on\");}else{wrap.classList.add(\"on\");}})&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Javascript Test&lt;/title&gt;&lt;script defer src=\"/script/ex07.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"./css/ex07.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;section id=\"wrap\"&gt;&lt;article&gt;&lt;/article&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;함수를 활용하여 코드 패키징하기함수 정의 및 호출로 기능 재활용하기자주 쓰는 코드를 매번 다시 입력하는것이 아닌 코드를 함수로 패키징해서 재활요하는 방법에대해 알아본다함수란 자주 실행하는 코드를 function 키워드와 임의의 이름을 붙여서 정의한 코드의 묶음이다function plus (num1, num2){console.log(num1 + num2);}plus(2,3);매개변수란 함수 외부에서 내부로 값을 전달하여 받을 수 있는 임시 데이터 공간이라고 볼 수 있다인수란 매개변수를 통해 실제 함수 외부에서 내부로 전달되는 값을 인수(argument) 또는 파라미터라고 불린다[ 자바스크립트 함수를 활용하여 코드 패키징 예제 ]Check Example code html./*버튼 비활성화 */ul li{color: gray;cursor: pointer;}/*버튼 활성화 */ul li.on{color: blueviolet;cursor: pointer;}section {width: 300px;height: 200px;border: 1px solid #888;margin: 50px;position: relative;perspective: 600px; /* 원근감 설정 */}/*박스 비활성화 */section article{width: 100%;height: 100%;position: absolute;top: 0px;left: 0px;display: flex;justify-content: center;align-items: center;color: #fff;font-size: 50px;opacity: 0;transform: rotateY(-180deg);transition: 0.5s;}/*박스 활성화 */section article.on {opacity: 1;transform: rotateY(0deg);}/*박스 순서별로 배경색 지정 */section article:nth-of-type(1){background: aqua;}section article:nth-of-type(2){background: hotpink;}section article:nth-of-type(3){background: orange;}const btns = document.querySelectorAll(\".btns li\");const boxs = document.querySelectorAll(\"section article\");// 버튼의 개수만큼 반복하며 클릭 이벤트 연결for(let i=0; i&lt;btns.length; i++){// 각 버튼을 클릭할 때마다btns[i].addEventListener(\"click\", e=&gt;{//각 인수로 순섯값과 버튼, 박스 그룹을 넣어서//activation 함수 호출activation(i, btns);activation(i, boxs);})}// 1번째 인수로 순섯값, 2번째 인수로 그룹을 전달받아function activation(index, list){//인수로 받은 요소의 그룹 개수만큼 반복하며 비활성화for(let el of list){el.classList.remove(\"on\");}//1번째 인수로 받은 순서에 해당하는 그룹의 요소만 찾아서 활성화list[index].classList.add(\"on\");}&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Javascript Test&lt;/title&gt;&lt;script defer src=\"/script/ex08.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" href=\"./css/ex08.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=\"btns\"&gt;&lt;li class =\"on\"&gt;button1&lt;/li&gt;&lt;li&gt;button2&lt;/li&gt;&lt;li&gt;button3&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;article class =\"on\"&gt;BOX1&lt;/article&gt;&lt;article&gt;BOX2&lt;/article&gt;&lt;article&gt;BOX3&lt;/article&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;HTML 요소의 속성값 제어하기HTML 요소에는 단지 태그만 있는 것이 아닌 태그의 src, alt, href 같은 다양한 속성값이 존재하는데 자바스크립트에서 해당 속성값들을 제어가 가능하다[ 자바스크립트로 HTML요소의 속성값 제어하기 예제 ]Check Example code html.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Javascript Test&lt;/title&gt;&lt;script defer src=\"/script/ex09.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"https://www.naver.com\"&gt;네이버&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;const link = document.querySelector(\"a\");let link_href = link.getAttribute(\"href\");console.log(link_href)const new_href = \"https://www.google.com\";link.setAttribute(\"href\", new_href);let link_href = link.getAttribute(\"href\");console.log(link_href);자바스크립트로 사용자 브라우저 판단하기모든 브라우저에는 navigator라는 객체가 있는데 이 객체 안에는 userAgent가 존재하고 여기에는 브라우저의 정보값이 문자 형태로 저장되어있다해당 객체를 활용해서 자바스크립트로 사용자가 어떤 브라우저로 웹 페이지에 접속하는지 확인이 가능하다[ 자바스크립트로 사용자 브라우저 판단하기 예제 ]Check Example code html.const version = navigator.userAgent;console.log(version);const isIE = /Edg/i.test(version);console.log(isIE);if(isIE){    alert(\"해당 브라우저는 Edge브라우저 입니다 이 웹 페이지는 크롬에서만 사용하실 수 있습니다\")}&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Javascript Test&lt;/title&gt;&lt;script defer src=\"/script/ex10.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"https://www.naver.com\"&gt;네이버&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "(Debian12) apache 멀티 포트 서비스 설정",
    "url": "/posts/apache_port_set/",
    "categories": "Framework, Apache",
    "tags": "Apache",
    "date": "2023-10-15 12:33:00 +0900",
    





    
    "snippet": "  해당 문서는 Debian12에서 테스트하여 작성된 문서이며 타OS에서는 설정 및 구동방식이 다를 수 있음/etc/apache2/ports.conf 수정/etc/apache2/ports.conf 수정 서비스할 포트들 Listen 추가# If you just change the port or add more ports here, you will lik...",
    "content": "  해당 문서는 Debian12에서 테스트하여 작성된 문서이며 타OS에서는 설정 및 구동방식이 다를 수 있음/etc/apache2/ports.conf 수정/etc/apache2/ports.conf 수정 서비스할 포트들 Listen 추가# If you just change the port or add more ports here, you will likely also# have to change the VirtualHost statement in# /etc/apache2/sites-enabled/000-default.confListen 80Listen 8080&lt;IfModule ssl_module&gt;        Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt;        Listen 443&lt;/IfModule&gt;/etc/apache2/sites-available/000-default.conf 수정/etc/apache2/sites-available/000-default.conf 수정 서비스할 디렉토리 경로 및 옵션 추가&lt;VirtualHost *:80&gt;        ServerName www.site1.kr        ServerAlias site1.kr        DocumentRoot /var/www/site1        &lt;Directory /var/www/site1&gt;                Options Indexes FollowSymLinks MultiViews                AllowOverride All                Order allow,deny                allow from all        &lt;/Directory&gt;        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined&lt;/VirtualHost&gt;&lt;VirtualHost *:8080&gt;        ServerName www.site2.kr        ServerAlias site2.kr        DocumentRoot /var/www/site2        &lt;Directory /var/www/site2&gt;                Options Indexes FollowSymLinks MultiViews                AllowOverride All                Order allow,deny                allow from all        &lt;/Directory&gt;        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined&lt;/VirtualHost&gt;/etc/apache2/apache2.conf 수정/etc/apache2/apache2.conf 수정 서비스할 디렉토리 경로 및 옵션 추가&lt;Directory /var/www/&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted&lt;/Directory&gt;&lt;Directory /var/www/site2&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted&lt;/Directory&gt;/etc/apache2/ports.conf 수정/etc/apache2/ports.conf 수정 서비스할 포트들 Listen 추가# If you just change the port or add more ports here, you will likely also# have to change the VirtualHost statement in# /etc/apache2/sites-enabled/000-default.confListen 80Listen 8080&lt;IfModule ssl_module&gt;        Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt;        Listen 443&lt;/IfModule&gt;Apache 설정 테스트 및 재구동sudo apachectl configtestsudo systemctl restart apache2Listen Port 정상 확인sudo ss -lntp | grep apache2"
  },
  
  {
    "title": "(인터랙티브 웹 페이지 만들기) Chapter4",
    "url": "/posts/chap4/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-10-15 12:33:00 +0900",
    





    
    "snippet": "Chap1. flex 방식으로 레이아웃 만들기  앞서배운 float을 활용한 레이아웃 배치에 이어서 더욱 더 편리하게 레이아웃을 만들 수 있는 flex방식이 있다Flex(플랙스)는 Flexible Box, Flexbox라고 불리기도한다flex의 기본[Flex의 기본 레이아웃]&lt;div class=\"container\"&gt;&lt;div class=...",
    "content": "Chap1. flex 방식으로 레이아웃 만들기  앞서배운 float을 활용한 레이아웃 배치에 이어서 더욱 더 편리하게 레이아웃을 만들 수 있는 flex방식이 있다Flex(플랙스)는 Flexible Box, Flexbox라고 불리기도한다flex의 기본[Flex의 기본 레이아웃]&lt;div class=\"container\"&gt;&lt;div class=\"item\"&gt;flex item&lt;/div&gt;&lt;div class=\"item\"&gt;flex item&lt;/div&gt;&lt;div class=\"item\"&gt;flex item&lt;/div&gt;&lt;/div&gt;부모 요소의 div.container를 Flex Container라고 부르며 자식 요소인 div.item들을 Flex Item이라고 부른다[속성]  display : flex container를 정의한다  flex-flow : flex-direction와 flex-wrap의 단축 속성  flex-direction : flex items의 주 축을 설정한다  flex-wrap : flex items의 여러 줄 묶음 설정  justify-content : 주 축의 정렬 방법을 설정한다  align-content : 교차 축의 정렬 방법을 설정한다  align-items : 교차 축에서 items의 정렬 방법을 설정한다display 속성 사용하기  자식 요소(Flex Item)를 감싸는 부모 요소(Flex Container)에 display: flex 혹은 display: inline-flex 속성값을 사용하여 이 요소들이 Flexbox 레이아웃임을 선언한다&lt;style&gt;.container { display: flex;}&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt;&lt;/div&gt;flex-direction 속성 사용하기  자식 요소를 어떤 방향성을 가지고 배치 할 지 결정하는 기본축을 선언한다. 이 기본축이 가로냐 세로냐에 따라 후속 속성들의 정렬축이 결정된다기본값은 row, 측방은 가로다 따라서 모든 자식 요소가 가로로 배치된다column의 측방은 세로이며 모든 자식 요소가 세로로 배치된다&lt;style&gt;.container { display: flex;flex-direction: row;}&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;...&lt;/div&gt;justify-content 속성 사용하기  기본축 방향으로 자식 요소를 정렬한다. 혼동하기 쉬운 요인은 아래와 같으니 유의한다.아래 예제에서 자식 요소들이 가로로 배치되어 있다고 해서 justify-content 속성이 반드시 수평 방향으로만 정렬하는 것은 아니다. flex-direction의 기본축(row, column)에 따라 수평, 수직으로 방향성이 바뀐다. 난해하다면 더 아래 align-items 설명에서 추가 예문을 참고한다.만일 자식 요소가 부모 요소의 공간에 꽉 차게 배치되어 있다면 아무런 효과를 볼 수 없다.&lt;style&gt;.container { display: flex;flex-direction: row;flex-wrap: nowrap;justify-content: flex-start;}&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;...&lt;/div&gt;align-items 속성 사용하기  기본축의 교차축(반대 축) 방향으로 자식 요소를 정렬한다. 혼동하기 쉬운 요인은 아래와 같으니 유의한다.align-items 속성이 반드시 수직 방향으로만 정렬하는 것은 아니다. flex-direction에서 선언한 기본축의 반대 방향으로 정렬한다.만일 자식 요소가 부모 요소의 공간에 꽉 차게 배치되어 있다면 아무런 효과를 볼 수 없다. 아래 예문에서도 일부 속성값에서 그런 현상을 볼 수 있다.여기에 소개한 flex-flow 속성은 flex-direction, flex-wrap 속성의 단축 속성이다.&lt;style&gt;.container { display: flex;flex-flow: row nowrap;align-items: stretch;}  /* baseline 이해를 돕기 위한 가시성 선언 */.container div:nth-child(1) { padding: 10px 40px 0 40px }.container div:nth-child(2) { padding: 20px 40px }.container div:nth-child(3) { padding: 10px 40px 80px 40px }.container div:nth-child(4) { padding: 40px 40px 20px 40px }.container div:nth-child(5) { padding: 20px 40px 10px 40px }&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;...&lt;/div&gt;align-content 속성 사용하기  flex-wrap: wrap 속성에 의해 줄넘김 된 요소를 개별 단위에서 하나의 그룹 단위로 묶는다. 자식 요소가 줄넘김 없이 한 줄로만 이루어진 경우에는 아무 효과가 없다.justify-content, align-items 속성값을 한꺼번에 가지고 있으며, 정렬 알고리즘은 align-items와 같이 기본축의 교차(반대) 방향이다.&lt;style&gt;.container { display: flex;flex-flow: row nowrap;align-content: stretch;}&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;...&lt;/div&gt;flex-wrap 속성 사용하기  자식 요소의 줄넘김을 처리한다. 기본값은 nowrap으로 줄넘김 하지 않는다.값이 wrap인 경우, 기본적으로 자식 요소 크기의 합이 부모 요소보다 클 때 줄넘김 하는데,100px 크기의 자식 요소가 10개 있다(총 1000px)부모 요소의 크기는 700px이다.부모 요소에 7개의 자식 요소가 한 행을 이루고 나머지 3개의 요소는 개행한다.&lt;style&gt;.container { display: flex;flex-direction: row;flex-wrap: nowrap;}&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;  ...&lt;/div&gt;자식 요소의 순서 지정하기  컨테이너 안에서 아이템이 나열되는 순서를 나타낸다. 숫자가 작을수록 앞에, 클수록 끝에 위치한다. 음수 사용이 가능하며, 음수가 클수록 앞에 위치한다.order 속성이 선언되면, HTML이나 CSS에서 구문을 어떤 순서에 따라 작성했는지와 상관없이, 오직 order에 선언된 값에 의해서만 순서가 정해진다&lt;style&gt;.container { display: flex;flex-flow: row nowrap;}    /* 화면 크기가 768px 이하면 끝으로 */@media screen and (max-width: 768px) {.container { flex-direction : column }.last-with-mobile { order: 1 }}&lt;/style&gt;&lt;div class=\"container\"&gt;&lt;div class=\"last-with-mobile\"&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;...&lt;/div&gt;요소의 여백 비율 지정하기"
  },
  
  {
    "title": "(인터랙티브 웹 페이지 만들기) Chapter3",
    "url": "/posts/chap3/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-10-07 12:33:00 +0900",
    





    
    "snippet": "Chap1. 웹 페이지의 배경 꾸미기   태그 영역마다 배경색과 이미지를 넣을 수 있다Chap1-1. 배경색 지정하기배경색은 background-color 속성을 사용해서 태그에 직접 지정할 수 있다            속성명      속성값      설명                  background-color      영문명rgb(0,0,0)#...",
    "content": "Chap1. 웹 페이지의 배경 꾸미기   태그 영역마다 배경색과 이미지를 넣을 수 있다Chap1-1. 배경색 지정하기배경색은 background-color 속성을 사용해서 태그에 직접 지정할 수 있다            속성명      속성값      설명                  background-color      영문명rgb(0,0,0)#000000      배경색을 영어 색상명으로 적용배경색을 RGB 표기법으로 적용배경색을 16진수 표기법으로 적용        See the Pen   background-color by mon node (@mon-node)  on CodePen.Chap1-2. 배경 이미지 적용하기            속성명      속성값      설명                  &lt;background-image&gt;      url(이미지 경로      배경 이미지를 삽입              &lt;background-repeat&gt;      repeat, repeat-x, repeat-y, no-repeat      배경 이미지를 반복              &lt;background-position&gt;      가로축, 세로축      배경 이미지의 위치를 지정              &lt;background-size&gt;      contain, cover      배경 이미지의 크기를 지정              &lt;background-attachment&gt;      fixed      배경 이미지가 움직이지 않게 고정        See the Pen   background-image by mon node (@mon-node)  on CodePen.Chap2. 웹 페이지의 레이아웃 구성하기  집의 공간을 거실, 주방, 서재등 사용 목적에 나누듯이 웹 페이지도 시맨틱 태그를 통해 레이아웃을 분리해본다Chap2-1. float을 사용하여 블록 요소 좌우로 배치하기  float 속성은 블록 요소를 강제로 띄워서 화면에 좌우로 배치가 가능하다            속성명      속성값      설명                  &lt;float&gt;      leftright      요소를 띄워서 왼쪽에 배치한다요소를 띄워서 오른쪽에 배치한다        See the Pen   웹 페이지의 레이아웃 구성_float 예제 by mon node (@mon-node)  on CodePen.위와 같이 section 요소가 좌우로 잘배치되었지만 부모 요소인 .wrap가 자식 요소의 높잇값을 인식하지 못해 테두리를 감싸지 못했다 인식 시키기위해서는 하기와 같이 가상 선택자를 생성한다.wrap::after{    content: '';    display: block;    clear: both;}Chap2-2. position 블록 요소 자유롭게 배치하기  position 속성은 여러 요소를  순서와 상관없이 화면에 가로세로 좌푯값을 설정해서 자유롭게 배치가 가능하다            속성명      속성값      설명                  &lt;position&gt;      relativeabsolutefixed      적용된 요소의 현재 위칫값을 기준으로 상대 위치를 지정부모 요소의 특정 구간을 기준으로 절대 위치를 지정한다웹 브라우저를 기준으로 절대 위치를 지정한다      [position-relative]  See the Pen   웹 페이지의 레이아웃 구성_position 예제 by mon node (@mon-node)  on CodePen.  relative는 요소를 일반적인 문서 흐름에 따라 배치하되, 상하좌우 위치 값에 따라 오프셋(위치를 얼마간 이동시킬 것인지)을 적용한다[position-absolute]  See the Pen   웹 페이지의 레이아웃 구성_position-absolute 예제 by mon node (@mon-node)  on CodePen.  absolute는 일반적인 문서 흐름에서 제거하고, 가장 가까운 position 지정 요소(position 속성에 속성값이 정의되어 있는 요소)에 대해 상대적으로 오프셋(위치를 얼마간 이동시킬 것인지)을 적용한다[position-fixed]  See the Pen   웹 페이지의 레이아웃 구성_position-fixed예제 by mon node (@mon-node)  on CodePen.  fixed는 웹 브라우저 기준으로 좌푯값이 고정된다Chap2-3. object-fit을 사용하여 콘텐츠를 특정 영역에 채우기  object-fit 속성을 사용하면 부모 요소 영역에서 자식 요소로 지정한 이미지, 동영상 등 콘텐츠의 비율을 설정할 수 있다            속성명      속성값      설명                  &lt;object-fit&gt;      fillcovercontain      요소의 비율을 무시하고 가득 채움요소의 비율을 유지하면서 여백 없이 가득 채움요소의 비율을 유지하면서 콘텐츠가 잘리지 않게 가득 채움        See the Pen   웹 페이지의 레이아웃 구성_object-fit예제 by mon node (@mon-node)  on CodePen.Chap2-4. z-index을 사용하여 겹쳐 있는 요소의 z축 순서를 지정하기  z-index를 사용하여 겹친 요소의 z축 순서를 강제로 지정할 수 있다            속성명      속성값      설명                  &lt;z-index&gt;      순섯값      요소에 z축의 순서를 지정한다(값이 큰 요소가 위로 올라감)      --css--.wrap .left{    width: 200px;    height: 200px;    background-color: blue;    position: absolute;    top: 50px;    left: 50px;    z-index: 2;}.wrap .right{    width: 200px;    height: 200px;    background-color: red;    position: absolute;    top: 50px;    left: 50px;    z-index: 1;}Chap2-5. opacity을 사용하여 요소의 투명도 설정하기  특정 요소에 opacity 속성을 사용하여 투명에서 불투명까지 단계별로 투명도를 지정할 수 있다            속성명      속성값      설명                  &lt;opacity&gt;      0~1      요소의 투명도를 지정함      --css--.wrap .left{    width: 200px;    height: 200px;    background-color: blue;    position: absolute;    top: 50px;    left: 50px;    opacity: 0.3;}.wrap .right{    width: 200px;    height: 200px;    background-color: red;    position: absolute;    top: 50px;    left: 50px;    opacity: 0.5;}Chap3. 다양한 그래픽 효과 적용하기  css만으로도 그래픽 효과를 넣고 다양한 인터랙티브한 콘텐츠를 만들 수 있다Chap3-1. 요소의 그림자 만들기  box-shadow, text-shadow 속성을 사용하면 블록 요소와 텍스트에 그림자 효과를 적용할 수 있다            속성명      속성값      설명                  &lt;box-shadow&gt;      가로축/세로축/퍼짐정도/색상      블록 요소의 그림자를 생성              &lt;text-shadow&gt;      가로축/세로축/퍼짐정도/색상      텍스트의 그림자를 생성        See the Pen   블록 요소 그림자 만들기 예제 by mon node (@mon-node)  on CodePen.Chap3-2. 모서리를 둥글게 만들기  border-radius 속성을 사용하면 모서리를 둥글게 설정할 수 있다            속성명      속성값      설명                  &lt;border-radius&gt;      px, %      모서리를 속성값만큼 둥글게 만듬        See the Pen   모서리 둥글게 만들기 예제 by mon node (@mon-node)  on CodePen.Chap3-3. 그레이디언트 적용하기  gradient 속성을 사용하면 한쪽은 짙게 하고 다른 쪽으로 갈수록 엷어지는 그레디언트로 지정이 가능하다 (그레이디언트 모양은 직선 또는 타원으로 지정한다)            속성명      속성값      설명                  &lt;gradient&gt;      linear-gradient(방향, 색상1, 색상2)radial-gradient(색상1, 색상2)      직선 모양의 그레이디언트를 적용타원 모양의 그레이디언트를 적용        See the Pen   그라디언트 적용하기 by mon node (@mon-node)  on CodePen.Chap3-4. filter 속성 적용하기  filter 속성은 요소에 대한 시각효과를 지정하며 포토샵에서의 보정 기술과 같은 기술을 적용할 수 있다            속성명      속성값      설명                  &lt;filter&gt;      blurbrightnesscontrastgrayscalehue-rotateinvertsaturatesepia      요소의 흐림 효과를 조정한다요소의 밝기를 조정한다요소의 명도 대비를 조절한다요소의 흑백을 지정한다요소의 색상 단계를 조절한다요소의 색상 반전 단계를 조절한다요소의 채도를 조절한다요소의 갈색 톤 단계를 조절한다        See the Pen   filter 사용하기 예제 by mon node (@mon-node)  on CodePen.Chap4. 인터랙티브 웹을 위한 css다루기  css를 사용하여 사용자 행동에 따라 반응하는 인터랙티브 웹 콘텐츠를 만들기Chap4-1. 콘텐츠 모양을 자유롭게 변형하기  transform 속성을 이용하여 HTML의 요소들을 다양하게 변형한 효과를 적용할 수 있다            속성명      속성값      설명                  &lt;transform(2D)&gt;      scaleskewtranslaterotate      선택한 요소의 크기를 확대 및 축소한다)선택한 요소를 x축 또는 y축으로 비틀어서 변형한다선택한 요소를 현재 위치 기준 x축 또는 y축 이동선택한 요소를 회전시킨다              &lt;transform(3D)&gt;      rotateX, rotateYtranslateZ      선택한 요소를 x축 또는 y축으로 입체감 있게 회전시킨다선택한 요소를 z축으로 입체감 있게 보이면서 이동시킨다              perspective      px      3D효과가 적용된 요소가 입체감 있게 보이도록 원근감을 부여한다              transform-style      preserve-3d      3D효과를 유지시킨다              transform-origin      가로축,세로축      요소의 변형이 일어나는 중심축을 변경할 수 있다        See the Pen   transform 예제 by mon node (@mon-node)  on CodePen.Chap4-2. 사용자 행동에 반응하는 전환 효과 만들기  transition 속성을 이용하여 요소의 속성값이 변경될 때 시간을 지정하여 일정시간 동안 부드러운 모션 처리를 가능하게한다            속성명      속성값      설명                  &lt;transition-property&gt;      속성명      전환 효과를 줄 css 속성명을 지정한다 속성명은 여러개 지정이 가능하며 all을 입력하면 전체 속성에서 사용이 가능하다              transition-duration      지속 시간(초 단위)      전환 효과가 발생할 때 지속할 시간을 나타낸다, 지속 시간은 초(s)단위로 지정하는데 0.5s는 0.5초, 1s는 1초를 의미한다              transition-delay      지연 시간(초 단위)      전환 효과가 발생할 때 지연할 시간을 나타낸다. 지연 시간은 초 단위로 지정하고, 이 속성을 사용하면 지연 시간 이후에 전환 효과가 나타난다              transition-timing-function      가속도      전환 효과의 가속도를 나타낸다              transition      속성명/전환시간/가속도/지연시간      모든 전환 효과 관련 속성값을 한꺼번에 축약해서 사용할 수 있다        See the Pen   trnstion 예제 by mon node (@mon-node)  on CodePen.Chap4-3. 자동으로 움직이는 애니메이션 효과 만들기  animation 속성을 사용자가 특정 동작을 하지 않더라도 미리 지정한 조건에 맞게 자동으로 반복하는 애니메이션 효과를 줄 수있다            속성명      속성값      설명                  &lt;@keyframes&gt;      애니메이션 세트 지정      애니메이션의 시작과 끝을 등록하여 사용자 모션을 등록한다 0%는 시작 지점, 100%는 끝 지점이며 중간 지점은 여러개 추가 가능              animation-name      이름      키프레임으로 등록한 모션의 이름을 호출한다              animation-duration      지속 시간(초 단위)      키프레임 모션 한 세트를 얼마 동안 동작하게 할지 초 단위로 등록              animation-timing-function      가속도      키프레임 모션을 실행할 때 가속도를 설정한다 가속도의 사용 방법은 transtion속성과 같다              animation-iteration-count      횟수      키프레임 모션 한 세트가 몇 번 동작하는지 횟수를 숫자로 설정한다, 무한 반복하고 싶으면 속성값을 infinite로 지정한다              animation-play-state      running/paused      키프레임 모션을 실행할 때 동작 상태를 지정한다 running은 모션을 그대로 진행하는 것을, paused는 일시 정지하는 것을 나타낸다              animation      이름/진행 시간/가속도/지연 시간/반복 횟수      애니메이션 속성을 축약해서 작성할 수 있다        See the Pen   애니메이션 예제 by mon node (@mon-node)  on CodePen."
  },
  
  {
    "title": "(인터랙티브 웹 페이지 만들기) Chapter2",
    "url": "/posts/chap2/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-09-24 12:33:00 +0900",
    





    
    "snippet": "css란   CSS는 Cascading Style Sheets 약자이며HTML, XHTML, XML 같은 문서의 스타일를 꾸밀 때 사용하는 스타일 시트 언어이다HTML로 문서의 뼈대를 만들면CSS는 이 문서의 색칠을 담당하고 있다글꼴이나, 배경색, 너비와 높이, 위치 등을 지정하거나,웹 브라우저, 스크린 크기, 장치에 따라서 화면을 다르게  표시될 수...",
    "content": "css란   CSS는 Cascading Style Sheets 약자이며HTML, XHTML, XML 같은 문서의 스타일를 꾸밀 때 사용하는 스타일 시트 언어이다HTML로 문서의 뼈대를 만들면CSS는 이 문서의 색칠을 담당하고 있다글꼴이나, 배경색, 너비와 높이, 위치 등을 지정하거나,웹 브라우저, 스크린 크기, 장치에 따라서 화면을 다르게  표시될 수 있도록 지정할 수도 있다.  CSS는 1996는 12월 W3C(웹 문서 표준을 만드는 기관)가 도입 했는데그 전엔 HTML언어 하나로 문서의 뼈대도 만들고, 꾸밈도 같이 했다.그러다 보니 HTML 문서를 수정할 때 모든 문서를 하나씩 수정해야 하는 번거로움이 있었으며,CSS는 문서의 내용(content)과 표현(presentation)을 분리하여CSS 파일 하나만 수정하면 스타일에 해당하는 HTML 문서가 한번에 수정되는 엄청난 장점이 있다css 사용방법기본적으로 CSS 파일을 HTML 파일에 연결하기 위해서 HTML 파일의 head 요소 안에 link 요소를 추가한다&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;link rel=\"stylesheet\" href=\"style.css\" /&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;link 요소는 다양한 용도로 사용되며 외부 CSS 스타일시트를 연결하기 위해서는 알맞은 속성을 사용하는 것이 중요하다      rel 속성 : link의 두 가지 필수 속성 중 첫 번째인 rel 속성이다 이 속성을 사용하여  브라우저에 현재 문서와 링크된 문서 사이의 연관 관계를 알려줄 수 있다rel=”stylesheet”를 사용해 브라우저에 어떤 스타일시트를 사용할 것인지 알려준다        href 속성 : 두 번째 필수 속성인 href는 가져올 파일을 지정하는 역할을 하는 속성이다보통의 경우에 CSS 파일과 HTML 파일은 같은 폴더 안에 있습니다. 이럴 때 href=”style.css”를 사용할 수 있다만약 CSS 파일과 HTML 파일이 다른 폴더에 있다면 HTML 파일에서 CSS 파일로 가는 올바른 경로를 적어야 한다          [파일 경로 설정 방법]                  절대 경로 : 어떠한 웹페이지나 파일이 가지고 있는 고유한 경로, 절대적으로 변하지 않는 경로           상대 경로 :                          ’/’ &gt; 가장 최상의 디렉토리로 이동한다.(web root)              ’./’ 파일이 현재 디렉토리를 의미한다.              ’../’상위 디렉토리로 이동한다.                                  만약 두 단계 상위 디렉토리로 이동하려면 ‘../../’이렇게 사용하면 된다.                                                                        css 인코딩인코딩은 content처럼 일부 CSS 속성(property)에서 비 ASCII 문자를 사용할 때 깨지지 않도록 미리 언어셋을 구현하는 것  인코딩 정의 방법 : css파일내 최상단에 작성 @charset “utf-8” css 선택자선택자는 css내에서 어느 요소에 스타일을 적용할지 알려주는 방식이 css 선택자이다            Best 선택자종류      설명                         전체 선택자      - 전체 선택자는 *을 사용하여 나타낸다 - html의 모든 태그에 대하여 적용한다                     태그 선택자      - 태그의 이름을 사용하여 나타낸다 - 태그명이 선택자와 같은 태그들에 대해서만 적용한다                     자식/자손 선택자      - 자손은 자식을 포괄하는 의미  - 자손은 모든 하위 요소를 의미하며 자식은 바로 아래의 자식 요소에만 적용- ‘부모 자손 {속성: 속성값;}’ 으로 적용한다 - 직계 자식에만 적용시에는 ‘부모 &gt; 자손 {속성: 속성값;}’으로 적용한다                     클래스 선택자      - 클래스 선택자는 여러 곳에서 적용 가능하다 - 클래스 선택자는 동일한 이름 사용이 가능하다 - 클래스 선택자는 .클래스이름을 사용하여 나타낸다 - 클래스 이름이 같은 태그들에 대하여 적용된다                     ID 선택자      - ID 선택자는 한 곳에서만 적용 가능하다- ID 선택자는 동일한 이름 사용이 불가능하다 - ID 선택자는 #아이디이름을 사용하여 나타낸다 - ID 이름이 같은 태그에 대해서 적용된다             - 전체 선택자 예제/* 전체 선택자 */* {    margin: 5px;    padding: 10px;}   See the Pen   전체 선택자 예제 by mon node (@mon-node)  on CodePen.- 태그 선택자 예제h2, p {color: red; font-size: 40px;}  See the Pen   태그 선택자 by mon node (@mon-node)  on CodePen.- 자식/자손 선택자 예제/* -- 직계 자식중에 li선택 --*/ul &gt; li {    color: red;}/* -- 모든 자손중에 li 선택 --*/ul li {    color: red;}  See the Pen   Untitled by mon node (@mon-node)  on CodePen.- 클래스 선택자 예제.testclass{  background: yellow;}  See the Pen   클래스 선택자 예제 by mon node (@mon-node)  on CodePen.- id 선택자 예제#korea{    color:red;    width:100%;    height: 140px;}  See the Pen   id 선택자 예제 by mon node (@mon-node)  on CodePen.폰트 스타일링웹 사이트에서 폰트를 변경하여 조금 더 UI적으로 개선해보자폰트 굵기 변경font-weight 속성을 사용해서 폰트의 굵기를 변경할 수 있다[제공되는 속성값]  normal : 폰트를 보통 굵기로 적용  bold : 폰트를 굵게 적용폰트 크기 변경font-size 속성을 사용해서 폰트의 사이즈를 변경할 수 있다[제공되는 속성값]  px : 픽셀 단위로 폰트 크기를 적용한다  rem : 최상위 부모인 &lt;html&gt; 태그를 기준으로 폰트 크기를 적용한다  em : 부모 요소를 기준으로 폰트 크기를 적용한다폰트 모양 변경font-family 속성을 사용해서 폰트의 모양을 변경할 수 있다[적용 방법]font-family: “적용할 폰트체명”;  구글 폰트 예제  구글 폰트 다운로드 사이트에서 폰트 선택  해당 폰트의 Select this styles 클릭  Use on the web에서 @import 선택 후 head 코드와 families 코드를 복사  아래 예제와 같이 css파일에 적용@charset \"utf-8\";@import url('https://fonts.googleapis.com/css2?family=Rubik+Moonrocks&amp;display=swap');.leftdiv {  font-size: 40px;  font-family: 'Rubik Moonrocks', cursive;}  See the Pen   구글 폰트 예제 by mon node (@mon-node)  on CodePen.폰트 색상 변경color 속성을 사용해서 폰트의 색상을 변경할 수 있다[제공되는 속성값]  색깔 영문명 : 폰트 색상을 영어 색상명으로 표기  #000000 : 폰트 색상을 16진수로 표기  rgb(0,0,0) 폰트 색상을 RGB로 표기웹 페이지 너비와 높이 지정하기width, height 속성을 사용해서 태그들의 영역과 여백 크기를 지정할 수 있다[제공되는 속성값]  px : 너빗값과 높잇값을 px단위로 설정한다  % : 부모 태그를 기준으로 너빗값과 높잇값을 % 단위로 설정한다  vw : 웹 브라우저의 너비를 기준으로 너빗값과 높잇값을 백분율로 설정한다  vh : 웹 브라우저의 높이를 기준으로 너빗값과 높잇값을 백분율로 설정한다바깥쪽 여백 지정하기margin 속성을 사용해서 태그의 바깥쪽 여백 설정이 가능하다[제공되는 속성값]  px : 너빗값과 높잇값을 px단위로 설정한다  % : 부모 태그를 기준으로 너빗값과 높잇값을 % 단위로 설정한다  vw : 웹 브라우저의 너비를 기준으로 너빗값과 높잇값을 백분율로 설정한다  vh : 웹 브라우저의 높이를 기준으로 너빗값과 높잇값을 백분율로 설정한다안쪽 여백 지정하기padding 속성을 사용해서 태그의 안쪽 여백 설정이 가능하다[제공되는 속성값]  px : 너빗값과 높잇값을 px단위로 설정한다  % : 부모 태그를 기준으로 너빗값과 높잇값을 % 단위로 설정한다  vw : 웹 브라우저의 너비를 기준으로 너빗값과 높잇값을 백분율로 설정한다  vh : 웹 브라우저의 높이를 기준으로 너빗값과 높잇값을 백분율로 설정한다블록 요소와 인라인 요소태그의 크기와 테두리 등을 지정할 때 블록 요소와 인라인 요소의 태그에 따라 다르게 적용된다“블럭요소” : 하나의 태그가 브라우저에서 좌우공간을 다 차지하면서 독립적인 덩어리 공간을 가지는 요소들을 말한다“인라인요소” : 하나의 태그가 브라우저에서 실제로 코딩된 그 영역만 차지하여 좌우로 다른 태그가 나란히 위치할 수 있는 요소를 말한다블럭요소(block element)와 인라인요소(inline element)의 종류- 블럭요소 : &lt;div&gt;,&lt;table&gt;,&lt;h1&gt;~&lt;h6&gt;,&lt;p&gt;,&lt;form&gt;,&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;,&lt;dl&gt;,&lt;dt&gt;,&lt;dd&gt;,&lt;pre&gt;,&lt;blockquote&gt;등- 인라인요소 : &lt;span&gt;,&lt;a&gt;,&lt;br&gt;,&lt;em&gt;,&lt;strong&gt;,&lt;input&gt;,&lt;label&gt;,&lt;img&gt;"
  },
  
  {
    "title": "(인터랙티브 웹 페이지 만들기) Chapter1",
    "url": "/posts/chap1/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-09-12 12:33:00 +0900",
    





    
    "snippet": "UI &amp; UX      UI는 User Interface의 약자이며 사용자가 콘텐츠를 직접 접하는 부분 사용자 환경을 의미한다(ex: 바탕화면 아이콘, 모바일 화면 등)    UX는 User experience의 약자이며 사용자가 UI를 사용하면서 느낄 수 있는 사용자의 경험을 의미한다(ex: 트리구조의 게시판 접근등 사용성의 전반적인 부분) ...",
    "content": "UI &amp; UX      UI는 User Interface의 약자이며 사용자가 콘텐츠를 직접 접하는 부분 사용자 환경을 의미한다(ex: 바탕화면 아이콘, 모바일 화면 등)    UX는 User experience의 약자이며 사용자가 UI를 사용하면서 느낄 수 있는 사용자의 경험을 의미한다(ex: 트리구조의 게시판 접근등 사용성의 전반적인 부분)  HTML, CSS, 자바스크립트란  예로 HTML은 그림의 연필로 그린 도면이고 CSS는 도면에 색칠을 하는것이고 자바스크립트는 해당 그림에 생명을 불어넣어 살아 움직이게 하는것과 같다웹 개발에 있어서 필요한 도구  웹 브라우저          웹 페이지를 개발하고 확인하기 위해서는 웹 브라우저라는 프로그램을 필요로 한다 웹 브라우저는 다양하며 현재 Chrome 브라우저가 점유율 최상위를 차지하고 있다              Chrome 설치 : https://www.google.co.kr/chrome/        웹 에디터          웹 개발을 위해 효율적인 코드를 작성 할 수 있도록 도와주는 웹 에디터 (IDE)가 필요하다 종류가 다양하며 대표적으로 Editplus, Notepad++, ATOM Editor, VisualStudio등이 존재한다              VisualStudio설치 : https://code.visualstudio.com      태그란 [태그는 브라우저가 웹 문서를 잘 이해할 수 있도록 콘텐츠를 목적에 맞게 분류한 규칙]부모 태그와 자식 태그 : 태그의 기본 문법은 부모 태그 안에 자식태그가 존재하는 형태이며 Tab으로 들여쓰기를 하여 자식 태그를 분리한다[Ex]&lt;html&gt; =&gt; 부모 태그    &lt;head&gt; =&gt; 자식 태그    &lt;/head&gt; =&gt; 자식 태그        &lt;body&gt; =&gt; 자식 태그    &lt;/body&gt; =&gt; 자식 태그&lt;/html&gt; =&gt; 부모 태그HTML의 기본 구조HTML의 구성은 문서 타입을 지정해 주는 &lt;!DOCTYPE&gt;, &lt;html&gt;태그로 구성되며 &lt;html&gt; 태그 안에는 다시 &lt;head&gt; 와 &lt;body&gt;태그 영역으로 분리된다[TCP School 참고]  &lt;!DOCTYPE html&gt; : 현재 웹 문서가 HTML5 문서임을 명시하는 영역&lt;html&gt; : HTML 문서의 루트 요소(주요 핵심) 내용을 담고 있는 영역&lt;head&gt; : HTML 문서의 메타데이터(metadata)를 갖고있는 영역이며 페이지에서 보이지 않는 문서 설정 또는 css, 자바스크립트와 같은 외부 파일을 연결하는 영역이다&lt;body&gt;: 웹 브라우저에 출력 할 주요 콘텐츠를 갖고있는 영역시맨틱 태그  HTML에서의 body안에 기본 구조를 형식에 맞게 구현해주는 형식 태그시맨틱(semantic)이라는 ‘의미의’, ‘의미론적인’라는 뜻을 가진 형용사  즉 시맨틱 태그는 의미를 부여한 태그라는 뜻이되며&lt;header&gt;나 &lt;footer&gt;  같은 태그들이 있다 이 태그들은 이름만 봐도 상단과 하단이라는 것을 알 수 있으며 이렇게 시맨틱 태그의 등장으로 인해 태그만 보고도 문서를 더 쉽게 이해할 수 있게 된다            시맨틱Tag      설명                         &lt;header&gt;      사이트의 머리부분에 사용                     &lt;main&gt;      메인 콘텐츠를 나타내는데 사용                     &lt;section&gt;      제목별로 나눌 수 있는 문서의 콘텐츠 영역을 구성하는 요소                     &lt;article&gt;      개별 콘텐츠를 나타내는 요소                     &lt;aside&gt;      좌우측의 사이드 영역                     &lt;footer&gt;      사이트의 바닥부분, 주로 연락처나 제작자 정보등을 기술하는 부분                     &lt;hgroup&gt;      제목과 부제목을 묶어서 나타내는 요소                     &lt;nav&gt;      웹 페이지 메뉴를 만들 때 사용             시맨틱 태그 예제&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;  &lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Jogyejin의 시맨틱 태그 연습&lt;/title&gt;    &lt;style&gt;      /* 전체 스타일링 */      body {        font-family: sans-serif;        margin: 0;        padding: 0;        background-color: skyblue;      }      /* 헤더 스타일링 */      header {        background-color: #333;        color: #fff;        padding: 1em;        display: flex;        align-items: center;        justify-content: space-between;      }      header h1 {        margin: 0;      }      /* 네비게이션 스타일링 */      nav {        background-color: orange;        padding: 0.5em;      }      nav ul {        list-style: none;        margin: 0;        padding: 0;        display: flex;      }      nav li {        margin-right: 1em;      }      nav a {        color: #333;        text-decoration: none;        padding: 0.5em;      }      nav a:hover {        background-color: #333;        color: #fff;      }      /* 메인 스타일링 */      main {        display: flex;        flex-wrap: wrap;        margin: 1em;      }      section {        margin-right: 1em;        flex: 1 1 300px;        background-color: #fff;        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);        margin-bottom: 1em;        padding: 1em;      }      section:last-child {        margin-right: 0;      }      section h2 {        margin: 0;      }      article {        margin-top: 1em;      }      article h3 {        margin: 0;      }      /* 사이드바 스타일링 */      aside {        background-color: #fab1a0;        padding: 1em;        margin-right: 1em;        flex: 0 0 300px;      }      aside h3 {        margin: 0;      }      /* 바닥글 스타일링 */      footer {        background-color: #1abc9c;        color: #fff;        padding: 1em;        text-align: center;      }      footer p {        margin: 0;        padding: 0.5em;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;header&gt;      &lt;h1&gt;Jogyejin의 시맨틱 태그 연습&lt;/h1&gt;      &lt;img src=\"https://i.ibb.co/bb7kRP4/default-avatar.jpg\" alt=\"default-avatar\" border=\"0\" width=\"100\"&gt;    &lt;/header&gt;    &lt;nav&gt;      &lt;ul&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;홈&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;상품정보&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;내정보&lt;/a&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/nav&gt;    &lt;main&gt;      &lt;section&gt;        &lt;h2&gt;상품정보&lt;/h2&gt;        &lt;p&gt;향이 좋은 향초&lt;/p&gt;        &lt;ul&gt;          &lt;li&gt;라벤더 향초&lt;/li&gt;          &lt;li&gt;파우더 향초&lt;/li&gt;          &lt;li&gt;바디솜 향초&lt;/li&gt;        &lt;/ul&gt;      &lt;/section&gt;      &lt;section&gt;        &lt;h2&gt;내정보&lt;/h2&gt;        &lt;article&gt;          &lt;h3&gt;사용자정보&lt;/h3&gt;          &lt;p&gt;ID/PW&lt;/p&gt;        &lt;/article&gt;        &lt;article&gt;          &lt;h3&gt;배송지주소&lt;/h3&gt;          &lt;p&gt;경기도 성남시&lt;/p&gt;        &lt;/article&gt;      &lt;/section&gt;    &lt;/main&gt;    &lt;aside&gt;      &lt;h3&gt;광고&lt;/h3&gt;      &lt;p&gt;광고 내용&lt;/p&gt;    &lt;/aside&gt;    &lt;footer&gt;      &lt;p&gt;상호명&lt;/p&gt;      &lt;p&gt;고객센터 전화번호&lt;/p&gt;    &lt;/footer&gt;  &lt;/body&gt;&lt;/html&gt;시맨틱 태그 예제 출력물  See the Pen   시맨틱 태그 by mon node (@mon-node)  on CodePen.서식태그  서식태그는 단어나 문자의 서식을 결정하며 다양한 태그를 활용하여 가독성을 높일 수 있다서식태그의 종류서식태그 예제&lt;!doctype html&gt;&lt;html&gt;     &lt;head&gt;        &lt;title&gt;서식태그 예제&lt;/title&gt;        &lt;style type=text/css&gt;           .leftdiv           {             background-color:yellow;             float: left;           }           .middlediv           {             float: left;             background-color:gray           }           .rightdiv           {             float: left;           }           div{             padding : 1%;             color: black;             background-color: 009900;             width: 30%;             border: solid black;           }         &lt;/style&gt;     &lt;/head&gt;    &lt;body&gt;      &lt;hr&gt;      &lt;!--제목태그 --&gt;      &lt;h1&gt;제목 1&lt;/h1&gt;       &lt;h2&gt;제목 2&lt;/h2&gt;      &lt;h3&gt;제목 3&lt;/h3&gt;      &lt;h4&gt;제목 4&lt;/h4&gt;      &lt;h5&gt;제목 5&lt;/h5&gt;      &lt;h6&gt;제목 6&lt;/h6&gt;            &lt;hr&gt;            &lt;!-- 문단태그 --&gt;      &lt;p style=\"background-color:powderblue;\"&gt;p 문단 1&lt;/p&gt;      &lt;p style=\"background-color:#D2E556;\"&gt;p 문단 2&lt;/p&gt;         &lt;hr&gt;            &lt;!-- 그룹지정태그 --&gt;      &lt;div class=\"leftdiv\"&gt;         &lt;h1&gt;div 1&lt;/h1&gt;         &lt;p&gt;p 문단 1&lt;/p&gt;       &lt;/div&gt;       &lt;div class=\"middlediv\"&gt;         &lt;h1&gt;div 2&lt;/h1&gt;         &lt;p&gt;p 문단 2&lt;/p&gt;       &lt;/div&gt;       &lt;div class=\"rightdiv\"&gt;         &lt;h1&gt;div 3&lt;/h1&gt;         &lt;p&gt;p 문단 3&lt;/p&gt;       &lt;/div&gt;             &lt;!-- 강조 태그 예제 --&gt;            &lt;hr&gt;      &lt;strong&gt;강력한 strong!&lt;/strong&gt;&lt;br&gt;      &lt;em&gt;최근에는 안쓰는 em!&lt;/em&gt;&lt;br&gt;      &lt;hr&gt;            &lt;!-- a 태그 예제 --&gt;      &lt;a href=\"http://www.naver.com\"&gt;나는야 하이퍼링크(클릭시 네이버이동)&lt;/a&gt;      &lt;hr&gt;      &lt;!-- 두꺼운 글씨체 태그 --&gt;      &lt;b&gt;bold text&lt;/b&gt;      &lt;hr&gt;            &lt;!-- span 예제 --&gt;      &lt;span style=\"background-color:red\"&gt;span1&lt;/span&gt;      &lt;span style=\"background-color:blue\"&gt;span2&lt;/span&gt;      &lt;span style=\"background-color:green\"&gt;span3&lt;/span&gt;      &lt;hr&gt;            &lt;!-- img 태그 --&gt;      &lt;img src=\"https://i.ibb.co/bb7kRP4/default-avatar.jpg\" alt=\"이미지 태그\" border=\"0\" width=\"100\"/&gt;      이미지 태그            &lt;hr&gt;      &lt;!-- 줄바꿈 태그 --&gt;      고생했어,&lt;br&gt;      오늘 하루도            &lt;/body&gt;&lt;/html&gt;  See the Pen   Untitled by mon node (@mon-node)  on CodePen.목록 태그텍스트나 이미지등을 목록화 및 리스트화하여 카테고리 등을 표현하기 위해 사용되는 태그            목록Tag      설명                  &lt;ul&gt;,&lt;li&gt;      순서가 없는 목록(unorder list)을 만들 때 사용              &lt;ol&gt;,&lt;li&gt;      순서가 있는 목록을 만들 때 사용              &lt;dl&gt;,&lt;dt&gt;,&lt;dd&gt;      제목과 설명이 한 쌍인 설명 목록을 만들 때 사용      목록 태그 예제&lt;!DOCTYPE&gt;&lt;html&gt;    &lt;head&gt;    &lt;/head&gt;    &lt;body&gt;       &lt;ul&gt; &lt;순서가 없는 목록&gt;           &lt;li&gt;HTML&lt;/li&gt;           &lt;li&gt;CSS&lt;/li&gt;           &lt;li&gt;JAVASCRIPT&lt;/li&gt;           &lt;li&gt;JAVA&lt;/li&gt;           &lt;li&gt;JSP&lt;/li&gt;           &lt;li&gt;ORACLE&lt;/li&gt;       &lt;/ul&gt;       &lt;hr&gt;       &lt;ol type=\"A\"&gt;&lt;순서가 있는 목록&gt;           &lt;li&gt;variable&lt;/li&gt;           &lt;li&gt;operator&lt;/li&gt;           &lt;li&gt;data type&lt;/li&gt;           &lt;li&gt;control statement&lt;/li&gt;       &lt;/ol&gt;        &lt;hr&gt;            &lt;정의형 목록&gt;       &lt;dl&gt;           &lt;dt&gt;HTML&lt;/dt&gt;           &lt;dd&gt;HyperText Markup Language&lt;/dd&gt;           &lt;dd&gt;웹페이지를 위한 지배적 마크업 언어&lt;/dd&gt;           &lt;dt&gt;JAVA&lt;/dt&gt;           &lt;dd&gt;객체지향 프로그래밍 언어&lt;/dd&gt;           &lt;dd&gt;웹 애플리케이션 등 가장 많이 사용되는 언어&lt;/dd&gt;           &lt;dt&gt;Python&lt;/dt&gt;         &lt;dd&gt; 파이썬(Python)은 1990년 암스테르담의 귀도 반 로섬(Guido Van Rossum)이 개발한 인터프리터 언어&lt;/dd&gt;         &lt;/dl&gt;         &lt;/body&gt;&lt;/html&gt;  See the Pen   Untitled by mon node (@mon-node)  on CodePen.폼(Form) 태그폼은 사용자로부터 데이터를 입력받아 서버로 전송한다 전송한 데이터는 웹 서버가 처리하고 결과에 따른 또 다른 웹 페이지를 출력한다input 태그      input 태그는 type 속성을 다르게 지정하여 다양하게 사용자로부터 데이터를 입력 받을 수 있다        input 태그에서 사용가능한 속성 [TCP School 참고]  input 예제  See the Pen   Untitled by mon node (@mon-node)  on CodePen.멀티미디어 태그HTML5에서 추가된 멀티미디어 요소인 video와 audio등을 말하며 현재에 웹에서 동영상을 시청하고 음악을 듣는데 지장이 없다고 생각할 수 있다 하지만 각종 플러그인과 ActiveX라는 불편함과 보안위협에 노출되어 있으며 그런 이유로 브라우저 자체에서 동영상을 재생하게끔 멀티미디어 태그가 필요하게 된 것이다Audio 태그  음악 컨텐츠를 사용하기 위해 구현 가능한 태그[Audio 태그에서 사용 가능한 파일]             확장자      설명                  wav      IBM과 Microsoft에 의해 개발되었으며, 개인용 PC에서 오디오를 재생하기 위한 IBM과 Microsoft의 표준 오디오 파일 형식              mp3      대부분의 음원에서 사용되며 Moving Picture Experts Group에 의해 개발됨, MPEG-1의 오디오 규격으로 개발된 손실 압축형 파일 형식이다              ogg      Xiph 재단에 의해 개발되었으며, MP3의 대안으로 개발된 특허권으로 보호되지 않는 개방형 공개 멀티미디어 파일 형식, 라이센스 없이 무료이므로 게임등에서 많이 사용한다      [Audio 태그에서 사용할 수 있는 속성]             속성      설명                  controls      웹 화면에 컨트롤 막대를 표시하고 컨트롤 막대에는 재생/멈춤, 진행바, 볼륨 등이 있다              autoplay      오디오를 자동 재생한다              loop      오디오를 반복해서 재생한다              muted      오디오는 재생하지만 소리는 자동 음소거된다              preload      재생 버튼을 눌러 재생하기 전에 오디오 파일을 다운로드해서 준비한다      Audio 태그 예제&lt;!--일반 재생--&gt;[일반 재생]&lt;br&gt;&lt;audio src=\"https://ccrma.stanford.edu/~jos/mp3/harpsi-cs.mp3\" controls&gt;&lt;/audio&gt;&lt;hr&gt;&lt;!--자동 재생--&gt;[자동 재생]&lt;br&gt;&lt;audio src=\"https://ccrma.stanford.edu/~jos/mp3/harpsi-cs.mp3\" controls autoplay&gt;&lt;/audio&gt;&lt;hr&gt;&lt;!--반복 재생--&gt;[반복 재생]&lt;br&gt;&lt;audio src=\"https://ccrma.stanford.edu/~jos/mp3/harpsi-cs.mp3\" controls loop&gt;&lt;/audio&gt;  See the Pen   Untitled by mon node (@mon-node)  on CodePen.Video 태그  비디오 컨텐츠를 사용하기 위해 구현 가능한 태그[video 태그에서 사용 가능한 속성]             속성      설명                  controls      영상 컨트롤 막대를 표시하며 컨트롤 막대에는 재생/멈춤, 진행바, 볼륨 등이 있다              width, height      화면에 표시되는 영상의 크기를 조절한다              autoplay      영상을 자동 재생              loop      영상을 반복해서 재생              muted      영상은 재생하지만 소리는 음소거됨              preload      영상을 재생하기 전에 미디어 파일을 다운로드 함              poster      브라우저나 인터넷 문제등으로 영상을 재생못하는 경우 표시함      video 태그 예제&lt;!--일반 재생--&gt;[일반 재생]&lt;br&gt;&lt;video src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\" controls width=\"300\" height=\"200\"&gt;&lt;/video&gt;&lt;hr&gt;&lt;!--자동 재생--&gt;[자동 재생]&lt;br&gt;&lt;video src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\" width=\"300\" controls autoplay&gt;&lt;/video&gt;&lt;hr&gt;&lt;!--반복 재생--&gt;[반복 재생]&lt;br&gt;&lt;video src=\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\" width=\"300\" controls loop&gt;&lt;/video&gt;  See the Pen   video 태그 by mon node (@mon-node)  on CodePen.###웹"
  },
  
  {
    "title": "Javascript 객체",
    "url": "/posts/javascript_object/",
    "categories": "Develop, Javascript",
    "tags": "Javascript",
    "date": "2023-08-24 12:33:00 +0900",
    





    
    "snippet": "객체 지향 프로그래밍(OOP)  객체 지향 프로그래밍은 Java를 비롯한 많은 프로그래밍 언어의 기본이 되는 프로그래밍 패러다임이다 이번 시간에는 OOP의 기본 개념이 되는 객체, 인스턴스, 생성자 를 알아보도록한다.생성자 함수  생성자 함수는 객체를 생성하기 위한 함수이다 생성자는 다른 함수들과 달리 대문자로 시작한다생성자 함수는 아래 두 조건을 만...",
    "content": "객체 지향 프로그래밍(OOP)  객체 지향 프로그래밍은 Java를 비롯한 많은 프로그래밍 언어의 기본이 되는 프로그래밍 패러다임이다 이번 시간에는 OOP의 기본 개념이 되는 객체, 인스턴스, 생성자 를 알아보도록한다.생성자 함수  생성자 함수는 객체를 생성하기 위한 함수이다 생성자는 다른 함수들과 달리 대문자로 시작한다생성자 함수는 아래 두 조건을 만족해야 한다  함수 이름의 첫 글자는 대문자로 시작한다  반드시 new연산자를 붙여 실행한다function human(name, age) {  this.name = name  this.age = age  this.introduce = function() {  console.log('이름 : ' + this.name + ' 나이: ' + this.age)  }}객체  객체는 여러 속성(프로퍼티)을 하나의 변수에 저장할 수 있도록 해주는 데이터 타입으로 Key / Value를 저장할 수 있는 구조이다  객체는 변수이다  객체는 중괄호 표기를 이용하여 만들 수 있다  객체는 각각의 key/value에 대한 정보를 나열할 수 있다  Key는 문자열 또는 기호여야 한다객체 생성 방법객체를 생성하는 방법에는 크게 2가지가 존재한다   객체 리터럴을 사용하여 단일 객체를 정의하고 만드는 방법  생성자 함수와 new 키워드를 사용하여 객체를 정의하고 만드는 방법객체 생성 방법 ( 객체 리터럴 )객체 리터럴 : 중괄호안에 key : value로 구성var robot = {  monster_name : \"로봇\",  monster_level : 10 }console.log(typeof monster); // object console.log(monster.monster_name); // 로봇console.log(monster.monster_level); // 10 객체 생성 방법 ( 생성자 함수와 new키워드 )// 생성자 함수 생성funtion Monster(params_name, params_level){  this.monster_name : params_name,  this.monster_level : params_level}// new 키워드를 사용하여 위에서 만든 생성자 함수로 robot이라는 객체를 만듬 (인스턴스화)const robot = new monster('로봇', 10); // robot 변수가 잘 생성되어 object 데이터타입을 갖은 객체라는것을 알 수 있음console.log (typeof robot); // object// robot 객체에 .(점) 접근자를 사용하여 속성(프로퍼티)에 접근할 수 있음console.log (robot.monster_name) // 로봇console.log (robot.monster_level) // 10객체 리터럴을 안쓰고 생성자 함수로 객체를 생성하는 이유?  위처럼 객체 리터럴문법으로 객체를 생성할 수 있지만 아래와 같이 여러개의 객체를 생성해야하는 경우는 소스의 중복 및 가독성이 떨어진다[객체 리터럴 방식으로 객체를 여러개 만든경우]var robot1 = {  monster_name : \"로봇1\",  monster_level : 10 }var robot2 = {  monster_name : \"로봇2\",  monster_level : 20 }var robot3 = {  monster_name : \"로봇3\",  monster_level : 30 }[생성자 함수로 객체를 여러개 만든 경우]funtion Monster(params_name, params_level){  this.monster_name : params_name,  this.monster_level : params_level}const robot1 = new Monster('로봇1', 10);const robot2 = new Monster('로봇2', 20);const robot3 = new Monster('로봇3', 30);"
  },
  
  {
    "title": "(Network) Subnet과 Subnetting",
    "url": "/posts/subnet/",
    "categories": "Network",
    "tags": "Network",
    "date": "2023-07-14 12:33:00 +0900",
    





    
    "snippet": "서브넷의 등장 배경  IPv4는 초기에 클래스로 나누어서 할당을 방법을 사용하였지만 이 방식은 크게 비효율적이었다 예로들어 클래스 B를 어느 중소기업체에게 할당했을 경우 65000여개의 아이피를 다 쓰는 것이 아닌 10000개 정도만 쓴다고 가정하면 10000개가 아닌 나머지 50000여개의 IP는 쓰이지 않은 채 이 기업체는 클래스 B의 하나를 점유...",
    "content": "서브넷의 등장 배경  IPv4는 초기에 클래스로 나누어서 할당을 방법을 사용하였지만 이 방식은 크게 비효율적이었다 예로들어 클래스 B를 어느 중소기업체에게 할당했을 경우 65000여개의 아이피를 다 쓰는 것이 아닌 10000개 정도만 쓴다고 가정하면 10000개가 아닌 나머지 50000여개의 IP는 쓰이지 않은 채 이 기업체는 클래스 B의 하나를 점유하고 있는 상태가 된다 그렇다고 이 기업체에게 클래스 C를 IP를 할당하자니 IP자원이 너무 부족하였고, 결국 큰 네트워크를 작게 쪼개는 작업이 필요했다이러한 문제를 해결하기 위해 IP를 사용하는 네트워크 장치 수에 따라 효율적으로 사용할 수 있는 서브넷(Subnet)이 등장하게 된다.서브넷(Subnet)네트워크의 규모가 크면 클수록 네트워크를 관리하고 유지하기는 어려워짐에 따라 네트워크를 작은 조각으로 쪼갠것을 서브넷이라고하며 ip주소에서 네트워크 영역을 부분적으로 나눈 부분 네트워크를 의미한다서브넷의 장점  유지보수가 쉬움 (네트워크를 관리하기 용이)  네트워크 보안 효율성 증가  네트워크의 트래픽 감소서브넷 마스크 (Subnet mask)아이피는 8비트 총 4옥텟으로 32비트의 비트수를 가지며 해당 아이피는 호스트와 네트워크 부분으로 나뉘며 서브넷 마스크라 부른다 32비트의 숫자로 ‘0’ 비트는 호스트 부분을 나타내며 ‘1’의 비트는 네트워크 부분을 나타낸다  서브넷 마스크와 IP 주소를 AND연산하면 Network ID가 된다            Class      이진표현      십진표현      기본 서브넷 마스크                  A class      0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx      0.0.0.0 ~ 127.255.255.255      255.0.0.0              B class      10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx      128.0.0.0 ~ 191.255.255.255      255.255.0.0              C class      110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx      192.0.0.0 ~ 223.255.255.255      255.255.255.0      서브넷팅(Subnetting)"
  },
  
  {
    "title": "(Web) Html의 모든것",
    "url": "/posts/html/",
    "categories": "Develop, html",
    "tags": "html",
    "date": "2023-07-14 12:33:00 +0900",
    





    
    "snippet": "HTML란  HTML은 HyperText Markup Language의 약자웹 페이지는 HTML 문서라고도 불리며, HTML 태그들로 구성된다각각의 HTML 태그는 웹 페이지의 디자인이나 기능을 결정하는데 사용된다HTML 기본 구조- &lt;!DOCTYPE html&gt; : 현재 문서가 HTML5 문서임을 명시한다- &lt;html&gt; : HTM...",
    "content": "HTML란  HTML은 HyperText Markup Language의 약자웹 페이지는 HTML 문서라고도 불리며, HTML 태그들로 구성된다각각의 HTML 태그는 웹 페이지의 디자인이나 기능을 결정하는데 사용된다HTML 기본 구조- &lt;!DOCTYPE html&gt; : 현재 문서가 HTML5 문서임을 명시한다- &lt;html&gt; : HTML 문서의 루트(root) 요소를 정의한다- &lt;head&gt; : HTML 문서의 메타데이터(metadata)를 정의한다- 메타데이터(metadata)란 HTML 문서에 대한 정보(data)로 웹 브라우저에는 직접적으로 표현되지 않는 정보를 의미한다- 이러한 메타데이터는 &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;base&gt;태그 등을 이용하여 표현할 수 있다- &lt;title&gt; : HTML 문서의 제목(title)을 정의하며, 다음과 같은 용도로 사용된다    &gt; 웹 브라우저의 툴바(toolbar)에 표시    &gt; 웹 브라우저의 즐겨찾기(favorites)에 추가할 때 즐겨찾기의 제목이 된다    &gt; 검색 엔진의 결과 페이지에 제목으로 표시된다- &lt;body&gt; : 웹 브라우저를 통해 보이는 내용(content) 부분- &lt;h1&gt; ~ &lt;h6&gt; : 제목(heading)을 나타낸다- &lt;p&gt; : 단락(paragraph)을 나타낸다Tag(태그)  웹 페이지를 구성하는 요소는 텍스트, 이미지, 버튼 등 매우 다양하다 태그는 이런 다양한 구성 요소를 정의하는 역할을 하며, HTML 문법을 이루는 가장 작은 단위입니다. 기본 형식은 다음과 같이 괄호(&lt; &gt;) 사이에 태그명을 넣는 형태이다[각종 태그 종류]- hn 태그 : hn 태그는 제목이나 주제를 나타내는 텍스트를 표현할 때 사용(hn 태그는 h1부터 h6 태그까지 6개가 있는데, 여기서 h는 heading을 의미하고 n에 들어가는 숫자는 중요도를 나타낸다)- p 태그 : p 태그는 본문의 문단(paragraph)을 작성할 때 사용(HTML에서는 제목이나 주제를 나타내는 텍스트가 아니면 대부분 본문이기 때문에 p 태그를 자주 사용한다)- br 태그 : br 태그는 문단에서 줄 바꿈할 때 사용- blockquote 태그 : blockquote 태그는 출처에서 인용한 문단 단위의 텍스트를 작성할 때 사용한다 이때 출처가 확실한 인용문은 cite 속성으로 출처 경로를 명시해야 한다- q 태그 : q 태그는 문단 안에 텍스트 단위의 짧은 인용문을 작성할 때 사용할 수 있는 태그 q 태그를 사용한 콘텐츠는 큰따옴표(\"\")로 묶임- ins와 del 태그 : ins 태그는 새로 추가된 텍스트임을 나타낼 때 사용하고, del 태그는 기존에 있던 텍스트가 삭제된 텍스트임을 나타낼 때 사용한다 ins 태그를 사용한 콘텐츠에는 밑줄이, del 태그를 사용한 콘텐츠에는 취소선이 생긴다- sub와 sup 태그 : sub 태그와 sup 태그는 각각 아래 첨자, 위 첨자에 해당하는 텍스트를 작성할 때 사용한다- div 태그 : div 태그는 블록 요소와 인라인 요소를 그룹으로 묶을 때 사용한다(body 태그 안에 영역 구분 없이 표시하려는 텍스트만 작성하면 코드가 복잡해질수록 텍스트를 구분하기 어려워지는데 이 코드를 div 태그를 사용해 영역별로 그룹을 지으면 코드 단순화가 가능하다)- span 태그 : span 태그는 인라인 요소를 그룹으로 묶을 때 사용한다- ul 태그 :ul(unordered list) 태그는 순서가 없는 비순서형 목록을 생성할 때 사용하며 이때 목록 내용은 li(list item) 태그로 구성한다- ol 태그 : ol(ordered list) 태그는 순서형 목록을 생성할 때 사용하며 ul 태그와 마찬가지로 li 태그로 목록 내용을 구성 한다- dl 태그 : dl(description list) 태그는 정의형 목록을 만들 때 사용합니다. 정의형 목록은 용어와 용어 설명을 나열한 형태의 목록이라고 보면 된다 dl 태그로 목록을 생성할 때는 li 태그 대신에 dt(description term) 태그로 용어를, dd(description details) 태그로 용어 설명을 작성한다- a 태그 : a 태그는 HTML에서 내부나 외부 링크를 생성하며 a 태그는 대상 경로를 의미하는 href 속성을 필수로 사용해야 하고, 그 외에 target, title 속성을 선택해서 사용할 수 있다- img 태그 : HTML에서 이미지 객체를 삽입하고 싶을 때는 img 태그를 사용하며 img 태그는 src 속성과 alt 속성으로 구성된다- strong 태그 : strong 태그는 텍스트의 의미를 강조하고 싶을 때 사용하며 strong 태그는 스타일에서 차이를 두기 위해 시각적으로 텍스트를 굵게 표시하는 것뿐 아니라 웹 브라우저에 중요한 부분임을 알려 주는 역할을 한다- em 태그 : em(emphasis) 태그 역시 텍스트의 의미를 강조하고 싶을 때 사용하며 em 태그를 사용하면 텍스트가 기울어져 보이면서 강조 효과를 낼 수 있다주석  주석(comment)은 실행결과(웹 브라우저)에는 표시되지 않지만, 코드에 어떠한 메모나 설명을 남기고 싶을 때 사용하며 &lt;!--와 --&gt; 사이에 내용을 작성하면 해당 내용은 주석으로 처리된다DTD (Documen Type Definition)웹 브라우저가 처리할 해당 문서가 어떤 문서 형식을 따라야 하는지 미리 정의 하는 것으로 HTML문서 작성시 항상 맨처음에 넣어야 한다&lt;!DOCTYPE html&gt;기본구조- html 태그는 HTML 문서의 시작과 끝을 의미한다 따라서 모든 태그는 html 태그 안에 작성해야 한다- head 태그는 HTML 문서의 메타데이터(metadata)를 정의하는 영역이다 메타데이터란 HTML 문서에 대한 정보(data)로, 웹 브라우저에는 직접 노출되지 않는다 보통 meta, title, link, style, script 등의 태그를 사용해 HTML 문서의 여러 정보를 정의한다- meta 태그는 메타데이터를 정의하는 데 사용한다- title 태그는 HTML 문서의 제목을 지정하는 데 사용한다- body 태그는 웹 브라우저에 노출되는 내용을 작성하는 영역이다, 따라서 웹 브라우저에서 표시되는 모든 내용은 body 태그 영역 안에 작성한다&lt;html&gt;     &lt;head&gt;         &lt;title&gt; 제목 &lt;/title&gt;         &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"keyword\" content=\"HTML, meta, tag, element, reference\"&gt;        &lt;meta name=\"description\" content=\"HTML meta tag page\"&gt;        &lt;meta name=\"author\" content=\"gyejin\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;            &lt;/head&gt;         &lt;body&gt;        내용    &lt;/body&gt; &lt;/html&gt; 부모,자식,형제 관계  HTML은 태그 사용 위치에 따라서 부모,자식,형제 관계가 성립된다 상위 태그 안에 하위 태그가 존재하면 상위태그는 하위태그의 부모가 되며 해당 상위태그 밑에 존재하는 하위태그들은 각 형제 관계를 갖게된다폼(Form) 구성하기  폼(form)은 HTML에서 사용자와 상호작용해서 정보를 입력받고 서버로 전송하기 위한 양식을 의미한다 실제로 웹 페이지에서 폼은 흔하게 찾아볼 수 있다 예를 들어, 네이버 로그인 화면에는 아이디와 비밀번호를 입력하는 요소와 로그인 상태 유지를 설정하는 체크박스, 버튼 요소까지 다양한 상호작용 요소가 존재한다폼(Form) 관련 태그- form 태그 : 폼 양식을 의미하는 태그이며 HTML의 폼을 구성하는 태그는 모두 form 태그 안에 작성해야 한다(form 태그는 action과 method 속성을 함께 사용)    * `action 속성` : action 속성에는 폼 요소에서 사용자와 상호작용으로 입력받은 값들을 전송할 서버의 URL 주소를 적는다    * `method 속성` : method 속성에는 입력받은 값을 서버에 전송할 때 송신 방식을 적습니다. 속성값으로 get 또는 post를 사용할 수 있다- input 태그 : 로그인 페이지의 아이디와 비밀번호처럼 입력받는 요소를 생성할 때는 input 태그를 사용한다(input 태그에는 type, name, value 속성이 있는데, type 속성은 필수로 사용해야 하고, name과 value 속성은 선택해서 사용할 수 있다)    * `type 속성` : type 속성은 입력된 값에 따라 상호작용 요소의 종류를 결정하며 입력 요소는 아이디나 비밀번호를 입력받는 요소 외에도 콤보박스, 파일 업로드, 체크박스, 라디오버튼 등 다양하다 이런 요소의 종류를 type 속성에 사용된 값으로 결정한다    * `name 속성` : name 속성에는 입력 요소의 이름을 작성하며 입력 요소가 form 태그에 의해 서버로 전송될 때, name 속성에 적힌 값이 이름으로 지정된다 서버에서는 지정된 이름으로 입력 요소를 식별할 수 있다    * `value 속성` : value 속성에는 입력 요소의 초깃값을 작성하며 입력 요소는 보통 사용자에게서 수동으로 값을 입력받지만, 상황에 따라 초깃값을 설정해야 하는 경우가 있다 이럴 때 사용하는 속성이다- label 태그 : label 태그는 form 태그 안에서 사용하는 상호작용 요소에 이름을 붙일 때 사용한다- textarea 태그 : 여러 줄의 입력 요소를 생성할 때는 input 태그가 아닌 textarea 태그를 사용하며 웹 사이트에서 글을 작성할 때 사용하는 입력 요소는 대부분 textarea 태그로 생성한다- select, option, optgroup 태그 : elect 태그를 사용하면 콤보박스(combobox)를 생성할 수 있으며, 콤보박스에 항목 하나를 추가할 때는 option 태그를 사용하고, 항목들을 그룹으로 묶고 싶다면 optgroup 태그를 사용한다- button 태그 : input 태그에서 type 속성값을 submit, reset, button으로 지정해 생성할 수 있으며 별도의 button 태그로 생성할 수도 있다. button 태그도 마찬가지로 type 속성을 가진다테이블(Table) 관련 태그  표(table)는 웹 페이지에서 흔하게 볼 수 있는, 2차원 격자 형태로 구성된 데이터를 의미하며 표는 다음 그림처럼 행(row), 열(column) 그리고 행과 열이 만나는 셀(cell)로 구성된다- table 태그 : html에서 표를 생성할 때 사용한다폼과 동일하게 표 관련 태그는 모두 table태그 안에서 사용해야 한다- caption 태그 : 표 제목을 지정할 때 사용하는 태그- tr 태그 : 표에서 행을 생성할 때 사용하며, tr 태그 하나는 행 하나를 생성하기 때문에 행을 여러 개 생성할 때는 tr 태그를 여러 번 사용한다- th, td 태그 : 표에서 열을 생성할 때 사용하며 th태그는 표에서 제목을 나타내는 열을 생성, td태그는 표에서 일반적인 데이터를 나타내는 열을 생성한다- thead, tfoot, tbody 태그 : 표에서 행을 묶어 그룹화가 가능하다- col과 colgroup 태그 : 표에서 열을 그룹화 하고자 할 때 사용된다멀티미디어 관련 태그- audio 태그 : audio 태그는 항상 src 속성과 함께 사용하며, src 속성값에는 삽입하려고 하는 오디오 파일의 경로를 적어 준다, 그리고 오디오 컨트롤 패널이 웹 브라우저에 노출되도록 controls 속성을 설정해야 한다- video 태그 : video 태그도 비디오 경로를 입력하는 src 속성을 필수로 사용해야 하며,controls 속성을 추가해 사용자가 제어할 수 있는 컨트롤 패널도 표시해야 한다- source 태그 : audio 태그와 video 태그는 다양한 포맷을 지원하지만, 웹 브라우저별로 지원하는 포맷과 미디어 타입은 각각 다르다 예를 들어 오디오에서, MP3 포맷은 모든 웹 브라우저에서 지원하지만 WAV나 OGG 포맷은 지원하지 않는 웹 브라우저도 있다 그런데 OGG 포맷을 우선 지원하고 어쩔 수 없는 경우에만 MP3 포맷을 지원해야 하는 경우 source 태그를 사용해야한다"
  },
  
  {
    "title": "(Debian) NTP와 systemd-timesyncd",
    "url": "/posts/debian_ntp/",
    "categories": "Linux, Debian",
    "tags": "Debian",
    "date": "2023-07-09 12:33:00 +0900",
    





    
    "snippet": "systemd-timesyncd란Ubuntu는 설치가 되면 systemd-timesyncd 라는 daemon이 기본적으로 ntp(network time protocol) 서비스를 수행한다.동작 확인은 timedatectl -a 명령어로 확인이 가능하며 systemd-timesyncd의 수정은 /etc/systemd/timesyncd.conf 파일로 수...",
    "content": "systemd-timesyncd란Ubuntu는 설치가 되면 systemd-timesyncd 라는 daemon이 기본적으로 ntp(network time protocol) 서비스를 수행한다.동작 확인은 timedatectl -a 명령어로 확인이 가능하며 systemd-timesyncd의 수정은 /etc/systemd/timesyncd.conf 파일로 수정하여 사용한다NTP 설치와 설정 (서버와 클라이언트)설치하여 사용하는 NTP 패키지는 NTP서버를 구성할 수 있어서 systemd-timesyncd는 클라이언트로만 동작하여 시간을 가져오는 기능만 수행 할 수 있지만 NTP 패키지는 서버로써의 동작 및 클라이언트 동작 수행이 가능하다. systemd-timesyncd와 같이 설치 될 수 없어서 NTP 설치시 systemd-timesyncd는 삭제해주어야 한다(삭제 : sudo apt remove systemd-timesyncd)NTP 설정은 /etc/ntp.conf 파일로 수정하여 사용한다.[공통]  패키지 설치  - ntp  - ntpdate  설정 전 ntp가 먹는지 확인하기 위해 일부러 시간을 변경함  ***`# dateWed Dec 18 14:20:13 KST 2019     –&gt; 정상# date -s ”2019-10-12 09:00:00”Sat Oct 12 09:00:00 KST 2019     –&gt; 시간 변경# dateSat Oct 12 09:00:02 KST 2019     –&gt; 시간 변경 확인`***[서버 192.168.20.10]  NTP 설정 (vi /etc/ntp.conf)  `(공통 설정)#restrict 127.0.0.1    –&gt; 주석restrict 0.0.0.0 mask 0.0.0.0 nomodify notrap  –&gt; 클라이언트들이 ntp 정보를 가져갈 수 있도록 접근제한 해제#server0.centos.pool.ntp.org iburst   –&gt; 주석#server1.centos.pool.ntp.org iburst   –&gt; 주석#server2.centos.pool.ntp.org iburst   –&gt; 주석#server3.centos.pool.ntp.org iburst   –&gt; 주석server 203.248.240.140 iburst –&gt; 시간을 어디서 받아 올것인지 추가`      NTP 재기동  &lt;aside&gt;💡 #systemctl restart ntp&lt;/aside&gt;      ntp sync 확인 및 시간 변경확인      💡 # ntpq -pn      #date  Wed Dec 18 14:27:06 KST 2022 →시간 변경됨 확인        [클라이언트 192.168.20.20]  NTP 설정 (vi /etc/ntp.conf)  `(공통 설정)#restrict 127.0.0.1    –&gt; 주석#restrict 0.0.0.0 mask 0.0.0.0 nomodify notrap  –&gt; 주석#server0.centos.pool.ntp.org iburst   –&gt; 주석#server1.centos.pool.ntp.org iburst   –&gt; 주석#server2.centos.pool.ntp.org iburst   –&gt; 주석#server3.centos.pool.ntp.org iburst   –&gt; 주석#server 203.248.240.140 iburst –&gt; 주석server 192.168.20.10   –&gt; ntp server 아이피로 추가`      NTP 재기동  &lt;aside&gt;💡 #systemctl restart ntp&lt;/aside&gt;      ntp sync 확인 및 시간 변경확인      💡 # ntpq -pn      #date  Wed Dec 18 14:27:06 KST 2022 →시간 변경됨 확인        ntpq 옵션  * ntpq 설명- remote : sync 하고 있는 ntp server    &gt;ntp.conf 파일에 등록된 server ip가 출력되며 /etc/hosts파일에 매핑되는 hosts가 존재하면 해당 hostname으로 출력됩니다.        또한 현재 동기화 중인 NTP서버는 [ * ], secondary NTP서버는 [ + ] 로 표시됩니다.        ntp 프로세스가 기동된지 얼마 되지 않았거나, 네트워크 상의 문제로 NTP서버와 sync 되지 않을 시 [ *, +] 기호 없이 출력됩니다.- refid : remote의 reference 주소 라는데 설명하자면 ntpserver1 이 바라보는 주소    &gt; 현재 ntp 서버로 sycn 중인 서버가 sync중인 NTP 주소, 내부 sync면 GPS로 표시됨- st : remote stratum (GPS = stratum 0)- t : 시간을 받아보는 방식 (uniquest, multicast, broadcast)- when :  NTP 서버로 부터 데이터를 수신한 후 경과 시간, 초 단위 이며 수신받으면 0으로 초기화- poll : NTP 서버에 sync 요청 주기, 초 단위- reach : 최근 8번 poll 요청에 대한 응답 여부 - 1, 3, 7, 17, 37, 77 ,177, 377 값으로 표시될 경우 정상- delay : Network 지연시간이며, millisecond 단위- offset : NTP서버와 로컬(자신) 의 시간 차이, millisecond 단위- disp : offset 에 대한 분산 (jitter)  "
  },
  
  {
    "title": "(Debian) 잠금 설정",
    "url": "/posts/debian_suspend_set-copy/",
    "categories": "Linux, Debian",
    "tags": "Debian",
    "date": "2023-06-15 12:33:00 +0900",
    





    
    "snippet": "데비안 환경  Debian 11.5자동 밝기를 비활성화gsettings set org.gnome.settings-daemon.plugins.power ambient-enabled false블랙스크린 비활성화gsettings set org.gnome.desktop.session idle-delay 0 #비활성화gsettings set org.gnome....",
    "content": "데비안 환경  Debian 11.5자동 밝기를 비활성화gsettings set org.gnome.settings-daemon.plugins.power ambient-enabled false블랙스크린 비활성화gsettings set org.gnome.desktop.session idle-delay 0 #비활성화gsettings set org.gnome.desktop.session idle-delay 1800 #30분으로 설정 단 gui에서는 30분 항목이없어서 Never로 표시자동 절전모드 해제- gsettings set org.gnome.settings-daemon.plugins.power sleep-inactive-ac-type 'nothing'- gsettings set org.gnome.settings-daemon.plugins.power sleep-inactive-battery-type 'suspend'"
  },
  
  {
    "title": "(Debian) 한글 설정",
    "url": "/posts/debian_hangul_set/",
    "categories": "Linux, Debian",
    "tags": "Debian",
    "date": "2023-06-11 12:33:00 +0900",
    





    
    "snippet": "데비안 환경  Debian 11.51. 한글폰트 및 ibus 한글입력기 설치 (해당 폰트가 있어야 한글 출력 안깨짐)$sudo apt update$sudo apt install ibus ibus-hangul fonts-nanum 2. locale 설정 확인 및 설정#locale은 언어 설정 파일$sudo dpkg-reconfigure locales #...",
    "content": "데비안 환경  Debian 11.51. 한글폰트 및 ibus 한글입력기 설치 (해당 폰트가 있어야 한글 출력 안깨짐)$sudo apt update$sudo apt install ibus ibus-hangul fonts-nanum 2. locale 설정 확인 및 설정#locale은 언어 설정 파일$sudo dpkg-reconfigure locales #locales 설정 프로그램 열기en_US.UTF-8 #선택 되어있는지 확인(선택안되어있으면 선택), 페이지내리는 키는 page down, 선택은 스페이스바 , Tab키로 ok선택en_US.UTF-8 지정후 Enter $gnome-session-quit # 그놈 세션 빠져나오기 (로그아웃과 동일)$sudo reboot # 정상 적용 및 확인을 위해 재부팅3. 최종 설정  Settings -&gt; Region &amp; Language -&gt; Input Sources -&gt; +버튼 -&gt; Korean(Hangul)선택"
  },
  
  {
    "title": "(Nodejs) 설치 및 구동",
    "url": "/posts/nodejs2/",
    "categories": "Framework, Nodejs",
    "tags": "Nodejs",
    "date": "2023-06-11 12:33:00 +0900",
    





    
    "snippet": "NodeJS 설치  다운로드 주소  설치 후 터미널에서 node –version 명령어를 통해 확인 할 수 있다NodeJS 기본 구동const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&g...",
    "content": "NodeJS 설치  다운로드 주소  설치 후 터미널에서 node –version 명령어를 통해 확인 할 수 있다NodeJS 기본 구동const http = require('http');const hostname = '127.0.0.1';const port = 3000;const server = http.createServer((req, res) =&gt; {  res.statusCode = 200;  res.setHeader('Content-Type', 'text/plain');  res.end('Hello World');});server.listen(port, hostname, () =&gt; {  console.log(`Server running at http://${hostname}:${port}/`);});  nodejs 사이트에 기재되어있는 기본 구동 소스를 통해 간단한 .js파일을 생성한다.  node [파일명]을 통해 node.js 파일을 구동시킨다.  웹 브라우저를 통해 접속한다 (ex: 127.0.0.1:3000)"
  },
  
  {
    "title": "(Nodejs) Nodejs란",
    "url": "/posts/nodejs1/",
    "categories": "Framework, Nodejs",
    "tags": "Nodejs",
    "date": "2023-06-10 12:33:00 +0900",
    





    
    "snippet": "NodeJS란Chrome V8 Javascript 엔진으로 빌드 된 JavaScript 런타임이다.NodeJS 특징- Node.js는 JavaScript를 서버에서도 사용할 수 있도록 만든 프로그램이다.- Node.js는 V8이라는 JavaScript 엔진 위에서 동작하는 자바스크립트 런타임(환경)이다.- Node.js는 서버사이트 스크립트 언어가 아...",
    "content": "NodeJS란Chrome V8 Javascript 엔진으로 빌드 된 JavaScript 런타임이다.NodeJS 특징- Node.js는 JavaScript를 서버에서도 사용할 수 있도록 만든 프로그램이다.- Node.js는 V8이라는 JavaScript 엔진 위에서 동작하는 자바스크립트 런타임(환경)이다.- Node.js는 서버사이트 스크립트 언어가 아니다. 프로그램(환경)이다.- Node.js는 웹서버와 같이 확장성 있는 네트워크 프로그램을 제작하기 위해 만들어졌다.- NOde.js는 단일쓰레드 기반 비동기방식으로 기존 업무 처리가 완료되기 전에 또 다른 요청이 있으면 다음 처리에 요청을 보내고 다른 작업을 처리하다가 끝나고 다음꺼를 처리하기 때문에 서버 부하가 적다NodeJS 장점  낮은 진입장벽 : 새로운 언어를 습득하지 않고도 자바스크립트를 활용해 서버기술을 빠르게 개발 할 수 있다.  빠른 개발 : npm(node package manager)을 통한 다양한 모듈(패키지) 제공npm을 이용해 자신이 필요한 라이브러리와 패키지를 검색해서 설치하고 사용할 수 있기 때문에 개발속도와 효율성이 크게 향상NodeJS 단점  싱글 스레드 : 싱글 스레드 모델이기 때문에, 하나의 작업이 시간이 많이 걸리면 전체 시스템의 성능이 급격하게 떨어진다.  트러블 슈팅 : 스크립트 언어의 특성 상 해당 언어가 수행되어야 에러가 나는지 확인할 수 있고, 에러가 날 경우 프로세스가 종료된다. = 잘 죽는다"
  },
  
  {
    "title": "(Flutter) 초기 설정",
    "url": "/posts/flutter_2/",
    "categories": "Framework, Flutter",
    "tags": "Flutter",
    "date": "2023-06-04 12:33:00 +0900",
    





    
    "snippet": "안드로이드 스튜디오안드로이드 스튜디오는 안드로이드 앱 개발을 위한 IDE이다.- /*네이티브 방식*/ : 안드로이드나 IOS 같은 플랫폼 자체에서 제공하는 개발 환경으로 개발하는 방식 안드로이드는 개발 도구로 안드로이드 스튜디오를 사용하며 개발 언어로는 자바 또는 코틀린을 사용한다 ios는 맥os 환경에서만 개발이 가능하며 개발 도구로 엑스코드를 사용...",
    "content": "안드로이드 스튜디오안드로이드 스튜디오는 안드로이드 앱 개발을 위한 IDE이다.- /*네이티브 방식*/ : 안드로이드나 IOS 같은 플랫폼 자체에서 제공하는 개발 환경으로 개발하는 방식 안드로이드는 개발 도구로 안드로이드 스튜디오를 사용하며 개발 언어로는 자바 또는 코틀린을 사용한다 ios는 맥os 환경에서만 개발이 가능하며 개발 도구로 엑스코드를 사용한다 사용언어로는 스위프트 또는 오브젝티브를 사용한다- /*하이브리드 방식*/ : 웹 기술로 앱 화면을 만들고 네이티브 기술로 포장하여 앱 형태로 가공한다. 기존의 웹 기술을 활용하여 빠르게 앱을 개발 할 수 있다는 장점을 가지고 있지만, 네이티브 성능을 따라 갈 수 없으며 UI 또한 별도로 만든다.- /*크로스 플랫폼 방식*/ : 안드로이드와 IOS를 한번에 개발하는 방식으로 빌드 할 때 네이티브 코드로 변환되어 네이티브 성능과 거의 동일하다. 생산성과 품질을 비교했을때 선호하는 방식안드로이드 스튜디오 설치1. 플러터는 이곳에서 다운로드가 가능하다      낮은 진입장벽 : 네이티브 개발에 비해 플러터는 배워야 할 개념과 안드로이드 ios를 동시에 만들어 내기 때문에 더 쉽게 개발이 가능하다        높은 네이티브 성능 : 플러터는 네이티브 코드로 변환되어 성능이 네이티브와 거의 유사하다.        편리한 개발 도구 : 안드로이드 스튜디오에서 개발 할 수 있으며 비주얼 스튜디오 코드에서도 플로그인을 제공한다.  flutter 설치1. 플러터는 이곳에서 다운로드가 가능하다      SDK 설치        다운받은 파일 사용할 디렉토리에 압축 풀기        환경변수 설정        시스템 환경 변수 편집    시스템 속성 창에서 ‘고급’ 선택 -&gt; ‘환경 변수’를 선택    환경 변수 창에서 사용자 변수 중 Path를 선택 후 편집을 누른다    새로 만들기 -&gt; 찾아보기를 눌러 위에서 압축을 풀었던 flutter 폴더 내의 bin폴더를 선택후 저장한다    정상적으로 설치되고 설정되었는지 확인"
  },
  
  {
    "title": "(Flutter) Flutter란",
    "url": "/posts/flutter_1/",
    "categories": "Framework, Flutter",
    "tags": "Flutter",
    "date": "2023-06-03 12:33:00 +0900",
    





    
    "snippet": "flutter는  크로스 플랫폼 이며 Dart언어를 사용한다 다트는 구글에서 개발한 언어이며 자바 또는 자바스크립트와 비슷하다.- /*네이티브 방식*/ : 안드로이드나 IOS 같은 플랫폼 자체에서 제공하는 개발 환경으로 개발하는 방식 안드로이드는 개발 도구로 안드로이드 스튜디오를 사용하며 개발 언어로는 자바 또는 코틀린을 사용한다 ios는 맥os 환경...",
    "content": "flutter는  크로스 플랫폼 이며 Dart언어를 사용한다 다트는 구글에서 개발한 언어이며 자바 또는 자바스크립트와 비슷하다.- /*네이티브 방식*/ : 안드로이드나 IOS 같은 플랫폼 자체에서 제공하는 개발 환경으로 개발하는 방식 안드로이드는 개발 도구로 안드로이드 스튜디오를 사용하며 개발 언어로는 자바 또는 코틀린을 사용한다 ios는 맥os 환경에서만 개발이 가능하며 개발 도구로 엑스코드를 사용한다 사용언어로는 스위프트 또는 오브젝티브를 사용한다- /*하이브리드 방식*/ : 웹 기술로 앱 화면을 만들고 네이티브 기술로 포장하여 앱 형태로 가공한다. 기존의 웹 기술을 활용하여 빠르게 앱을 개발 할 수 있다는 장점을 가지고 있지만, 네이티브 성능을 따라 갈 수 없으며 UI 또한 별도로 만든다.- /*크로스 플랫폼 방식*/ : 안드로이드와 IOS를 한번에 개발하는 방식으로 빌드 할 때 네이티브 코드로 변환되어 네이티브 성능과 거의 동일하다. 생산성과 품질을 비교했을때 선호하는 방식flutter의 특징      낮은 진입장벽 : 네이티브 개발에 비해 플러터는 배워야 할 개념과 안드로이드 ios를 동시에 만들어 내기 때문에 더 쉽게 개발이 가능하다        높은 네이티브 성능 : 플러터는 네이티브 코드로 변환되어 성능이 네이티브와 거의 유사하다.        편리한 개발 도구 : 안드로이드 스튜디오에서 개발 할 수 있으며 비주얼 스튜디오 코드에서도 플로그인을 제공한다.  flutter 설치1. 플러터는 이곳에서 다운로드가 가능하다      SDK 설치        다운받은 파일 사용할 디렉토리에 압축 풀기        환경변수 설정        시스템 환경 변수 편집    시스템 속성 창에서 ‘고급’ 선택 -&gt; ‘환경 변수’를 선택    환경 변수 창에서 사용자 변수 중 Path를 선택 후 편집을 누른다    새로 만들기 -&gt; 찾아보기를 눌러 위에서 압축을 풀었던 flutter 폴더 내의 bin폴더를 선택후 저장한다    정상적으로 설치되고 설정되었는지 확인"
  },
  
  {
    "title": "(Vmware) 공유폴더 설정",
    "url": "/posts/vmware_dirshare/",
    "categories": "Utils, Vmware",
    "tags": "Vmware",
    "date": "2023-05-29 12:33:00 +0900",
    





    
    "snippet": "vmware 공유폴더 설정1.vmware 세션 설정에서 Shared Folders를 Always enabled로 변경하고 Add버튼을 눌러 호스트PC에서 공유 할 폴더를 지정한다.2.vmware 툴바 설치를 진행 한다3.게스트os(필자는 debian11)에서 sudo apt-get install open-vm-tools 명령어로 툴바에 필요한 파일 설...",
    "content": "vmware 공유폴더 설정1.vmware 세션 설정에서 Shared Folders를 Always enabled로 변경하고 Add버튼을 눌러 호스트PC에서 공유 할 폴더를 지정한다.2.vmware 툴바 설치를 진행 한다3.게스트os(필자는 debian11)에서 sudo apt-get install open-vm-tools 명령어로 툴바에 필요한 파일 설치4.게스트os(필자는 debian11)에서 sudo /usr/bin/vmhgfs-fuse .host:/ /mnt -o subtype=vmhgfs-fuse,allow_other 명령어 실행5.재부팅했을때에도 자동 마운트가 가능하게 하기 위해서 /etc/fstab 파일에 최하단에 아래 내용을 추가 및 저장하고 재부팅한다.vmhgfs-fuse /mnt/hgfs fuse defaults,allow_other 0 06.게스트os(필자는 debian11)에서 mnt/hgfs로 이동하면 1번 사항에서 공유한 폴더에 접근이 가능하다."
  },
  
  {
    "title": "(Debian) sudoers 설정",
    "url": "/posts/debian_sudoer_setting/",
    "categories": "Linux, Debian",
    "tags": "Debian",
    "date": "2023-05-27 12:33:00 +0900",
    





    
    "snippet": "sudoer이란  sudo 명령은 일반 사용자가 관리자 권한(root)의 명령을 수행하고자 할 떄 사용하는 명령어이다.superuser do, substitute user do 등의 약자로 알려져있다.su 명령은 root의 비밀번호를 알려줘야 한다는 부담감이 있으며 최소 권한의 원칙에 따라 root 로그인을 차단하는 것이 좋다. sudo 명령을 사용하...",
    "content": "sudoer이란  sudo 명령은 일반 사용자가 관리자 권한(root)의 명령을 수행하고자 할 떄 사용하는 명령어이다.superuser do, substitute user do 등의 약자로 알려져있다.su 명령은 root의 비밀번호를 알려줘야 한다는 부담감이 있으며 최소 권한의 원칙에 따라 root 로그인을 차단하는 것이 좋다. sudo 명령을 사용하여 제한적으로 관리자 권한의 명령을 실행하도록 하는 점에서sudo를 권장한다sudo 명령의 설정 파일 : /etc/sudoersdebian sudoer설정  debian은 다른 os와 다르게 os설치시 설정하는 계정에 sudo 권한이 자동으로 부여되지 않는다.따라서 os설치 후 수동으로 설정을 변경해주어야한다.sudoers파일은 sudo명령어에 대한 설정을 다루는 파일이고 이곳에 sudo명령어를 사용할 수 있는 계정을 지정할수 있다.그 외에도 여러가지 설정에 대한 부분이 있으며 /etc/sudoers 에 위치하고 있다. 기본으로 지정된 내용을 보면 root   ALL=(ALL) ALL 이라는 부분이 있는데 이 설정이 root 유저가 sudo명령어를 사용할 수 있도록 하는 부분이다."
  },
  
  {
    "title": "(Linux) vi편집기",
    "url": "/posts/linux_vi/",
    "categories": "Linux",
    "tags": "Linux",
    "date": "2023-05-20 12:33:00 +0900",
    





    
    "snippet": "vi 편집기란vi편집기는 리눅스 계열의 시스템에서 제일 많이 사용되고있는 제일 보편적인 편집기다vi 편집기에는 아래 3개의 모드를 지원한다  명령모드  입력모드  콜론 모드vi 명령어  명령 모드에서 입력 모드로 전환      i : 커서 앞(왼쪽)에 입력    a : 커서 다음(오른쪽)에 입력    입력 모드에서 명령 모드로 전환      ESC  ...",
    "content": "vi 편집기란vi편집기는 리눅스 계열의 시스템에서 제일 많이 사용되고있는 제일 보편적인 편집기다vi 편집기에는 아래 3개의 모드를 지원한다  명령모드  입력모드  콜론 모드vi 명령어  명령 모드에서 입력 모드로 전환      i : 커서 앞(왼쪽)에 입력    a : 커서 다음(오른쪽)에 입력    입력 모드에서 명령 모드로 전환      ESC    저장 및 종료하기 (명령모드에서 콜론:을 사용하여 콜론 모드에서 입력)      q : 저장하지 않고 편집기 종료    q! : 저장하지 않고 강제로 종료    w : 저장    wq : 저장 후 종료    ZZ : 저장 후 종료 (wq와 동일)    wq 파일이름 : 저장 후 파일 이름 지정    커서 이동      h, j, k, l : 좌,하,상,우 커서 이동 (방향 키가 없는 키보드에서 사용)    w : 다음 단어의 첫 글자로 이동    b : 이전 단어의 첫 글자로 이동    G : 마지막 행으로 가기    :숫자: 지정한 숫자 행으로 이동    삭제      x : 커서에 있는 글자 삭제    X : 커서 앞에 있는 글자 삭제    dw : 커서를 기준으로 뒤에 있는 단어 글자 삭제 (커서 포함)    db : 커서를 기준으로 앞에 있는 단어 글자 삭제    dd : 커서가 있는 라인(줄) 삭제    복사      yw : 커서를 기준으로 뒤에 있는 단어 글자 복사 (커서 포함)    yb : 커서를 기준으로 앞에 있는 단어 글자 복사    yy : 커서가 있는 라인(줄) 복사    붙여넣기      p : 커서 다음에 붙여넣기    P : 커서 이전에 붙여넣기    찾기      /문자열 : 앞에서 부터 문자열을 찾는다    ?문자열 : 뒤에서 부터 문자열을 찾는다    n : 뒤로 검색    N : 앞으로 검색    되돌리기, 다시실행      u : 이전으로 되돌리기    Ctrl + r : 되돌리기한 것을 다시 복구    자주 사용하는 명령어      :set number :행번호를 출력    :set nonumber : 행번호를 숨김    :cd: 현재 디렉토리를 출력  "
  },
  
  {
    "title": "(Raid) Raid의 정의와 구성",
    "url": "/posts/RAID/",
    "categories": "Linux",
    "tags": "Linux",
    "date": "2023-05-20 12:33:00 +0900",
    





    
    "snippet": "RAID 정의  Raid(redundant array of independent/inexpensive disks)는 여러 개의 드라이브를 하나의 논리적인 유닛으로 묶어주는 저장 기술이다RAID 0(스트라이핑)  RAID 0 또는 스트라이핑은 배열 드라이브에 데이터를 분산시킨다.작업부하가 각 드라이브로 병렬화되고 분산되기 때문에,여러 환경에서의 읽기 및...",
    "content": "RAID 정의  Raid(redundant array of independent/inexpensive disks)는 여러 개의 드라이브를 하나의 논리적인 유닛으로 묶어주는 저장 기술이다RAID 0(스트라이핑)  RAID 0 또는 스트라이핑은 배열 드라이브에 데이터를 분산시킨다.작업부하가 각 드라이브로 병렬화되고 분산되기 때문에,여러 환경에서의 읽기 및 쓰기 처리량이 개선된다. RAID 0을 위해서는 최소한 2개의 드라이브가 필요하며, 데이터가 분산되는 방식 때문에 배열 드라이브의 전체 용량이 하나로 통합된다. 예를 들어 스트라이프 RAID 0 구성에서 쌍을 이룬 2개의 1TB 드라이브는 하나의 2TB 볼륨으로 인식된다. 하지만 RAID 0 는 패리티(Parity) 데이터를 미러링(Mirroring) 처리하거나 저장하지 않기 때문에, 하나의 디스크에 문제가 발생하면 나머지 디스크에 저장된 데이터가 무용지물이 된다.RAID 1(미러링)  RAID 0 과의 반대로 안정성에 방향을 둔 레벨로 데이터 저장소를 서로 복제형태로 하나의 데이터를 양쪽에 디스크에 동일하게 기록 한다, 데이터의 저장용량은 줄어들지만 데이터를 양쪽에 각각 보관함으로써 안정성을 높였다.RAID 4RAID 5(패리티 스트라이핑)"
  },
  
  {
    "title": "(Network) 본딩의 정의와 설정방법",
    "url": "/posts/Bonding/",
    "categories": "Network",
    "tags": "Network",
    "date": "2023-05-17 12:33:00 +0900",
    





    
    "snippet": "본딩이란(Bonding)  본딩(Bonding)이란 여러개의 물리적인 NIC카드를 논리적으로 묶어서 대역폭을 확장하거나 NIC카드 장애가 발생 할 경우 정상적인 NIC카드로 네트워크 서비스를 자동으로 변경해주는 기능본딩 설정방법(centos)  Redhat에서의 네트워크 본딩 설정방법을 정의합니다.1. 현재OS 확인[root@localhost ~]# ...",
    "content": "본딩이란(Bonding)  본딩(Bonding)이란 여러개의 물리적인 NIC카드를 논리적으로 묶어서 대역폭을 확장하거나 NIC카드 장애가 발생 할 경우 정상적인 NIC카드로 네트워크 서비스를 자동으로 변경해주는 기능본딩 설정방법(centos)  Redhat에서의 네트워크 본딩 설정방법을 정의합니다.1. 현재OS 확인[root@localhost ~]# cat /etc/redhat-releaseCentOS Linux release 7.9.2009 (Core)2. 네트워크 인터페이스명 확인[root@localhost ~]# ip aens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.91.128  netmask 255.255.255.0  broadcast 192.168.91.255        inet6 fe80::20c:29ff:fe87:b70e  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:87:b7:0e  txqueuelen 1000  (Ethernet)        RX packets 226  bytes 22388 (21.8 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 172  bytes 26838 (26.2 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens36: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.91.129  netmask 255.255.255.0  broadcast 192.168.91.255        inet6 fe80::20c:29ff:fe87:b718  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:87:b7:18  txqueuelen 1000  (Ethernet)        RX packets 9  bytes 1104 (1.0 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 22  bytes 2236 (2.1 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 10  bytes 1010 (1010.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 10  bytes 1010 (1010.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@localhost ~]#3.네트워크 인터페이스를 설정하는 곳으로 이동[root@localhost network-scripts]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]#4.본딩 할 인터페이스 파일 수정[root@localhost network-scripts]# vi ifcfg-ens33BOOTPROTO=noneNAME=ens33DEVICE=ens33ONBOOT=yesMASTER=bond0SLAVE=yes[root@localhost network-scripts]# vi ifcfg-ens36BOOTPROTO=dhcpNAME=ens36DEVICE=ens36ONBOOT=yesMASTER=bond0SLAVE=yes[root@localhost network-scripts]#5.본딩 설정 파일을 생성하고 설정[본딩모드 옵션][root@localhost network-scripts]# vi ifcfg-bond0BOOTPROTO=noneNAME=bond0DEVICE=bond0ONBOOT=yesTYPE=BondIPADDR=192.168.91.110 # 서비스 사용 할 IPNETMASK=255.255.255.0GATEWAY=192.168.91.2BONDING_OPTS=mode=1 miimon=10 primary=ens33 fail_over_mac=1 #본딩모드 옵션[root@localhost network-scripts]#6.네트워크 이슈를 예방하기 위한 네트워크관리자 중지[root@localhost network-scripts]# sudo systemctl stop NetworkManager[root@localhost network-scripts]# sudo systemctl disable NetworkManager[root@localhost network-scripts]# sudo systemctl status NetworkManager #종료 상태확인7.본딩 모듈 적재[root@localhost network-scripts]# modprobe --first-time bonding[root@localhost network-scripts]#8.네트워크 서비스 재시작[root@localhost network-scripts]# sudo systemctl restart network[root@localhost network-scripts]#9.본딩이 정상 동작하는지 확인[root@localhost ~]# cat /proc/net/bonding/bond0Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)Bonding Mode: fault-tolerance (active-backup) (fail_over_mac active)Primary Slave: ens33 (primary_reselect always)Currently Active Slave: ens33MII Status: upMII Polling Interval (ms): 10Up Delay (ms): 0Down Delay (ms): 0Slave Interface: ens33MII Status: upSpeed: 1000 MbpsDuplex: fullLink Failure Count: 0Permanent HW addr: 00:0c:29:87:b7:0eSlave queue ID: 0Slave Interface: ens36MII Status: upSpeed: 1000 MbpsDuplex: fullLink Failure Count: 0Permanent HW addr: 00:0c:29:87:b7:18Slave queue ID: 0[root@localhost ~]#"
  },
  
  {
    "title": "(Network) 클라우드 서비스의 종류(DaaS/SaaS/PaaS)",
    "url": "/posts/DaaS_SaaS/",
    "categories": "Network",
    "tags": "Network",
    "date": "2023-05-17 12:33:00 +0900",
    





    
    "snippet": "DaaS(Desktop as a Service)  DaaS는 클라우드 인프라를 이용해 사용자가 개인용 컴퓨터가 없어도 원격 인프라에 구축된 서비스를 이용할 수 있는것SaaS(Software as a Service)  DaaS는 클라우드 인프라를 이용해 사용자가 개인용 컴퓨터가 없어도 원격 인프라에 구축된 서비스를 이용할 수 있는것PaaS(Platfor...",
    "content": "DaaS(Desktop as a Service)  DaaS는 클라우드 인프라를 이용해 사용자가 개인용 컴퓨터가 없어도 원격 인프라에 구축된 서비스를 이용할 수 있는것SaaS(Software as a Service)  DaaS는 클라우드 인프라를 이용해 사용자가 개인용 컴퓨터가 없어도 원격 인프라에 구축된 서비스를 이용할 수 있는것PaaS(Platform as a Service)  DaaS는 클라우드 인프라를 이용해 사용자가 개인용 컴퓨터가 없어도 원격 인프라에 구축된 서비스를 이용할 수 있는것VDI와 DaaS의 차이점  VDI와 DaaS 모두 사용자가 가상 ​​데스크톱에 액세스할 수 있도록 하고 관리자가 회사 내의 각 개별 장치에 운영 체제를 설치 및 관리하지 않아도 된다.  그러나 이러한 두 가지 유형의 가상화에는 주요 차이점이 존재한다.  VDI를 통해 조직은 자체 온프레미스 데이터 센터에서 가상 데스크톱을 배포한다. 사내 IT 팀은 가상 데스크톱 배포와 인프라 구매, 관리 및 업그레이드를 담당하지만 DaaS 솔루션을 구독하는 조직은 자체 하드웨어를 관리할 필요가 없으며 사용자당 지불 구독 모델을 사용하여 필요에 따라 확장하거나 축소한다.  즉 VDI와 DaaS의 큰 차이점은 해당 인프라 구축 및 관리를 누가하냐에 따라 달라지는 형태이다."
  },
  
  {
    "title": "(Mariadb) 이중화란",
    "url": "/posts/ha_mariadb/",
    "categories": "Linux",
    "tags": "Linux",
    "date": "2023-05-13 12:33:00 +0900",
    





    
    "snippet": "HA(High Availability, 고가용성)이란  이중화(HA)는 서비스의 연속성 보장을 위해 서버 2대 이상을 통해 한쪽 서버가 장애 시 다른 서버가 해당 서비스를 대신 운영하여 가용성을 높이는 솔루션이다.HA 방식1. Active-Standby  Active-Standby 구성은 하나의 Master서버와 여러대의 Slave 서버로 구성된다.M...",
    "content": "HA(High Availability, 고가용성)이란  이중화(HA)는 서비스의 연속성 보장을 위해 서버 2대 이상을 통해 한쪽 서버가 장애 시 다른 서버가 해당 서비스를 대신 운영하여 가용성을 높이는 솔루션이다.HA 방식1. Active-Standby  Active-Standby 구성은 하나의 Master서버와 여러대의 Slave 서버로 구성된다.Master는 Read-Write를 제공하며 Slave 서버는 Master의 데이터만 동기화하며 서비스 제공은 하지 않는다.평상시에는 Master서버가 Active상태로 서비스를 제공하다가 Master 서버에서 장애요소가 발생시 Slave 서버가 Master 서버로 승격하여 Active상태로 서비스를 제공한다.2. Active-Active  Active-Active 구성은 여러대의 서버가 동기화하며 서비스를 제공한다.Active-Standby는 Master서버의 장애요소를 Slave서버가 파악하는데 까지의 소요시간(Faill over time)이 필요하지만 Active-Active는 해당 소요시간이 발생하지 않는다."
  },
  
  {
    "title": "(Hypervisor) 하이퍼바이저란",
    "url": "/posts/Hypervisor/",
    "categories": "Linux",
    "tags": "Linux",
    "date": "2023-05-08 12:33:00 +0900",
    





    
    "snippet": "hypervisor(하이퍼바이저)란?  가상 머신(Virtual Machine, VM)을 생성하고 구동하는 프로그램이다. 하이퍼바이저는 가상 운영 체제를 관리하며 운영하면서 해당 인스턴스들의 하드웨어 리소스를 공유할 수 있다.  전가상화/반가상화/호스트기반      전 가상화(bare-metal/hypervisor)OS위에 하이퍼바이저가 동작하는것이 ...",
    "content": "hypervisor(하이퍼바이저)란?  가상 머신(Virtual Machine, VM)을 생성하고 구동하는 프로그램이다. 하이퍼바이저는 가상 운영 체제를 관리하며 운영하면서 해당 인스턴스들의 하드웨어 리소스를 공유할 수 있다.  전가상화/반가상화/호스트기반      전 가상화(bare-metal/hypervisor)OS위에 하이퍼바이저가 동작하는것이 아닌 하드웨어 바로 위에 하이퍼바이저가 동작하여 가상 머신을 생성 및 구동하는 형태    반 가상화(para-virtualization)          전 가상화의 경우는 하이퍼바이저가 생성한 VM은 하드웨어 자원을 사용 할 수 없고 하이퍼바이저를 통해서만 사용이 가능했다 하지만 반 가상화는 하이퍼바이저가 생성한 VM에서 하이퍼바이저 없이 하드웨어 리소스를 사용 할 수 있다하지만 반 가상화를 사용하기 위해서는 VM에서 각 커널을 일일이 수정해줘야한다는 어려움이 있다        호스트 기반 가상화          하드웨어 위에 OS를 설치해서 OS위에 하이퍼바이저가 구동하는 형태      "
  },
  
  {
    "title": "(Network) NAT, Bridge, Host-Only란",
    "url": "/posts/nat_bridge_host-copy-2/",
    "categories": "Network",
    "tags": "Network",
    "date": "2023-05-06 12:33:00 +0900",
    





    
    "snippet": "NAT(Network Address Translation)  NAT방식으로 네트워크를 구성하게 되면 호스트 PC로부터 IP를 할당 받아 가상머신 프로그램이 자체 DHCP서버를 만들어 내부 네트워크에 대역 할당 및 통신을 한다 Host 공인 IP를 통해 외부 네트워크와 통신이 가능하다 (단 외부에서는 내부 네트워크 대역을 알 수 없기 때문에 내부에서 외...",
    "content": "NAT(Network Address Translation)  NAT방식으로 네트워크를 구성하게 되면 호스트 PC로부터 IP를 할당 받아 가상머신 프로그램이 자체 DHCP서버를 만들어 내부 네트워크에 대역 할당 및 통신을 한다 Host 공인 IP를 통해 외부 네트워크와 통신이 가능하다 (단 외부에서는 내부 네트워크 대역을 알 수 없기 때문에 내부에서 외부로만 나가는 단방향 통신이 가능하다)Bridged(브릿지)  Bridged 방식으로 네트워크를 구성하게 되면 Host가 가상pc의 다리(Bridge)역할을 한다 가상pc는 Host와 동일한 공인ip 대역을 부여 받아 사용가능하며 따라서 외부에서도 가상pc로 접근이 가능하게 된다.Host-Only  Host-Only 방식으로 네트워크를 구성하게 되면 가상pc는 외부 인터넷을 사용 할 수 없으며 host하고만 통신이 가능하다NAT 구성과의 차이는 NAT는 외부 인터넷까지는 사용이 가능하고 외부PC에서 가상pc로 통신을 할 수 없었지만 Host-Only는 외부pc접근 불가는 물론 외부 인터넷까지 사용이 불가능하다"
  },
  
  {
    "title": "(Network) vpn이란",
    "url": "/posts/vpn/",
    "categories": "Network",
    "tags": "Network",
    "date": "2023-05-04 12:33:00 +0900",
    





    
    "snippet": "vpn을 이해하기 위한 사설망과 공중망의 개념            사설망(Private Network) : 사설 ip를 사용하여 별도 네트워크를 구성하며 외부 인터넷과 내부 네트워크를 분리한다 즉 외부 인터넷의 접근으로부터 내부 네트워크를 보호할 수 있다 기업의 예로 본사 사설망과 지사 사설망을 따로 구성하여 전용 회선으로만 연결하여 사용한다.    ...",
    "content": "vpn을 이해하기 위한 사설망과 공중망의 개념            사설망(Private Network) : 사설 ip를 사용하여 별도 네트워크를 구성하며 외부 인터넷과 내부 네트워크를 분리한다 즉 외부 인터넷의 접근으로부터 내부 네트워크를 보호할 수 있다 기업의 예로 본사 사설망과 지사 사설망을 따로 구성하여 전용 회선으로만 연결하여 사용한다.              공중망(public Network) : 사설망과 대칭되는 내용으로 불특정 다수의 사용자들이 사용되는 일반적인 네트워크망이다 전화망이나 인터넷처럼 모두에게 공개되며 어느 누구와 언제든 정보 및 데이터 교환이 가능함에 따라 보안성이 취약하다      vpn(Virtual Private Network) 정의      vpn은 공중망 인터넷을 사이에 둔 사설망과 사설망간 공인 IP로 NAT와 같은 제약 없이 사설 IP를 사용하여 통신 할 수 있도록 Routing을 지원하며 데이터의 암호화 기능을 제공한다. 따라서 vpn은 공인 인터넷에서 캡슐화 및 데이터 암호화를 사용하며 패킷 탈취를 방어하기 위해 터널링(Tunneling) 기술을 사용한다.  vpn 사용 목적1. 장거리 전용망 구축 비용 대비 네트워크 운영비용 절감 및 변경에 대한 유연성을 확보 가능2. 두 호스트 간 데이터 유출 없이 통신이 가능하며 보안 관리가 효율적이다3. 네트워크 이동성 및 확장성이 보장되어 재택 및 원격지 사용에 부담이 적다vpn의 기술 정의            터널링(Tunneling): 공중망상에서 사설 전용망과 같은 보안효과를 주기 위한 기술이며 vpn 내의 두 네트워크 간에 가상경로(Routing)를 사용하여 사용자에게 투명한 통신 제공              터널링(Tunneling)을 지원하는 프로토콜: PPTP(Point-to-Point), L2TP(Layer2 Tunneling Protocol), L2F(Layer2 Fowarding Protocol), IPsec      "
  },
  
  {
    "title": "(Linux) docker의 개념",
    "url": "/posts/docker1/",
    "categories": "Linux, docker",
    "tags": "Linux, docker",
    "date": "2023-04-25 12:33:00 +0900",
    





    
    "snippet": "Docker란도커(docker)는 하나의 OS에 가상 머신처럼 독립된 여러개의 실행환경을 만들어주는 것으로, 사용시에 아래와 같은 이점을 얻을 수 있다      구성 단순화          Docker는 하나의 Configuration으로 모든 플랫폼에서 실행할 수 있다. Configuration 파일을 코드에 넣고 환경 변수를 전달하여 다른 환경에 ...",
    "content": "Docker란도커(docker)는 하나의 OS에 가상 머신처럼 독립된 여러개의 실행환경을 만들어주는 것으로, 사용시에 아래와 같은 이점을 얻을 수 있다      구성 단순화          Docker는 하나의 Configuration으로 모든 플랫폼에서 실행할 수 있다. Configuration 파일을 코드에 넣고 환경 변수를 전달하여 다른 환경에 맞출 수 있다. 따라서 하나의 Docker 이미지를 다른 환경에서 사용할 수 있다.            코드 관리          Docker는 일관된 환경을 제공하여 개발 및 코딩을 훨씬 편안하게 만들어준다. Docker 이미지는 변경이 불가하기에 개발환경에서 운영 환경까지 애플리케이션 환경이 변경되지 않는 이점이 존재한다.            개발 생산성 향상          개발 환경을 운영 환경에 최대한 가깝게 복제할 수 있다. Docker를 사용하면 코드가 운영 환경의 컨테이너에서 실행될 수 있으며 VM과 달리 Docker는 오버 헤드 메모리 용량이 적기에 여러 서비스를 실행하는데 도움이 된다. 또한 Docker의 Shared Volume을 사용하여 호스트에서 컨테이너의 어플리케이션 코드를 사용할 수 있도록 할 수 있다. 이를 통해 개발자는 자신의 플랫폼 및 편집기에서 소스 코드를 편집할 수 있으며 이는 Docker내에서 실행 중인 환경에 반영된다.            애플리케이션 격리          Web Server(e.g. Apache, Nginx)와 연결된 API 서버를 격리할 필요가 있는 경우가 있다. 이 경우 다른 컨테이너에서 API를 서버를 실행할 수 있다.            빠른 배포          컨테이너가 OS를 부팅하지 않고 어플리케이션을 실행하기 때문에 Docker 컨테이너를 매우 빠르게 만들 수 있다.      Docker컨테이너기존에 vm가상화 기술은 하나의 OS안에 여러개의 OS를 생성하는 가상화 방식이지만 컨테이너 가상화 기술은 OS레벨의 가상화로 프로세만 격리시켜 동작하는 방식이다Docker이미지Docker Image란 컨테이너를 실행 할 수 있는 실행파일과 설정 값 들을 가지고 있는 파일이다Docker 컨테이너에 이미지를 넣고 실행을 시키면 해당 프로세스가 동작한다Docker엔진"
  }
  
]

